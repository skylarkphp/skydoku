{"version":3,"sources":["Upload.js"],"names":["define","types","objects","arrays","Deferred","Evented","Xhr","http","blobSlice","Blob","prototype","slice","webkitSlice","mozSlice","Upload","inherit","klassName","_construct","options","this","_options","mixin","debug","url","maxConnections","maxChunkSize","undefined","onProgress","id","fileName","loaded","total","onComplete","onCancel","onFailure","e","_queue","_params","_files","_xhrs","_loaded","add","file","push","send","params","indexOf","len","copy","clone","_send","sendAll","length","cancel","_cancel","_dequeue","cancelAll","i","getName","name","getSize","fileSize","size","getLoaded","curUploadingSize","chunkSize","curLoadedSize","args","headers","xhr","data","call","type","formParamName","formData","FormData","append","self","post","progress","lengthComputable","then","catch","abort","getQueue","inArray","splice","max","nextId"],"mappings":";;;;;;;AAAAA,QACI,sBACA,wBACA,uBACA,+BACA,gCACA,QACA,UACF,SAASC,EAAOC,EAASC,EAAQC,EAAUC,EAAQC,EAAKC,GAEtD,IAAIC,EAAYC,KAAKC,UAAUC,OAASF,KAAKC,UAAUE,aAAeH,KAAKC,UAAUG,SAMjFC,EAAST,EAAQU,SACjBC,UAAY,SAEZC,WAAa,SAASC,GAClBC,KAAKC,SAAWlB,EAAQmB,OACpBC,OAAO,EACPC,IAAK,UAELC,eAAgB,IAKhBC,kBAAcC,EAEdC,WAAY,SAASC,EAAIC,EAAUC,EAAQC,KAE3CC,WAAY,SAASJ,EAAIC,KAEzBI,SAAU,SAASL,EAAIC,KAEvBK,UAAY,SAASN,EAAGC,EAASM,MAEnCjB,GAEFC,KAAKiB,UAELjB,KAAKkB,WAELlB,KAAKmB,UACLnB,KAAKoB,SAGLpB,KAAKqB,YAQTC,IAAK,SAASC,GACV,OAAOvB,KAAKmB,OAAOK,KAAKD,GAAQ,GAMpCE,KAAM,SAAShB,EAAIiB,GACf,GAAK1B,KAAKmB,OAAOV,MAIbT,KAAKiB,OAAOU,QAAQlB,IAAK,GAA7B,CAIA,IAAImB,EAAM5B,KAAKiB,OAAOO,KAAKf,GAEvBoB,EAAO9C,EAAQ+C,MAAMJ,GAEzB1B,KAAKkB,QAAQT,GAAMoB,EAGfD,GAAO5B,KAAKC,SAASI,gBACrBL,KAAK+B,MAAMtB,EAAIT,KAAKkB,QAAQT,MAOpCuB,QAAS,SAASN,GACf,IAAK,IAAIjB,EAAK,EAAGA,EAAIT,KAAKmB,OAAOc,OAAQxB,IACpCT,KAAKyB,KAAKhB,EAAGiB,IAOrBQ,OAAQ,SAASzB,GACbT,KAAKmC,QAAQ1B,GACbT,KAAKoC,SAAS3B,IAMlB4B,UAAW,WACP,IAAK,IAAIC,EAAE,EAAGA,EAAEtC,KAAKiB,OAAOgB,OAAQK,IAChCtC,KAAKmC,QAAQnC,KAAKiB,OAAOqB,IAE7BtC,KAAKiB,WAGTsB,QAAS,SAAS9B,GACd,IAAIc,EAAOvB,KAAKmB,OAAOV,GACvB,OAAwB,MAAjBc,EAAKb,SAAmBa,EAAKb,SAAWa,EAAKiB,MAGxDC,QAAS,SAAShC,GACd,IAAIc,EAAOvB,KAAKmB,OAAOV,GACvB,OAAwB,MAAjBc,EAAKmB,SAAmBnB,EAAKmB,SAAWnB,EAAKoB,MAMxDC,UAAW,SAASnC,GAChB,OAAOT,KAAKqB,QAAQZ,IAAO,GAQ/BsB,MAAO,SAAStB,EAAIiB,GAChB,IAIImB,EAJA9C,EAAUC,KAAKC,SACfuC,EAAOxC,KAAKuC,QAAQ9B,GACpBkC,EAAO3C,KAAKyC,QAAQhC,GACpBqC,EAAY/C,EAAQO,cAAgB,EAEpCyC,EAAgB,EAChBxB,EAAOvB,KAAKmB,OAAOV,GACnBuC,GACIC,YAIRjD,KAAKqB,QAAQZ,GAAMT,KAAKqB,QAAQZ,IAAO,EAEvC,IAAIyC,EAAMlD,KAAKoB,MAAMX,GAAM,IAAItB,GAC3BiB,IAAML,EAAQK,MAGlB,GAAI0C,EAEAE,EAAKG,KAAO9D,EAAU+D,KAClB7B,EACAvB,KAAKqB,QAAQZ,GACbT,KAAKqB,QAAQZ,GAAMqC,EACnBvB,EAAK8B,MAITR,EAAmBG,EAAKG,KAAKR,KAE7BK,EAAKC,QAAQ,iBAAmB,SAAWjD,KAAKqB,QAAQZ,GAAM,KACzDT,KAAKqB,QAAQZ,GAAMoC,EAAmB,GAAK,IAAMF,EACtDK,EAAKC,QAAQ,gBAAkB,+BAC3B,CACJJ,EAAmBF,EACnB,IAAIW,EAAiB5B,EAAO4B,cACxBC,EAAW7B,EAAO6B,SAElBD,GACKC,IACDA,EAAW,IAAIC,UAEnBD,EAASE,OAAOH,EAAc/B,GAC9ByB,EAAKG,KAAOI,IAGZP,EAAKC,QAAQ,gBAAkB1B,EAAK8B,MAAQ,2BAC5CL,EAAKG,KAAO5B,GAKpB,IAAImC,EAAO1D,KACXkD,EAAIS,KACAX,GACFY,SAAS,SAAS5C,GACZA,EAAE6C,mBACFd,GAAgC/B,EAAEL,OAClC+C,EAAKrC,QAAQZ,GAAMiD,EAAKrC,QAAQZ,GAAMO,EAAEL,OACxC+C,EAAKzD,SAASO,WAAWC,EAAI+B,EAAMkB,EAAKrC,QAAQZ,GAAKkC,MAE1DmB,KAAK,WACCJ,EAAKvC,OAAOV,KAKbsC,EAAgBF,IAIhBa,EAAKrC,QAAQZ,GAAMiD,EAAKrC,QAAQZ,GAAMoC,EAAmBE,EACzDW,EAAKzD,SAASO,WAAWC,EAAI+B,EAAMkB,EAAKrC,QAAQZ,GAAKkC,IAGrDe,EAAKrC,QAAQZ,GAAKkC,EAGlBe,EAAK3B,MAAMtB,EAAGiB,IAEdgC,EAAKzD,SAASY,WAAWJ,EAAG+B,GAE5BkB,EAAKvC,OAAOV,GAAM,KAClBiD,EAAKtC,MAAMX,GAAM,KACjBiD,EAAKtB,SAAS3B,OAInBsD,MAAM,SAAS/C,GACd0C,EAAKzD,SAASc,UAAUN,EAAG+B,EAAKxB,GAEhC0C,EAAKvC,OAAOV,GAAM,KAClBiD,EAAKtC,MAAMX,GAAM,KACjBiD,EAAKtB,SAAS3B,MAItB0B,QAAS,SAAS1B,GACdT,KAAKC,SAASa,SAASL,EAAIT,KAAKuC,QAAQ9B,IAExCT,KAAKmB,OAAOV,GAAM,KAEdT,KAAKoB,MAAMX,KACXT,KAAKoB,MAAMX,GAAIuD,QACfhE,KAAKoB,MAAMX,GAAM,OAQzBwD,SAAU,WACN,OAAOjE,KAAKiB,QAOhBmB,SAAU,SAAS3B,GACf,IAAI6B,EAAItD,EAAOkF,QAAQzD,EAAGT,KAAKiB,QAC/BjB,KAAKiB,OAAOkD,OAAO7B,EAAG,GAEtB,IAAI8B,EAAMpE,KAAKC,SAASI,eAExB,GAAIL,KAAKiB,OAAOgB,QAAUmC,GAAO9B,EAAI8B,EAAI,CACrC,IAAIC,EAASrE,KAAKiB,OAAOmD,EAAI,GAC7BpE,KAAK+B,MAAMsC,EAAQrE,KAAKkB,QAAQmD,QAK5C,OAAOjF,EAAKO,OAASA","file":"../Upload.js","sourcesContent":["define([\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-objects\",\r\n    \"skylark-langx-arrays\",\r\n    \"skylark-langx-async/Deferred\",\r\n    \"skylark-langx-emitter/Evented\",    \r\n    \"./Xhr\",\r\n    \"./http\"\r\n],function(types, objects, arrays, Deferred, Evented,Xhr, http){\r\n\r\n    var blobSlice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n\r\n\r\n    /*\r\n     *Class for uploading files using xhr.\r\n     */\r\n    var Upload = Evented.inherit({\r\n        klassName : \"Upload\",\r\n\r\n        _construct : function(options) {\r\n            this._options = objects.mixin({\r\n                debug: false,\r\n                url: '/upload',\r\n                // maximum number of concurrent uploads\r\n                maxConnections: 999,\r\n                // To upload large files in smaller chunks, set the following option\r\n                // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n                // or the browser does not support the required Blob API, files will\r\n                // be uploaded as a whole.\r\n                maxChunkSize: undefined,\r\n\r\n                onProgress: function(id, fileName, loaded, total){\r\n                },\r\n                onComplete: function(id, fileName){\r\n                },\r\n                onCancel: function(id, fileName){\r\n                },\r\n                onFailure : function(id,fileName,e) {                    \r\n                }\r\n            },options);\r\n\r\n            this._queue = [];\r\n            // params for files in queue\r\n            this._params = [];\r\n\r\n            this._files = [];\r\n            this._xhrs = [];\r\n\r\n            // current loaded size in bytes for each file\r\n            this._loaded = [];\r\n\r\n        },\r\n\r\n        /**\r\n         * Adds file to the queue\r\n         * Returns id to use with upload, cancel\r\n         **/\r\n        add: function(file){\r\n            return this._files.push(file) - 1;\r\n        },\r\n\r\n        /**\r\n         * Sends the file identified by id and additional query params to the server.\r\n         */\r\n        send: function(id, params){\r\n            if (!this._files[id]) {\r\n                // Already sended or canceled\r\n                return ;\r\n            }\r\n            if (this._queue.indexOf(id)>-1) {\r\n                // Already in the queue\r\n                return;\r\n            }\r\n            var len = this._queue.push(id);\r\n\r\n            var copy = objects.clone(params);\r\n\r\n            this._params[id] = copy;\r\n\r\n            // if too many active uploads, wait...\r\n            if (len <= this._options.maxConnections){\r\n                this._send(id, this._params[id]);\r\n            }     \r\n        },\r\n\r\n        /**\r\n         * Sends all files  and additional query params to the server.\r\n         */\r\n        sendAll: function(params){\r\n           for( var id = 0; id <this._files.length; id++) {\r\n                this.send(id,params);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Cancels file upload by id\r\n         */\r\n        cancel: function(id){\r\n            this._cancel(id);\r\n            this._dequeue(id);\r\n        },\r\n\r\n        /**\r\n         * Cancells all uploads\r\n         */\r\n        cancelAll: function(){\r\n            for (var i=0; i<this._queue.length; i++){\r\n                this._cancel(this._queue[i]);\r\n            }\r\n            this._queue = [];\r\n        },\r\n\r\n        getName: function(id){\r\n            var file = this._files[id];\r\n            return file.fileName != null ? file.fileName : file.name;\r\n        },\r\n\r\n        getSize: function(id){\r\n            var file = this._files[id];\r\n            return file.fileSize != null ? file.fileSize : file.size;\r\n        },\r\n\r\n        /**\r\n         * Returns uploaded bytes for file identified by id\r\n         */\r\n        getLoaded: function(id){\r\n            return this._loaded[id] || 0;\r\n        },\r\n\r\n\r\n        /**\r\n         * Sends the file identified by id and additional query params to the server\r\n         * @param {Object} params name-value string pairs\r\n         */\r\n        _send: function(id, params){\r\n            var options = this._options,\r\n                name = this.getName(id),\r\n                size = this.getSize(id),\r\n                chunkSize = options.maxChunkSize || 0,\r\n                curUploadingSize,\r\n                curLoadedSize = 0,\r\n                file = this._files[id],\r\n                args = {\r\n                    headers : {\r\n                    }                    \r\n                };\r\n\r\n            this._loaded[id] = this._loaded[id] || 0;\r\n\r\n            var xhr = this._xhrs[id] = new Xhr({\r\n                url : options.url\r\n            });\r\n\r\n            if (chunkSize)  {\r\n\r\n                args.data = blobSlice.call(\r\n                    file,\r\n                    this._loaded[id],\r\n                    this._loaded[id] + chunkSize,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                curUploadingSize = args.data.size;\r\n                // Expose the chunk bytes position range:\r\n                args.headers[\"content-range\"] = 'bytes ' + this._loaded[id] + '-' +\r\n                    (this._loaded[id] + curUploadingSize - 1) + '/' + size;\r\n                args.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            }  else {\r\n                curUploadingSize = size;\r\n                var formParamName =  params.formParamName,\r\n                    formData = params.formData;\r\n\r\n                if (formParamName) {\r\n                    if (!formData) {\r\n                        formData = new FormData();\r\n                    }\r\n                    formData.append(formParamName,file);\r\n                    args.data = formData;\r\n    \r\n                } else {\r\n                    args.headers[\"Content-Type\"] = file.type || \"application/octet-stream\";\r\n                    args.data = file;\r\n                }\r\n            }\r\n\r\n\r\n            var self = this;\r\n            xhr.post(\r\n                args\r\n            ).progress(function(e){\r\n                if (e.lengthComputable){\r\n                    curLoadedSize = curLoadedSize + e.loaded;\r\n                    self._loaded[id] = self._loaded[id] + e.loaded;\r\n                    self._options.onProgress(id, name, self._loaded[id], size);\r\n                }\r\n            }).then(function(){\r\n                if (!self._files[id]) {\r\n                    // the request was aborted/cancelled\r\n                    return;\r\n                }\r\n\r\n                if (curLoadedSize < curUploadingSize) {\r\n                    // Create a progress event if no final progress event\r\n                    // with loaded equaling total has been triggered\r\n                    // for this chunk:\r\n                    self._loaded[id] = self._loaded[id] + curUploadingSize - curLoadedSize;\r\n                    self._options.onProgress(id, name, self._loaded[id], size);                    \r\n                }\r\n\r\n                if (self._loaded[id] <size) {\r\n                    // File upload not yet complete,\r\n                    // continue with the next chunk:\r\n                    self._send(id,params);\r\n                } else {\r\n                    self._options.onComplete(id,name);\r\n\r\n                    self._files[id] = null;\r\n                    self._xhrs[id] = null;\r\n                    self._dequeue(id);\r\n                }\r\n\r\n\r\n            }).catch(function(e){\r\n                self._options.onFailure(id,name,e);\r\n\r\n                self._files[id] = null;\r\n                self._xhrs[id] = null;\r\n                self._dequeue(id);\r\n            });\r\n        },\r\n\r\n        _cancel: function(id){\r\n            this._options.onCancel(id, this.getName(id));\r\n\r\n            this._files[id] = null;\r\n\r\n            if (this._xhrs[id]){\r\n                this._xhrs[id].abort();\r\n                this._xhrs[id] = null;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Returns id of files being uploaded or\r\n         * waiting for their turn\r\n         */\r\n        getQueue: function(){\r\n            return this._queue;\r\n        },\r\n\r\n\r\n        /**\r\n         * Removes element from queue, starts upload of next\r\n         */\r\n        _dequeue: function(id){\r\n            var i = arrays.inArray(id,this._queue);\r\n            this._queue.splice(i, 1);\r\n\r\n            var max = this._options.maxConnections;\r\n\r\n            if (this._queue.length >= max && i < max){\r\n                var nextId = this._queue[max-1];\r\n                this._send(nextId, this._params[nextId]);\r\n            }\r\n        }\r\n    });\r\n\r\n    return http.Upload = Upload;    \r\n});"]}