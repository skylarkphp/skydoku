{"version":3,"sources":["core.js"],"names":["define","window","Visibility","lastId","self","onVisible","callback","support","isSupported","hidden","listener","change","e","state","unbind","number","_callbacks","_listen","id","afterPrerendering","_doc","webkitHidden","visibilityState","webkitVisibilityState","undefined","document","_change","event","i","call","_init","apply","arguments","addEventListener","attachEvent"],"mappings":";;;;;;;AAAAA,QACI,cACF,WACE,GAAIC,OAAOC,WACP,OAAOD,OAAOC,WAElB,IAAIC,GAAU,EAMVC,GAaAC,UAAW,SAAUC,GACjB,IAAIC,EAAUH,EAAKI,cACnB,IAAMD,IAAYH,EAAKK,SAEnB,OADAH,IACOC,EAGX,IAAIG,EAAWN,EAAKO,OAAO,SAAUC,EAAGC,GAC9BT,EAAKK,WACPL,EAAKU,OAAOJ,GACZJ,OAGR,OAAOI,GAiBXC,OAAQ,SAAUL,GACd,IAAMF,EAAKI,cACP,OAAO,EAGX,IAAIO,EADJZ,GAAU,EAIV,OAFAC,EAAKY,WAAWD,GAAUT,EAC1BF,EAAKa,UACEF,GASXD,OAAQ,SAAUI,UACPd,EAAKY,WAAWE,IAe3BC,kBAAmB,SAAUb,GACzB,IAAIC,EAAYH,EAAKI,cAGrB,IAAMD,GAFU,aAEcH,EAAKS,QAE/B,OADAP,IACOC,EAGX,IAAIG,EAAWN,EAAKO,OAAO,SAAUC,EAAGC,GAPxB,aAQMA,IACdT,EAAKU,OAAOJ,GACZJ,OAGR,OAAOI,GAUXD,OAAQ,WACJ,SAAUL,EAAKgB,KAAKX,SAAUL,EAAKgB,KAAKC,eAe5CR,MAAO,WACH,OAAOT,EAAKgB,KAAKE,iBACVlB,EAAKgB,KAAKG,uBACV,WAYXf,YAAa,WACT,YAA4BgB,IAArBpB,EAAKgB,KAAKX,aAAmDe,IAA3BpB,EAAKgB,KAAKC,cAIvDD,KAAMK,aAGNT,cAGAU,QAAS,SAASC,GACd,IAAId,EAAQT,EAAKS,QAEjB,IAAM,IAAIe,KAAKxB,EAAKY,WAChBZ,EAAKY,WAAWY,GAAGC,KAAKzB,EAAKgB,KAAMO,EAAOd,IAKlDI,QAAS,WACL,IAAKb,EAAK0B,MAAV,CAIA,IAAIH,EAAQ,mBACPvB,EAAKgB,KAAKG,wBACXI,EAAQ,SAAWA,GAGvB,IAAIjB,EAAW,WACXN,EAAKsB,QAAQK,MAAM3B,EAAM4B,YAExB5B,EAAKgB,KAAKa,iBACX7B,EAAKgB,KAAKa,iBAAiBN,EAAOjB,GAElCN,EAAKgB,KAAKc,YAAYP,EAAOjB,GAEjCN,EAAK0B,OAAQ,KAMrB,OAAO7B,OAAOC,WAAaE","file":"../core.js","sourcesContent":["define([\n    \"./fallback\"\n],function(){\n    if (window.Visibility) {\n        return window.Visibility;\n    }\n    var lastId = -1;\n\n    // Visibility.js allow you to know, that your web page is in the background\n    // tab and thus not visible to the user. This library is wrap under\n    // Page Visibility API. It fix problems with different vendor prefixes and\n    // add high-level useful functions.\n    var self = {\n\n        // Call callback only when page become to visible for user or\n        // call it now if page is visible now or Page Visibility API\n        // doesn’t supported.\n        //\n        // Return false if API isn’t supported, true if page is already visible\n        // or listener ID (you can use it in `unbind` method) if page isn’t\n        // visible now.\n        //\n        //   Visibility.onVisible(function () {\n        //       startIntroAnimation();\n        //   });\n        onVisible: function (callback) {\n            var support = self.isSupported();\n            if ( !support || !self.hidden() ) {\n                callback();\n                return support;\n            }\n\n            var listener = self.change(function (e, state) {\n                if ( !self.hidden() ) {\n                    self.unbind(listener);\n                    callback();\n                }\n            });\n            return listener;\n        },\n\n        // Call callback when visibility will be changed. First argument for\n        // callback will be original event object, second will be visibility\n        // state name.\n        //\n        // Return listener ID to unbind listener by `unbind` method.\n        //\n        // If Page Visibility API doesn’t supported method will be return false\n        // and callback never will be called.\n        //\n        //   Visibility.change(function(e, state) {\n        //       Statistics.visibilityChange(state);\n        //   });\n        //\n        // It is just proxy to `visibilitychange` event, but use vendor prefix.\n        change: function (callback) {\n            if ( !self.isSupported() ) {\n                return false;\n            }\n            lastId += 1;\n            var number = lastId;\n            self._callbacks[number] = callback;\n            self._listen();\n            return number;\n        },\n\n        // Remove `change` listener by it ID.\n        //\n        //   var id = Visibility.change(function(e, state) {\n        //       firstChangeCallback();\n        //       Visibility.unbind(id);\n        //   });\n        unbind: function (id) {\n            delete self._callbacks[id];\n        },\n\n        // Call `callback` in any state, expect “prerender”. If current state\n        // is “prerender” it will wait until state will be changed.\n        // If Page Visibility API doesn’t supported, it will call `callback`\n        // immediately.\n        //\n        // Return false if API isn’t supported, true if page is already after\n        // prerendering or listener ID (you can use it in `unbind` method)\n        // if page is prerended now.\n        //\n        //   Visibility.afterPrerendering(function () {\n        //       Statistics.countVisitor();\n        //   });\n        afterPrerendering: function (callback) {\n            var support   = self.isSupported();\n            var prerender = 'prerender';\n\n            if ( !support || prerender != self.state() ) {\n                callback();\n                return support;\n            }\n\n            var listener = self.change(function (e, state) {\n                if ( prerender != state ) {\n                    self.unbind(listener);\n                    callback();\n                }\n            });\n            return listener;\n        },\n\n        // Return true if page now isn’t visible to user.\n        //\n        //   if ( !Visibility.hidden() ) {\n        //       VideoPlayer.play();\n        //   }\n        //\n        // It is just proxy to `document.hidden`, but use vendor prefix.\n        hidden: function () {\n            return !!(self._doc.hidden || self._doc.webkitHidden);\n        },\n\n        // Return visibility state: 'visible', 'hidden' or 'prerender'.\n        //\n        //   if ( 'prerender' == Visibility.state() ) {\n        //       Statistics.pageIsPrerendering();\n        //   }\n        //\n        // Don’t use `Visibility.state()` to detect, is page visible, because\n        // visibility states can extend in next API versions.\n        // Use more simpler and general `Visibility.hidden()` for this cases.\n        //\n        // It is just proxy to `document.visibilityState`, but use\n        // vendor prefix.\n        state: function () {\n            return self._doc.visibilityState       ||\n                   self._doc.webkitVisibilityState ||\n                   'visible';\n        },\n\n        // Return true if browser support Page Visibility API.\n        // refs: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n        //\n        //   if ( Visibility.isSupported() ) {\n        //       Statistics.startTrackingVisibility();\n        //       Visibility.change(function(e, state)) {\n        //           Statistics.trackVisibility(state);\n        //       });\n        //   }\n        isSupported: function () {\n            return self._doc.hidden !== undefined || self._doc.webkitHidden !== undefined;\n        },\n\n        // Link to document object to change it in tests.\n        _doc: document || {},\n\n        // Callbacks from `change` method, that wait visibility changes.\n        _callbacks: { },\n\n        // Listener for `visibilitychange` event.\n        _change: function(event) {\n            var state = self.state();\n\n            for ( var i in self._callbacks ) {\n                self._callbacks[i].call(self._doc, event, state);\n            }\n        },\n\n        // Set listener for `visibilitychange` event.\n        _listen: function () {\n            if ( self._init ) {\n                return;\n            }\n\n            var event = 'visibilitychange';\n            if ( self._doc.webkitVisibilityState ) {\n                event = 'webkit' + event;\n            }\n\n            var listener = function () {\n                self._change.apply(self, arguments);\n            };\n            if ( self._doc.addEventListener ) {\n                self._doc.addEventListener(event, listener);\n            } else {\n                self._doc.attachEvent(event, listener);\n            }\n            self._init = true;\n        }\n\n    };\n\n\n    return window.Visibility = self;\n\n});\n"]}