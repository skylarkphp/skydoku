{"version":3,"sources":["skylark-visibility.js"],"names":["define","document","visibilityState","webkitVisibilityState","hidden","event","fireEvent","createEvent","initEvent","dispatchEvent","Visibility","_change","call","onFocus","onBlur","addEventListener","window","attachEvent","lastId","self","onVisible","callback","support","isSupported","listener","change","e","state","unbind","number","_callbacks","_listen","id","afterPrerendering","_doc","webkitHidden","undefined","i","_init","apply","arguments","core","lastTimer","every","interval","hiddenInterval","_time","_timers","visible","_run","stop","_stop","_timed","_wasHidden","_stopRun","runNow","timer","runner","last","Date","delay","setTimeout","setInterval","clearInterval","clearTimeout","isHidden","wasHidden","visibility","main"],"mappings":"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","file":"../skylark-visibility.js","sourcesContent":["define('skylark-visibility/fallback',[],function(){\n    if ( document.visibilityState || document.webkitVisibilityState ) {\n        return;\n    }\n\n    document.hidden = false;\n    document.visibilityState = 'visible';\n\n    var event = null\n    var i = 0\n    var fireEvent = function () {\n        if( document.createEvent ) {\n            if ( !event ) {\n                event = document.createEvent('HTMLEvents');\n                event.initEvent('visibilitychange', true, true);\n            }\n            document.dispatchEvent(event);\n        } else {\n            if ( typeof(Visibility) == 'object' ) {\n                Visibility._change.call(Visibility, { });\n            }\n        }\n    }\n\n    var onFocus = function () {\n        document.hidden = false;\n        document.visibilityState = 'visible';\n        fireEvent();\n    };\n    var onBlur  = function () {\n        document.hidden = true;\n        document.visibilityState = 'hidden';\n        fireEvent();\n    }\n\n    if ( document.addEventListener ) {\n        window.addEventListener('focus', onFocus, true);\n        window.addEventListener('blur',  onBlur,  true);\n    } else {\n        document.attachEvent('onfocusin',  onFocus);\n        document.attachEvent('onfocusout', onBlur);\n    }\n});\n\ndefine('skylark-visibility/core',[\n    \"./fallback\"\n],function(){\n    if (window.Visibility) {\n        return window.Visibility;\n    }\n    var lastId = -1;\n\n    // Visibility.js allow you to know, that your web page is in the background\n    // tab and thus not visible to the user. This library is wrap under\n    // Page Visibility API. It fix problems with different vendor prefixes and\n    // add high-level useful functions.\n    var self = {\n\n        // Call callback only when page become to visible for user or\n        // call it now if page is visible now or Page Visibility API\n        // doesn’t supported.\n        //\n        // Return false if API isn’t supported, true if page is already visible\n        // or listener ID (you can use it in `unbind` method) if page isn’t\n        // visible now.\n        //\n        //   Visibility.onVisible(function () {\n        //       startIntroAnimation();\n        //   });\n        onVisible: function (callback) {\n            var support = self.isSupported();\n            if ( !support || !self.hidden() ) {\n                callback();\n                return support;\n            }\n\n            var listener = self.change(function (e, state) {\n                if ( !self.hidden() ) {\n                    self.unbind(listener);\n                    callback();\n                }\n            });\n            return listener;\n        },\n\n        // Call callback when visibility will be changed. First argument for\n        // callback will be original event object, second will be visibility\n        // state name.\n        //\n        // Return listener ID to unbind listener by `unbind` method.\n        //\n        // If Page Visibility API doesn’t supported method will be return false\n        // and callback never will be called.\n        //\n        //   Visibility.change(function(e, state) {\n        //       Statistics.visibilityChange(state);\n        //   });\n        //\n        // It is just proxy to `visibilitychange` event, but use vendor prefix.\n        change: function (callback) {\n            if ( !self.isSupported() ) {\n                return false;\n            }\n            lastId += 1;\n            var number = lastId;\n            self._callbacks[number] = callback;\n            self._listen();\n            return number;\n        },\n\n        // Remove `change` listener by it ID.\n        //\n        //   var id = Visibility.change(function(e, state) {\n        //       firstChangeCallback();\n        //       Visibility.unbind(id);\n        //   });\n        unbind: function (id) {\n            delete self._callbacks[id];\n        },\n\n        // Call `callback` in any state, expect “prerender”. If current state\n        // is “prerender” it will wait until state will be changed.\n        // If Page Visibility API doesn’t supported, it will call `callback`\n        // immediately.\n        //\n        // Return false if API isn’t supported, true if page is already after\n        // prerendering or listener ID (you can use it in `unbind` method)\n        // if page is prerended now.\n        //\n        //   Visibility.afterPrerendering(function () {\n        //       Statistics.countVisitor();\n        //   });\n        afterPrerendering: function (callback) {\n            var support   = self.isSupported();\n            var prerender = 'prerender';\n\n            if ( !support || prerender != self.state() ) {\n                callback();\n                return support;\n            }\n\n            var listener = self.change(function (e, state) {\n                if ( prerender != state ) {\n                    self.unbind(listener);\n                    callback();\n                }\n            });\n            return listener;\n        },\n\n        // Return true if page now isn’t visible to user.\n        //\n        //   if ( !Visibility.hidden() ) {\n        //       VideoPlayer.play();\n        //   }\n        //\n        // It is just proxy to `document.hidden`, but use vendor prefix.\n        hidden: function () {\n            return !!(self._doc.hidden || self._doc.webkitHidden);\n        },\n\n        // Return visibility state: 'visible', 'hidden' or 'prerender'.\n        //\n        //   if ( 'prerender' == Visibility.state() ) {\n        //       Statistics.pageIsPrerendering();\n        //   }\n        //\n        // Don’t use `Visibility.state()` to detect, is page visible, because\n        // visibility states can extend in next API versions.\n        // Use more simpler and general `Visibility.hidden()` for this cases.\n        //\n        // It is just proxy to `document.visibilityState`, but use\n        // vendor prefix.\n        state: function () {\n            return self._doc.visibilityState       ||\n                   self._doc.webkitVisibilityState ||\n                   'visible';\n        },\n\n        // Return true if browser support Page Visibility API.\n        // refs: https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API\n        //\n        //   if ( Visibility.isSupported() ) {\n        //       Statistics.startTrackingVisibility();\n        //       Visibility.change(function(e, state)) {\n        //           Statistics.trackVisibility(state);\n        //       });\n        //   }\n        isSupported: function () {\n            return self._doc.hidden !== undefined || self._doc.webkitHidden !== undefined;\n        },\n\n        // Link to document object to change it in tests.\n        _doc: document || {},\n\n        // Callbacks from `change` method, that wait visibility changes.\n        _callbacks: { },\n\n        // Listener for `visibilitychange` event.\n        _change: function(event) {\n            var state = self.state();\n\n            for ( var i in self._callbacks ) {\n                self._callbacks[i].call(self._doc, event, state);\n            }\n        },\n\n        // Set listener for `visibilitychange` event.\n        _listen: function () {\n            if ( self._init ) {\n                return;\n            }\n\n            var event = 'visibilitychange';\n            if ( self._doc.webkitVisibilityState ) {\n                event = 'webkit' + event;\n            }\n\n            var listener = function () {\n                self._change.apply(self, arguments);\n            };\n            if ( self._doc.addEventListener ) {\n                self._doc.addEventListener(event, listener);\n            } else {\n                self._doc.attachEvent(event, listener);\n            }\n            self._init = true;\n        }\n\n    };\n\n\n    return window.Visibility = self;\n\n});\n\ndefine('skylark-visibility/visibility',[\n    \"./core\"\n],function(core){\n    var lastTimer = -1;\n\n    var install = function (Visibility) {\n\n        // Run callback every `interval` milliseconds if page is visible and\n        // every `hiddenInterval` milliseconds if page is hidden.\n        //\n        //   Visibility.every(60 * 1000, 5 * 60 * 1000, function () {\n        //       checkNewMails();\n        //   });\n        //\n        // You can skip `hiddenInterval` and callback will be called only if\n        // page is visible.\n        //\n        //   Visibility.every(1000, function () {\n        //       updateCountdown();\n        //   });\n        //\n        // It is analog of `setInterval(callback, interval)` but use visibility\n        // state.\n        //\n        // It return timer ID, that you can use in `Visibility.stop(id)` to stop\n        // timer (`clearInterval` analog).\n        // Warning: timer ID is different from interval ID from `setInterval`,\n        // so don’t use it in `clearInterval`.\n        //\n        // On change state from hidden to visible timers will be execute.\n        Visibility.every = function (interval, hiddenInterval, callback) {\n            Visibility._time();\n\n            if ( !callback ) {\n                callback = hiddenInterval;\n                hiddenInterval = null;\n            }\n\n            lastTimer += 1;\n            var number = lastTimer;\n\n            Visibility._timers[number] = {\n                visible:  interval,\n                hidden:   hiddenInterval,\n                callback: callback\n            };\n            Visibility._run(number, false);\n\n            if ( Visibility.isSupported() ) {\n                Visibility._listen();\n            }\n            return number;\n        };\n\n        // Stop timer from `every` method by it ID (`every` method return it).\n        //\n        //   slideshow = Visibility.every(5 * 1000, function () {\n        //       changeSlide();\n        //   });\n        //   $('.stopSlideshow').click(function () {\n        //       Visibility.stop(slideshow);\n        //   });\n        Visibility.stop = function(id) {\n            if ( !Visibility._timers[id] ) {\n                return false;\n            }\n            Visibility._stop(id);\n            delete Visibility._timers[id];\n            return true;\n        };\n\n        // Callbacks and intervals added by `every` method.\n        Visibility._timers = { };\n\n        // Initialize variables on page loading.\n        Visibility._time = function () {\n            if ( Visibility._timed ) {\n                return;\n            }\n            Visibility._timed     = true;\n            Visibility._wasHidden = Visibility.hidden();\n\n            Visibility.change(function () {\n                Visibility._stopRun();\n                Visibility._wasHidden = Visibility.hidden();\n            });\n        };\n\n        // Try to run timer from every method by it’s ID. It will be use\n        // `interval` or `hiddenInterval` depending on visibility state.\n        // If page is hidden and `hiddenInterval` is null,\n        // it will not run timer.\n        //\n        // Argument `runNow` say, that timers must be execute now too.\n        Visibility._run = function (id, runNow) {\n            var interval,\n                timer = Visibility._timers[id];\n\n            if ( Visibility.hidden() ) {\n                if ( null === timer.hidden ) {\n                    return;\n                }\n                interval = timer.hidden;\n            } else {\n                interval = timer.visible;\n            }\n\n            var runner = function () {\n                timer.last = new Date();\n                timer.callback.call(window);\n            }\n\n            if ( runNow ) {\n                var now  = new Date();\n                var last = now - timer.last ;\n\n                if ( interval > last ) {\n                    timer.delay = setTimeout(function () {\n                        timer.id = setInterval(runner, interval);\n                        runner();\n                    }, interval - last);\n                } else {\n                    timer.id = setInterval(runner, interval);\n                    runner();\n                }\n\n            } else {\n              timer.id = setInterval(runner, interval);\n            }\n        };\n\n        // Stop timer from `every` method by it’s ID.\n        Visibility._stop = function (id) {\n            var timer = Visibility._timers[id];\n            clearInterval(timer.id);\n            clearTimeout(timer.delay);\n            delete timer.id;\n            delete timer.delay;\n        };\n\n        // Listener for `visibilitychange` event.\n        Visibility._stopRun = function (event) {\n            var isHidden  = Visibility.hidden(),\n                wasHidden = Visibility._wasHidden;\n\n            if ( (isHidden && !wasHidden) || (!isHidden && wasHidden) ) {\n                for ( var i in Visibility._timers ) {\n                    Visibility._stop(i);\n                    Visibility._run(i, !isHidden);\n                }\n            }\n        };\n\n        return Visibility;\n    }\n\n\n    return   install(core);\n    \n});\n\ndefine('skylark-visibility/main',[\n\t\"./visibility\"\n],function(visibility){\n\treturn visibility;\n});\ndefine('skylark-visibility', ['skylark-visibility/main'], function (main) { return main; });\n\n"]}