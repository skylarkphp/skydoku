{"version":3,"sources":["search.js"],"names":["define","require","exports","module","lang","oop","Range","Search","this","$options","set","options","mixin","getOptions","copyObject","setOptions","find","session","iterator","$matchIterator","firstRange","forEach","sr","sc","er","ec","start","skipCurrent","isEqual","findAll","needle","$assembleRegExp","range","lines","getLines","row","end","doc","getAllLines","ranges","re","$isMultiLine","prevRange","len","length","maxRow","outer","offset","j","search","startLine","line","startIndex","match","endIndex","column","push","i","matches","getMatchOffsets","startColumn","endColumn","slice","replace","input","replacement","exec","preserveCase","split","Math","min","ch","toLowerCase","toUpperCase","join","$disableFakeMultiline","RegExp","regExp","escapeRegExp","wholeWord","wordBoundary","c","test","addWordBoundary","modifier","caseSensitive","$assembleMultilineRegExp","e","parts","backwards","selection","getRange","firstRow","lastRow","getLength","callback","forEachInLine","Number","MAX_VALUE","wrap","startRow","getLine","m","last","lastIndex","index","call","prototype"],"mappings":"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","file":"../search.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar lang = require(\"./lib/lang\");\r\nvar oop = require(\"./lib/oop\");\r\nvar Range = require(\"./range\").Range;\r\n\r\n/**\r\n * @class Search\r\n *\r\n * A class designed to handle all sorts of text searches within a [[Document `Document`]].\r\n *\r\n **/\r\n\r\n/**\r\n * \r\n *\r\n * Creates a new `Search` object. The following search options are available:\r\n *\r\n * - `needle`: The string or regular expression you're looking for\r\n * - `backwards`: Whether to search backwards from where cursor currently is. Defaults to `false`.\r\n * - `wrap`: Whether to wrap the search back to the beginning when it hits the end. Defaults to `false`.\r\n * - `caseSensitive`: Whether the search ought to be case-sensitive. Defaults to `false`.\r\n * - `wholeWord`: Whether the search matches only on whole words. Defaults to `false`.\r\n * - `range`: The [[Range]] to search within. Set this to `null` for the whole document\r\n * - `regExp`: Whether the search is a regular expression or not. Defaults to `false`.\r\n * - `start`: The starting [[Range]] or cursor position to begin the search\r\n * - `skipCurrent`: Whether or not to include the current line in the search. Default to `false`.\r\n * \r\n * @constructor\r\n **/\r\n\r\nvar Search = function() {\r\n    this.$options = {};\r\n};\r\n\r\n(function() {\r\n    /**\r\n     * Sets the search options via the `options` parameter.\r\n     * @param {Object} options An object containing all the new search properties\r\n     *\r\n     * \r\n     * @returns {Search}\r\n     * @chainable\r\n    **/\r\n    this.set = function(options) {\r\n        oop.mixin(this.$options, options);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * [Returns an object containing all the search options.]{: #Search.getOptions}\r\n     * @returns {Object}\r\n    **/\r\n    this.getOptions = function() {\r\n        return lang.copyObject(this.$options);\r\n    };\r\n    \r\n    /**\r\n     * Sets the search options via the `options` parameter.\r\n     * @param {Object} An object containing all the search propertie\r\n     * @related Search.set\r\n    **/\r\n    this.setOptions = function(options) {\r\n        this.$options = options;\r\n    };\r\n    /**\r\n     * Searches for `options.needle`. If found, this method returns the [[Range `Range`]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.\r\n     * @param {EditSession} session The session to search with\r\n     *\r\n     * \r\n     * @returns {Range}\r\n    **/\r\n    this.find = function(session) {\r\n        var options = this.$options;\r\n        var iterator = this.$matchIterator(session, options);\r\n        if (!iterator)\r\n            return false;\r\n\r\n        var firstRange = null;\r\n        iterator.forEach(function(sr, sc, er, ec) {\r\n            firstRange = new Range(sr, sc, er, ec);\r\n            if (sc == ec && options.start && options.start.start\r\n                && options.skipCurrent != false && firstRange.isEqual(options.start)\r\n            ) {\r\n                firstRange = null;\r\n                return false;\r\n            }\r\n            \r\n            return true;\r\n        });\r\n\r\n        return firstRange;\r\n    };\r\n\r\n    /**\r\n     * Searches for all occurrances `options.needle`. If found, this method returns an array of [[Range `Range`s]] where the text first occurs. If `options.backwards` is `true`, the search goes backwards in the session.\r\n     * @param {EditSession} session The session to search with\r\n     *\r\n     * \r\n     * @returns {[Range]}\r\n    **/\r\n    this.findAll = function(session) {\r\n        var options = this.$options;\r\n        if (!options.needle)\r\n            return [];\r\n        this.$assembleRegExp(options);\r\n\r\n        var range = options.range;\r\n        var lines = range\r\n            ? session.getLines(range.start.row, range.end.row)\r\n            : session.doc.getAllLines();\r\n\r\n        var ranges = [];\r\n        var re = options.re;\r\n        if (options.$isMultiLine) {\r\n            var len = re.length;\r\n            var maxRow = lines.length - len;\r\n            var prevRange;\r\n            outer: for (var row = re.offset || 0; row <= maxRow; row++) {\r\n                for (var j = 0; j < len; j++)\r\n                    if (lines[row + j].search(re[j]) == -1)\r\n                        continue outer;\r\n                \r\n                var startLine = lines[row];\r\n                var line = lines[row + len - 1];\r\n                var startIndex = startLine.length - startLine.match(re[0])[0].length;\r\n                var endIndex = line.match(re[len - 1])[0].length;\r\n                \r\n                if (prevRange && prevRange.end.row === row &&\r\n                    prevRange.end.column > startIndex\r\n                ) {\r\n                    continue;\r\n                }\r\n                ranges.push(prevRange = new Range(\r\n                    row, startIndex, row + len - 1, endIndex\r\n                ));\r\n                if (len > 2)\r\n                    row = row + len - 2;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < lines.length; i++) {\r\n                var matches = lang.getMatchOffsets(lines[i], re);\r\n                for (var j = 0; j < matches.length; j++) {\r\n                    var match = matches[j];\r\n                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (range) {\r\n            var startColumn = range.start.column;\r\n            var endColumn = range.start.column;\r\n            var i = 0, j = ranges.length - 1;\r\n            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)\r\n                i++;\r\n\r\n            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)\r\n                j--;\r\n            \r\n            ranges = ranges.slice(i, j + 1);\r\n            for (i = 0, j = ranges.length; i < j; i++) {\r\n                ranges[i].start.row += range.start.row;\r\n                ranges[i].end.row += range.start.row;\r\n            }\r\n        }\r\n\r\n        return ranges;\r\n    };\r\n\r\n    /**\r\n     * Searches for `options.needle` in `input`, and, if found, replaces it with `replacement`.\r\n     * @param {String} input The text to search in\r\n     * @param {String} replacement The replacing text\r\n     * + (String): If `options.regExp` is `true`, this function returns `input` with the replacement already made. Otherwise, this function just returns `replacement`.<br/>\r\n     * If `options.needle` was not found, this function returns `null`.\r\n     *\r\n     * \r\n     * @returns {String}\r\n    **/\r\n    this.replace = function(input, replacement) {\r\n        var options = this.$options;\r\n\r\n        var re = this.$assembleRegExp(options);\r\n        if (options.$isMultiLine)\r\n            return replacement;\r\n\r\n        if (!re)\r\n            return;\r\n\r\n        var match = re.exec(input);\r\n        if (!match || match[0].length != input.length)\r\n            return null;\r\n        \r\n        replacement = input.replace(re, replacement);\r\n        if (options.preserveCase) {\r\n            replacement = replacement.split(\"\");\r\n            for (var i = Math.min(input.length, input.length); i--; ) {\r\n                var ch = input[i];\r\n                if (ch && ch.toLowerCase() != ch)\r\n                    replacement[i] = replacement[i].toUpperCase();\r\n                else\r\n                    replacement[i] = replacement[i].toLowerCase();\r\n            }\r\n            replacement = replacement.join(\"\");\r\n        }\r\n        \r\n        return replacement;\r\n    };\r\n\r\n    this.$assembleRegExp = function(options, $disableFakeMultiline) {\r\n        if (options.needle instanceof RegExp)\r\n            return options.re = options.needle;\r\n\r\n        var needle = options.needle;\r\n\r\n        if (!options.needle)\r\n            return options.re = false;\r\n\r\n        if (!options.regExp)\r\n            needle = lang.escapeRegExp(needle);\r\n\r\n        if (options.wholeWord)\r\n            needle = addWordBoundary(needle, options);\r\n\r\n        var modifier = options.caseSensitive ? \"gm\" : \"gmi\";\r\n\r\n        options.$isMultiLine = !$disableFakeMultiline && /[\\n\\r]/.test(needle);\r\n        if (options.$isMultiLine)\r\n            return options.re = this.$assembleMultilineRegExp(needle, modifier);\r\n\r\n        try {\r\n            var re = new RegExp(needle, modifier);\r\n        } catch(e) {\r\n            re = false;\r\n        }\r\n        return options.re = re;\r\n    };\r\n\r\n    this.$assembleMultilineRegExp = function(needle, modifier) {\r\n        var parts = needle.replace(/\\r\\n|\\r|\\n/g, \"$\\n^\").split(\"\\n\");\r\n        var re = [];\r\n        for (var i = 0; i < parts.length; i++) try {\r\n            re.push(new RegExp(parts[i], modifier));\r\n        } catch(e) {\r\n            return false;\r\n        }\r\n        return re;\r\n    };\r\n\r\n    this.$matchIterator = function(session, options) {\r\n        var re = this.$assembleRegExp(options);\r\n        if (!re)\r\n            return false;\r\n        var backwards = options.backwards == true;\r\n        var skipCurrent = options.skipCurrent != false;\r\n\r\n        var range = options.range;\r\n        var start = options.start;\r\n        if (!start)\r\n            start = range ? range[backwards ? \"end\" : \"start\"] : session.selection.getRange();\r\n         \r\n        if (start.start)\r\n            start = start[skipCurrent != backwards ? \"end\" : \"start\"];\r\n\r\n        var firstRow = range ? range.start.row : 0;\r\n        var lastRow = range ? range.end.row : session.getLength() - 1;\r\n        \r\n        if (backwards) {\r\n            var forEach = function(callback) {\r\n                var row = start.row;\r\n                if (forEachInLine(row, start.column, callback))\r\n                    return;\r\n                for (row--; row >= firstRow; row--)\r\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\r\n                        return;\r\n                if (options.wrap == false)\r\n                    return;\r\n                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)\r\n                    if (forEachInLine(row, Number.MAX_VALUE, callback))\r\n                        return;\r\n            };\r\n        }\r\n        else {\r\n            var forEach = function(callback) {\r\n                var row = start.row;\r\n                if (forEachInLine(row, start.column, callback))\r\n                    return;\r\n                for (row = row + 1; row <= lastRow; row++)\r\n                    if (forEachInLine(row, 0, callback))\r\n                        return;\r\n                if (options.wrap == false)\r\n                    return;\r\n                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)\r\n                    if (forEachInLine(row, 0, callback))\r\n                        return;\r\n            };\r\n        }\r\n        \r\n        if (options.$isMultiLine) {\r\n            var len = re.length;\r\n            var forEachInLine = function(row, offset, callback) {\r\n                var startRow = backwards ? row - len + 1 : row;\r\n                if (startRow < 0) return;\r\n                var line = session.getLine(startRow);\r\n                var startIndex = line.search(re[0]);\r\n                if (!backwards && startIndex < offset || startIndex === -1) return;\r\n                for (var i = 1; i < len; i++) {\r\n                    line = session.getLine(startRow + i);\r\n                    if (line.search(re[i]) == -1)\r\n                        return;\r\n                }\r\n                var endIndex = line.match(re[len - 1])[0].length;\r\n                if (backwards && endIndex > offset) return;\r\n                if (callback(startRow, startIndex, startRow + len - 1, endIndex))\r\n                    return true;\r\n            };\r\n        }\r\n        else if (backwards) {\r\n            var forEachInLine = function(row, endIndex, callback) {\r\n                var line = session.getLine(row);\r\n                var matches = [];\r\n                var m, last = 0;\r\n                re.lastIndex = 0;\r\n                while((m = re.exec(line))) {\r\n                    var length = m[0].length;\r\n                    last = m.index;\r\n                    if (!length) {\r\n                        if (last >= line.length) break;\r\n                        re.lastIndex = last += 1;\r\n                    }\r\n                    if (m.index + length > endIndex)\r\n                        break;\r\n                    matches.push(m.index, length);\r\n                }\r\n                for (var i = matches.length - 1; i >= 0; i -= 2) {\r\n                    var column = matches[i - 1];\r\n                    var length = matches[i];\r\n                    if (callback(row, column, row, column + length))\r\n                        return true;\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            var forEachInLine = function(row, startIndex, callback) {\r\n                var line = session.getLine(row);\r\n                var last;\r\n                var m;\r\n                re.lastIndex = startIndex;\r\n                while((m = re.exec(line))) {\r\n                    var length = m[0].length;\r\n                    last = m.index;\r\n                    if (callback(row, last, row,last + length))\r\n                        return true;\r\n                    if (!length) {\r\n                        re.lastIndex = last += 1;\r\n                        if (last >= line.length) return false;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return {forEach: forEach};\r\n    };\r\n\r\n}).call(Search.prototype);\r\n\r\nfunction addWordBoundary(needle, options) {\r\n    function wordBoundary(c) {\r\n        if (/\\w/.test(c) || options.regExp) return \"\\\\b\";\r\n        return \"\";\r\n    }\r\n    return wordBoundary(needle[0]) + needle\r\n        + wordBoundary(needle[needle.length - 1]);\r\n}\r\n\r\nexports.Search = Search;\r\n});\r\n"]}