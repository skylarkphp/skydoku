{"version":3,"sources":["mode/text.js"],"names":["define","require","exports","module","config","Tokenizer","TextHighlightRules","CstyleBehaviour","unicode","lang","TokenIterator","Range","Mode","this","HighlightRules","$defaultBehaviour","tokenRe","RegExp","wordChars","nonTokenRe","getTokenizer","$tokenizer","$highlightRules","$highlightRuleConfig","getRules","lineCommentStart","blockComment","toggleCommentLines","state","session","startRow","endRow","doc","ignoreBlankLines","shouldRemove","minIndent","Infinity","tabSize","getTabSize","insertAtTabStop","Array","isArray","regexpStart","map","escapeRegExp","join","getUseSoftTabs","uncomment","line","i","m","match","start","length","end","shouldInsertSpace","removeInLine","commentWithSpace","comment","test","insertInLine","row","column","testRemove","before","after","spaces","charAt","lineCommentEnd","regexpEnd","tokens","getTokens","type","iter","fun","getLine","minEmptyLength","indent","search","Math","floor","toggleBlockComment","range","cursor","colDiff","token","iterator","getCurrentToken","initialRange","selection","toOrientedRange","startRange","endRange","value","indexOf","getCurrentTokenRow","getCurrentTokenColumn","stepBackward","stepForward","remove","insert","fromOrientedRange","getNextLineIndent","tab","$getIndent","checkOutdent","input","autoOutdent","createWorker","createModeDelegates","mapping","$embeds","$modes","id","prototype","$id","mode","push","delegations","scope","functionName","defaultHandler","$delegator","arguments","method","args","language","apply","concat","slice","call","split","ret","undefined","transformAction","action","editor","param","$behaviour","behaviours","getBehaviours","key","getKeywords","append","completionKeywords","rules","rule","ruleItr","r","l","regex","a","aLength","substr","$keywordList","$createKeywordList","getCompletions","pos","prefix","word","name","score","meta"],"mappings":"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","file":"../../mode/text.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\nvar config = require(\"../config\");\r\n\r\nvar Tokenizer = require(\"../tokenizer\").Tokenizer;\r\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\r\nvar unicode = require(\"../unicode\");\r\nvar lang = require(\"../lib/lang\");\r\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\r\nvar Range = require(\"../range\").Range;\r\n\r\nvar Mode = function() {\r\n    this.HighlightRules = TextHighlightRules;\r\n};\r\n\r\n(function() {\r\n    this.$defaultBehaviour = new CstyleBehaviour();\r\n\r\n    this.tokenRe = new RegExp(\"^[\" + unicode.wordChars + \"\\\\$_]+\", \"g\");\r\n\r\n    this.nonTokenRe = new RegExp(\"^(?:[^\" + unicode.wordChars + \"\\\\$_]|\\\\s])+\", \"g\");\r\n\r\n    this.getTokenizer = function() {\r\n        if (!this.$tokenizer) {\r\n            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);\r\n            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());\r\n        }\r\n        return this.$tokenizer;\r\n    };\r\n\r\n    this.lineCommentStart = \"\";\r\n    this.blockComment = \"\";\r\n\r\n    this.toggleCommentLines = function(state, session, startRow, endRow) {\r\n        var doc = session.doc;\r\n\r\n        var ignoreBlankLines = true;\r\n        var shouldRemove = true;\r\n        var minIndent = Infinity;\r\n        var tabSize = session.getTabSize();\r\n        var insertAtTabStop = false;\r\n\r\n        if (!this.lineCommentStart) {\r\n            if (!this.blockComment)\r\n                return false;\r\n            var lineCommentStart = this.blockComment.start;\r\n            var lineCommentEnd = this.blockComment.end;\r\n            var regexpStart = new RegExp(\"^(\\\\s*)(?:\" + lang.escapeRegExp(lineCommentStart) + \")\");\r\n            var regexpEnd = new RegExp(\"(?:\" + lang.escapeRegExp(lineCommentEnd) + \")\\\\s*$\");\r\n\r\n            var comment = function(line, i) {\r\n                if (testRemove(line, i))\r\n                    return;\r\n                if (!ignoreBlankLines || /\\S/.test(line)) {\r\n                    doc.insertInLine({row: i, column: line.length}, lineCommentEnd);\r\n                    doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\r\n                }\r\n            };\r\n\r\n            var uncomment = function(line, i) {\r\n                var m;\r\n                if (m = line.match(regexpEnd))\r\n                    doc.removeInLine(i, line.length - m[0].length, line.length);\r\n                if (m = line.match(regexpStart))\r\n                    doc.removeInLine(i, m[1].length, m[0].length);\r\n            };\r\n\r\n            var testRemove = function(line, row) {\r\n                if (regexpStart.test(line))\r\n                    return true;\r\n                var tokens = session.getTokens(row);\r\n                for (var i = 0; i < tokens.length; i++) {\r\n                    if (tokens[i].type === \"comment\")\r\n                        return true;\r\n                }\r\n            };\r\n        } else {\r\n            if (Array.isArray(this.lineCommentStart)) {\r\n                var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join(\"|\");\r\n                var lineCommentStart = this.lineCommentStart[0];\r\n            } else {\r\n                var regexpStart = lang.escapeRegExp(this.lineCommentStart);\r\n                var lineCommentStart = this.lineCommentStart;\r\n            }\r\n            regexpStart = new RegExp(\"^(\\\\s*)(?:\" + regexpStart + \") ?\");\r\n            \r\n            insertAtTabStop = session.getUseSoftTabs();\r\n\r\n            var uncomment = function(line, i) {\r\n                var m = line.match(regexpStart);\r\n                if (!m) return;\r\n                var start = m[1].length, end = m[0].length;\r\n                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == \" \")\r\n                    end--;\r\n                doc.removeInLine(i, start, end);\r\n            };\r\n            var commentWithSpace = lineCommentStart + \" \";\r\n            var comment = function(line, i) {\r\n                if (!ignoreBlankLines || /\\S/.test(line)) {\r\n                    if (shouldInsertSpace(line, minIndent, minIndent))\r\n                        doc.insertInLine({row: i, column: minIndent}, commentWithSpace);\r\n                    else\r\n                        doc.insertInLine({row: i, column: minIndent}, lineCommentStart);\r\n                }\r\n            };\r\n            var testRemove = function(line, i) {\r\n                return regexpStart.test(line);\r\n            };\r\n            \r\n            var shouldInsertSpace = function(line, before, after) {\r\n                var spaces = 0;\r\n                while (before-- && line.charAt(before) == \" \")\r\n                    spaces++;\r\n                if (spaces % tabSize != 0)\r\n                    return false;\r\n                var spaces = 0;\r\n                while (line.charAt(after++) == \" \")\r\n                    spaces++;\r\n                if (tabSize > 2)\r\n                    return spaces % tabSize != tabSize - 1;\r\n                else\r\n                    return spaces % tabSize == 0;\r\n            };\r\n        }\r\n\r\n        function iter(fun) {\r\n            for (var i = startRow; i <= endRow; i++)\r\n                fun(doc.getLine(i), i);\r\n        }\r\n\r\n\r\n        var minEmptyLength = Infinity;\r\n        iter(function(line, i) {\r\n            var indent = line.search(/\\S/);\r\n            if (indent !== -1) {\r\n                if (indent < minIndent)\r\n                    minIndent = indent;\r\n                if (shouldRemove && !testRemove(line, i))\r\n                    shouldRemove = false;\r\n            } else if (minEmptyLength > line.length) {\r\n                minEmptyLength = line.length;\r\n            }\r\n        });\r\n\r\n        if (minIndent == Infinity) {\r\n            minIndent = minEmptyLength;\r\n            ignoreBlankLines = false;\r\n            shouldRemove = false;\r\n        }\r\n\r\n        if (insertAtTabStop && minIndent % tabSize != 0)\r\n            minIndent = Math.floor(minIndent / tabSize) * tabSize;\r\n\r\n        iter(shouldRemove ? uncomment : comment);\r\n    };\r\n\r\n    this.toggleBlockComment = function(state, session, range, cursor) {\r\n        var comment = this.blockComment;\r\n        if (!comment)\r\n            return;\r\n        if (!comment.start && comment[0])\r\n            comment = comment[0];\r\n\r\n        var iterator = new TokenIterator(session, cursor.row, cursor.column);\r\n        var token = iterator.getCurrentToken();\r\n\r\n        var sel = session.selection;\r\n        var initialRange = session.selection.toOrientedRange();\r\n        var startRow, colDiff;\r\n\r\n        if (token && /comment/.test(token.type)) {\r\n            var startRange, endRange;\r\n            while (token && /comment/.test(token.type)) {\r\n                var i = token.value.indexOf(comment.start);\r\n                if (i != -1) {\r\n                    var row = iterator.getCurrentTokenRow();\r\n                    var column = iterator.getCurrentTokenColumn() + i;\r\n                    startRange = new Range(row, column, row, column + comment.start.length);\r\n                    break;\r\n                }\r\n                token = iterator.stepBackward();\r\n            }\r\n\r\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\r\n            var token = iterator.getCurrentToken();\r\n            while (token && /comment/.test(token.type)) {\r\n                var i = token.value.indexOf(comment.end);\r\n                if (i != -1) {\r\n                    var row = iterator.getCurrentTokenRow();\r\n                    var column = iterator.getCurrentTokenColumn() + i;\r\n                    endRange = new Range(row, column, row, column + comment.end.length);\r\n                    break;\r\n                }\r\n                token = iterator.stepForward();\r\n            }\r\n            if (endRange)\r\n                session.remove(endRange);\r\n            if (startRange) {\r\n                session.remove(startRange);\r\n                startRow = startRange.start.row;\r\n                colDiff = -comment.start.length;\r\n            }\r\n        } else {\r\n            colDiff = comment.start.length;\r\n            startRow = range.start.row;\r\n            session.insert(range.end, comment.end);\r\n            session.insert(range.start, comment.start);\r\n        }\r\n        // todo: selection should have ended up in the right place automatically!\r\n        if (initialRange.start.row == startRow)\r\n            initialRange.start.column += colDiff;\r\n        if (initialRange.end.row == startRow)\r\n            initialRange.end.column += colDiff;\r\n        session.selection.fromOrientedRange(initialRange);\r\n    };\r\n\r\n    this.getNextLineIndent = function(state, line, tab) {\r\n        return this.$getIndent(line);\r\n    };\r\n\r\n    this.checkOutdent = function(state, line, input) {\r\n        return false;\r\n    };\r\n\r\n    this.autoOutdent = function(state, doc, row) {\r\n    };\r\n\r\n    this.$getIndent = function(line) {\r\n        return line.match(/^\\s*/)[0];\r\n    };\r\n\r\n    this.createWorker = function(session) {\r\n        return null;\r\n    };\r\n\r\n    this.createModeDelegates = function (mapping) {\r\n        this.$embeds = [];\r\n        this.$modes = {};\r\n        for (var i in mapping) {\r\n            if (mapping[i]) {\r\n                var Mode = mapping[i];\r\n                var id = Mode.prototype.$id;\r\n                var mode = config.$modes[id];\r\n                if (!mode)\r\n                    config.$modes[id] = mode = new Mode();\r\n                if (!config.$modes[i])\r\n                    config.$modes[i] = mode;\r\n                this.$embeds.push(i);\r\n                this.$modes[i] = mode;\r\n            }\r\n        }\r\n\r\n        var delegations = [\"toggleBlockComment\", \"toggleCommentLines\", \"getNextLineIndent\", \r\n            \"checkOutdent\", \"autoOutdent\", \"transformAction\", \"getCompletions\"];\r\n\r\n        for (var i = 0; i < delegations.length; i++) {\r\n            (function(scope) {\r\n              var functionName = delegations[i];\r\n              var defaultHandler = scope[functionName];\r\n              scope[delegations[i]] = function() {\r\n                  return this.$delegator(functionName, arguments, defaultHandler);\r\n              };\r\n            }(this));\r\n        }\r\n    };\r\n\r\n    this.$delegator = function(method, args, defaultHandler) {\r\n        var state = args[0] || \"start\";\r\n        if (typeof state != \"string\") {\r\n            if (Array.isArray(state[2])) {\r\n                var language = state[2][state[2].length - 1];\r\n                var mode = this.$modes[language];\r\n                if (mode)\r\n                    return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));\r\n            }\r\n            state = state[0] || \"start\";\r\n        }\r\n            \r\n        for (var i = 0; i < this.$embeds.length; i++) {\r\n            if (!this.$modes[this.$embeds[i]]) continue;\r\n\r\n            var split = state.split(this.$embeds[i]);\r\n            if (!split[0] && split[1]) {\r\n                args[0] = split[1];\r\n                var mode = this.$modes[this.$embeds[i]];\r\n                return mode[method].apply(mode, args);\r\n            }\r\n        }\r\n        var ret = defaultHandler.apply(this, args);\r\n        return defaultHandler ? ret : undefined;\r\n    };\r\n\r\n    this.transformAction = function(state, action, editor, session, param) {\r\n        if (this.$behaviour) {\r\n            var behaviours = this.$behaviour.getBehaviours();\r\n            for (var key in behaviours) {\r\n                if (behaviours[key][action]) {\r\n                    var ret = behaviours[key][action].apply(this, arguments);\r\n                    if (ret) {\r\n                        return ret;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    this.getKeywords = function(append) {\r\n        // this is for autocompletion to pick up regexp'ed keywords\r\n        if (!this.completionKeywords) {\r\n            var rules = this.$tokenizer.rules;\r\n            var completionKeywords = [];\r\n            for (var rule in rules) {\r\n                var ruleItr = rules[rule];\r\n                for (var r = 0, l = ruleItr.length; r < l; r++) {\r\n                    if (typeof ruleItr[r].token === \"string\") {\r\n                        if (/keyword|support|storage/.test(ruleItr[r].token))\r\n                            completionKeywords.push(ruleItr[r].regex);\r\n                    }\r\n                    else if (typeof ruleItr[r].token === \"object\") {\r\n                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {    \r\n                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {\r\n                                // drop surrounding parens\r\n                                var rule = ruleItr[r].regex.match(/\\(.+?\\)/g)[a];\r\n                                completionKeywords.push(rule.substr(1, rule.length - 2));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.completionKeywords = completionKeywords;\r\n        }\r\n        // this is for highlighting embed rules, like HAML/Ruby or Obj-C/C\r\n        if (!append)\r\n            return this.$keywordList;\r\n        return completionKeywords.concat(this.$keywordList || []);\r\n    };\r\n    \r\n    this.$createKeywordList = function() {\r\n        if (!this.$highlightRules)\r\n            this.getTokenizer();\r\n        return this.$keywordList = this.$highlightRules.$keywordList || [];\r\n    };\r\n\r\n    this.getCompletions = function(state, session, pos, prefix) {\r\n        var keywords = this.$keywordList || this.$createKeywordList();\r\n        return keywords.map(function(word) {\r\n            return {\r\n                name: word,\r\n                value: word,\r\n                score: 0,\r\n                meta: \"keyword\"\r\n            };\r\n        });\r\n    };\r\n\r\n    this.$id = \"ace/mode/text\";\r\n}).call(Mode.prototype);\r\n\r\nexports.Mode = Mode;\r\n});\r\n"]}