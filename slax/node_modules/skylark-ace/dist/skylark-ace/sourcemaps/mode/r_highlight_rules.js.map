{"version":3,"sources":["mode/r_highlight_rules.js"],"names":["define","require","exports","module","oop","lang","TextHighlightRules","TexHighlightRules","RHighlightRules","keywords","arrayToMap","split","buildinConstants","this","$rules","start","token","regex","next","onMatch","value","match","qqstring","qstring","rdRules","getRules","i","length","addRules","unshift","push","inherits"],"mappings":";;;;;;;AAqCAA,OAAO,SAASC,EAASC,EAASC,GAG/B,IAAIC,EAAMH,EAAQ,cACdI,EAAOJ,EAAQ,eACfK,EAAqBL,EAAQ,0BAA0BK,mBACvDC,EAAoBN,EAAQ,yBAAyBM,kBAErDC,EAAkB,WAGnB,IAAIC,EAAWJ,EAAKK,WACd,6KACOC,MAAM,MAGfC,EAAmBP,EAAKK,WACtB,gFACgBC,MAAM,MAM5BE,KAAKC,QACFC,QAGMC,MAAQ,sBACRC,MAAQ,qCAIRD,MAAQ,UACRC,MAAQ,MACRC,KAAO,aAGPF,MAAQ,UACRC,MAAQ,SAGRD,MAAQ,SACRC,MAAQ,MACRC,KAAO,aAGPF,MAAQ,SACRC,MAAQ,MACRC,KAAO,YAGPF,MAAQ,mBACRC,MAAQ,8BAGRD,MAAQ,mBACRC,MAAQ,aAGRD,MAAQ,mBACRC,MAAQ,8CAGRD,MAAQ,mBACRC,MAAQ,qCAGRD,MAAQ,4BACRC,MAAQ,0BAGRD,MAAQ,aACRC,MAAQ,UAGRE,QAAU,SAASC,GAChB,OAAIX,EAASW,GACH,UACDR,EAAiBQ,GAChB,oBACQ,OAATA,GAAkBA,EAAMC,MAAM,aAC7B,oBAEA,cAEbJ,MAAQ,+BAGRD,MAAQ,mBACRC,MAAQ,+EAGRD,MAAQ,mBACRC,MAAQ,UAMRD,MAAQ,yBACRC,MAAQ,UAMRD,MAAQ,yBACRC,MAAQ,YAGRD,MAAQ,OACRC,MAAQ,SAGdK,WAEMN,MAAQ,SACRC,MAAQ,gCACRC,KAAO,UAGPF,MAAQ,SACRC,MAAQ,OAGdM,UAEMP,MAAQ,SACRC,MAAQ,gCACRC,KAAO,UAGPF,MAAQ,SACRC,MAAQ,QASjB,IAJA,IAAIO,EAAU,IAAIjB,EAAkB,WAAWkB,WAItCC,EAAI,EAAGA,EAAIF,EAAe,MAAEG,OAAQD,IAC1CF,EAAe,MAAEE,GAAGV,OAAS,mBAGhCH,KAAKe,SAASJ,EAAS,OACvBX,KAAKC,OAAO,YAAYe,SACpBb,MAAO,OACPC,MAAO,IACPC,KAAM,UAEVL,KAAKC,OAAO,YAAYe,SACrBb,MAAQ,UACRC,MAAQ,gBAEXJ,KAAKC,OAAO,YAAYe,SACrBb,MAAQ,UACRC,MAAQ,OAEXJ,KAAKC,OAAO,YAAYgB,MACrBd,MAAQ,UACRC,MAAQ,uBAIdb,EAAI2B,SAASvB,EAAiBF,GAE9BJ,EAAQM,gBAAkBA","file":"../../mode/r_highlight_rules.js","sourcesContent":["/*\r\n * r_highlight_rules.js\r\n *\r\n * Copyright (C) 2009-11 by RStudio, Inc.\r\n *\r\n * The Initial Developer of the Original Code is\r\n * Ajax.org B.V.\r\n * Portions created by the Initial Developer are Copyright (C) 2010\r\n * the Initial Developer. All Rights Reserved.\r\n *\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n *\r\n */\r\ndefine(function(require, exports, module)\r\n{\r\n\r\n   var oop = require(\"../lib/oop\");\r\n   var lang = require(\"../lib/lang\");\r\n   var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\n   var TexHighlightRules = require(\"./tex_highlight_rules\").TexHighlightRules;\r\n\r\n   var RHighlightRules = function()\r\n   {\r\n\r\n      var keywords = lang.arrayToMap(\r\n            (\"function|if|in|break|next|repeat|else|for|return|switch|while|try|tryCatch|stop|warning|require|library|attach|detach|source|setMethod|setGeneric|setGroupGeneric|setClass\")\r\n                  .split(\"|\")\r\n            );\r\n\r\n      var buildinConstants = lang.arrayToMap(\r\n            (\"NULL|NA|TRUE|FALSE|T|F|Inf|NaN|NA_integer_|NA_real_|NA_character_|\" +\r\n             \"NA_complex_\").split(\"|\")\r\n            );\r\n\r\n      // regexp must not have capturing parentheses. Use (?:) instead.\r\n      // regexps are ordered -> the first match is used\r\n\r\n      this.$rules = {\r\n         \"start\" : [\r\n            {\r\n               // Roxygen\r\n               token : \"comment.sectionhead\",\r\n               regex : \"#+(?!').*(?:----|====|####)\\\\s*$\"\r\n            },\r\n            {\r\n               // Roxygen\r\n               token : \"comment\",\r\n               regex : \"#+'\",\r\n               next : \"rd-start\"\r\n            },\r\n            {\r\n               token : \"comment\",\r\n               regex : \"#.*$\"\r\n            },\r\n            {\r\n               token : \"string\", // multi line string start\r\n               regex : '[\"]',\r\n               next : \"qqstring\"\r\n            },\r\n            {\r\n               token : \"string\", // multi line string start\r\n               regex : \"[']\",\r\n               next : \"qstring\"\r\n            },\r\n            {\r\n               token : \"constant.numeric\", // hex\r\n               regex : \"0[xX][0-9a-fA-F]+[Li]?\\\\b\"\r\n            },\r\n            {\r\n               token : \"constant.numeric\", // explicit integer\r\n               regex : \"\\\\d+L\\\\b\"\r\n            },\r\n            {\r\n               token : \"constant.numeric\", // number\r\n               regex : \"\\\\d+(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d*)?i?\\\\b\"\r\n            },\r\n            {\r\n               token : \"constant.numeric\", // number with leading decimal\r\n               regex : \"\\\\.\\\\d+(?:[eE][+\\\\-]?\\\\d*)?i?\\\\b\"\r\n            },\r\n            {\r\n               token : \"constant.language.boolean\",\r\n               regex : \"(?:TRUE|FALSE|T|F)\\\\b\"\r\n            },\r\n            {\r\n               token : \"identifier\",\r\n               regex : \"`.*?`\"\r\n            },\r\n            {\r\n               onMatch : function(value) {\r\n                  if (keywords[value])\r\n                     return \"keyword\";\r\n                  else if (buildinConstants[value])\r\n                     return \"constant.language\";\r\n                  else if (value == '...' || value.match(/^\\.\\.\\d+$/))\r\n                     return \"variable.language\";\r\n                  else\r\n                     return \"identifier\";\r\n               },\r\n               regex : \"[a-zA-Z.][a-zA-Z0-9._]*\\\\b\"\r\n            },\r\n            {\r\n               token : \"keyword.operator\",\r\n               regex : \"%%|>=|<=|==|!=|\\\\->|<\\\\-|\\\\|\\\\||&&|=|\\\\+|\\\\-|\\\\*|/|\\\\^|>|<|!|&|\\\\||~|\\\\$|:\"\r\n            },\r\n            {\r\n               token : \"keyword.operator\", // infix operators\r\n               regex : \"%.*?%\"\r\n            },\r\n            {\r\n               // Obviously these are neither keywords nor operators, but\r\n               // labelling them as such was the easiest way to get them\r\n               // to be colored distinctly from regular text\r\n               token : \"paren.keyword.operator\",\r\n               regex : \"[[({]\"\r\n            },\r\n            {\r\n               // Obviously these are neither keywords nor operators, but\r\n               // labelling them as such was the easiest way to get them\r\n               // to be colored distinctly from regular text\r\n               token : \"paren.keyword.operator\",\r\n               regex : \"[\\\\])}]\"\r\n            },\r\n            {\r\n               token : \"text\",\r\n               regex : \"\\\\s+\"\r\n            }\r\n         ],\r\n         \"qqstring\" : [\r\n            {\r\n               token : \"string\",\r\n               regex : '(?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?\"',\r\n               next : \"start\"\r\n            },\r\n            {\r\n               token : \"string\",\r\n               regex : '.+'\r\n            }\r\n         ],\r\n         \"qstring\" : [\r\n            {\r\n               token : \"string\",\r\n               regex : \"(?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?'\",\r\n               next : \"start\"\r\n            },\r\n            {\r\n               token : \"string\",\r\n               regex : '.+'\r\n            }\r\n         ]\r\n      };\r\n\r\n      var rdRules = new TexHighlightRules(\"comment\").getRules();\r\n\r\n      // Make all embedded TeX virtual-comment so they don't interfere with\r\n      // auto-indent.\r\n      for (var i = 0; i < rdRules[\"start\"].length; i++) {\r\n         rdRules[\"start\"][i].token += \".virtual-comment\";\r\n      }\r\n\r\n      this.addRules(rdRules, \"rd-\");\r\n      this.$rules[\"rd-start\"].unshift({\r\n          token: \"text\",\r\n          regex: \"^\",\r\n          next: \"start\"\r\n      });\r\n      this.$rules[\"rd-start\"].unshift({\r\n         token : \"keyword\",\r\n         regex : \"@(?!@)[^ ]*\"\r\n      });\r\n      this.$rules[\"rd-start\"].unshift({\r\n         token : \"comment\",\r\n         regex : \"@@\"\r\n      });\r\n      this.$rules[\"rd-start\"].push({\r\n         token : \"comment\",\r\n         regex : \"[^%\\\\\\\\[({\\\\])}]+\"\r\n      });\r\n   };\r\n\r\n   oop.inherits(RHighlightRules, TextHighlightRules);\r\n\r\n   exports.RHighlightRules = RHighlightRules;\r\n});\r\n"]}