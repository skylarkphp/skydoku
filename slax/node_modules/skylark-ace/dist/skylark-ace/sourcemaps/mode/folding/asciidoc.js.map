{"version":3,"sources":["mode/folding/asciidoc.js"],"names":["define","require","exports","module","oop","BaseFoldMode","FoldMode","Range","inherits","this","foldingStartMarker","singleLineHeadingRe","getFoldWidget","session","foldStyle","row","line","getLine","test","length","bgTokenizer","getState","getFoldWidgetRange","startColumn","maxRow","getLength","startRow","endRow","match","token","levels","getTokenType","startHeadingLevel","getLevel","value","endColumn","lastIndexOf","getTokens","type","level","indexOf","Infinity","call","prototype"],"mappings":";;;;;;;AA8BAA,OAAO,SAASC,EAASC,EAASC,GAClC,aAEA,IAAIC,EAAMH,EAAQ,iBACdI,EAAeJ,EAAQ,eAAeK,SACtCC,EAAQN,EAAQ,eAAeM,MAE/BD,EAAWJ,EAAQI,SAAW,aAClCF,EAAII,SAASF,EAAUD,GAEvB,WACII,KAAKC,mBAAqB,6CAC1BD,KAAKE,oBAAsB,mBAE3BF,KAAKG,cAAgB,SAASC,EAASC,EAAWC,GAC9C,IAAIC,EAAOH,EAAQI,QAAQF,GAC3B,OAAKN,KAAKC,mBAAmBQ,KAAKF,GAGnB,KAAXA,EAAK,GACDP,KAAKE,oBAAoBO,KAAKF,GACvB,QACPH,EAAQI,QAAQF,EAAM,GAAGI,QAAUN,EAAQI,QAAQF,GAAKI,OACjD,GACJ,QAE8B,2BAArCN,EAAQO,YAAYC,SAASN,GACtB,MACJ,QAXI,IAcfN,KAAKa,mBAAqB,SAAST,EAASC,EAAWC,GACnD,IAAIC,EAAOH,EAAQI,QAAQF,GACvBQ,EAAcP,EAAKG,OACnBK,EAASX,EAAQY,YACjBC,EAAWX,EACXY,EAASZ,EACb,GAAKC,EAAKY,MAAMnB,KAAKC,oBAArB,CAGA,IAAImB,EAMAC,GAAU,IAAI,IAAI,IAAI,IAAI,KAE1BnB,EAAsBF,KAAKE,oBAa/B,GAdc,kBAcVoB,EAAahB,GAAiB,CAE9B,IADA,IAAIiB,EAAoBC,MACflB,EAAMS,GAAQ,CACnB,GAjBM,kBAiBFO,EAAahB,GAGjB,GADYkB,KACCD,EACT,MAMR,IAFAL,EAD0BE,GAASA,EAAMK,MAAMN,MAAMnB,KAAKE,qBAC3BI,EAAM,EAAIA,EAAM,GAElCW,EACT,KAAOC,EAASD,KAAcK,EAAaJ,IAA6B,KAAlBE,EAAMK,MAAM,KAC9DP,IAGR,GAAIA,EAASD,EAAU,CACnB,IAAIS,EAAYtB,EAAQI,QAAQU,GAAQR,OACxC,OAAO,IAAIZ,EAAMmB,EAAUH,EAAaI,EAAQQ,QAEjD,CAEH,GAAa,2BADDtB,EAAQO,YAAYC,SAASN,GACD,CACpC,KAAOA,KAAS,IACmD,GAA3DF,EAAQO,YAAYC,SAASN,GAAKqB,YAAY,WAItD,IADAT,EAASZ,EAAM,GACFW,EAAU,CACfS,EAAYtB,EAAQI,QAAQF,GAAKI,OACrC,OAAO,IAAIZ,EAAMoB,EAAQ,EAAGD,EAAUH,EAAc,QAErD,CACH,OAASR,EAAMS,GAC8B,2BAArCX,EAAQO,YAAYC,SAASN,KAIrC,IADAY,EAASZ,GACIW,EAAU,CACfS,EAAYtB,EAAQI,QAAQF,GAAKI,OACrC,OAAO,IAAIZ,EAAMmB,EAAU,EAAGC,EAAQQ,EAAY,MA9D9D,SAASJ,EAAahB,GAElB,OADAc,EAAQhB,EAAQwB,UAAUtB,GAAK,KACfc,EAAMS,KAM1B,SAASL,IACL,IAAIL,EAAQC,EAAMK,MAAMN,MAAMjB,GAC9B,GAAIiB,EACA,OAAOA,EAAM,GAAGT,OACpB,IAAIoB,EAAQT,EAAOU,QAAQX,EAAMK,MAAM,IAAM,EAC7C,OAAa,GAATK,GACI1B,EAAQI,QAAQF,EAAM,GAAGI,QAAUN,EAAQI,QAAQF,GAAKI,OACjDsB,EAAAA,EAERF,KAmDhBG,KAAKpC,EAASqC","file":"../../../mode/folding/asciidoc.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../../lib/oop\");\r\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\r\nvar Range = require(\"../../range\").Range;\r\n\r\nvar FoldMode = exports.FoldMode = function() {};\r\noop.inherits(FoldMode, BaseFoldMode);\r\n\r\n(function() {\r\n    this.foldingStartMarker = /^(?:\\|={10,}|[\\.\\/=\\-~^+]{4,}\\s*$|={1,5} )/;\r\n    this.singleLineHeadingRe = /^={1,5}(?=\\s+\\S)/;\r\n\r\n    this.getFoldWidget = function(session, foldStyle, row) {\r\n        var line = session.getLine(row);\r\n        if (!this.foldingStartMarker.test(line))\r\n            return \"\";\r\n\r\n        if (line[0] == \"=\") {\r\n            if (this.singleLineHeadingRe.test(line))\r\n                return \"start\";\r\n            if (session.getLine(row - 1).length != session.getLine(row).length)\r\n                return \"\";\r\n            return \"start\";\r\n        }\r\n        if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\")\r\n            return \"end\";\r\n        return \"start\";\r\n    };\r\n\r\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\r\n        var line = session.getLine(row);\r\n        var startColumn = line.length;\r\n        var maxRow = session.getLength();\r\n        var startRow = row;\r\n        var endRow = row;\r\n        if (!line.match(this.foldingStartMarker))\r\n            return;\r\n\r\n        var token;\r\n        function getTokenType(row) {\r\n            token = session.getTokens(row)[0];\r\n            return token && token.type;\r\n        }\r\n\r\n        var levels = [\"=\",\"-\",\"~\",\"^\",\"+\"];\r\n        var heading = \"markup.heading\";\r\n        var singleLineHeadingRe = this.singleLineHeadingRe;\r\n        function getLevel() {\r\n            var match = token.value.match(singleLineHeadingRe);\r\n            if (match)\r\n                return match[0].length;\r\n            var level = levels.indexOf(token.value[0]) + 1;\r\n            if (level == 1) {\r\n                if (session.getLine(row - 1).length != session.getLine(row).length)\r\n                    return Infinity;\r\n            }\r\n            return level;\r\n        }\r\n\r\n        if (getTokenType(row) == heading) {\r\n            var startHeadingLevel = getLevel();\r\n            while (++row < maxRow) {\r\n                if (getTokenType(row) != heading)\r\n                    continue;\r\n                var level = getLevel();\r\n                if (level <= startHeadingLevel)\r\n                    break;\r\n            }\r\n\r\n            var isSingleLineHeading = token && token.value.match(this.singleLineHeadingRe);\r\n            endRow = isSingleLineHeading ? row - 1 : row - 2;\r\n\r\n            if (endRow > startRow) {\r\n                while (endRow > startRow && (!getTokenType(endRow) || token.value[0] == \"[\"))\r\n                    endRow--;\r\n            }\r\n\r\n            if (endRow > startRow) {\r\n                var endColumn = session.getLine(endRow).length;\r\n                return new Range(startRow, startColumn, endRow, endColumn);\r\n            }\r\n        } else {\r\n            var state = session.bgTokenizer.getState(row);\r\n            if (state == \"dissallowDelimitedBlock\") {\r\n                while (row -- > 0) {\r\n                    if (session.bgTokenizer.getState(row).lastIndexOf(\"Block\") == -1)\r\n                        break;\r\n                }\r\n                endRow = row + 1;\r\n                if (endRow < startRow) {\r\n                    var endColumn = session.getLine(row).length;\r\n                    return new Range(endRow, 5, startRow, startColumn - 5);\r\n                }\r\n            } else {\r\n                while (++row < maxRow) {\r\n                    if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\")\r\n                        break;\r\n                }\r\n                endRow = row;\r\n                if (endRow > startRow) {\r\n                    var endColumn = session.getLine(row).length;\r\n                    return new Range(startRow, 5, endRow, endColumn - 5);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n}).call(FoldMode.prototype);\r\n\r\n});\r\n"]}