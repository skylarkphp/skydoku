{"version":3,"sources":["mode/folding/latex.js"],"names":["define","require","exports","module","oop","BaseFoldMode","FoldMode","Range","TokenIterator","keywordLevels","\\subparagraph","\\paragraph","\\subsubsubsection","\\subsubsection","\\subsection","\\section","\\chapter","\\part","\\begin","\\end","inherits","this","foldingStartMarker","foldingStopMarker","getFoldWidgetRange","session","foldStyle","row","match","line","doc","getLine","exec","latexBlock","length","latexSection","openingBracketBlock","index","closingBracketBlock","column","returnRange","keywords","stream","token","getCurrentToken","type","dir","value","getType","stepForward","stepBackward","stack","startColumn","getCurrentTokenColumn","startRow","step","level","unshift","shift","getCurrentTokenRange","getCurrentTokenRow","startLevel","stackDepth","endRow","test","call","prototype"],"mappings":"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","file":"../../../mode/folding/latex.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2012, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../../lib/oop\");\r\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\r\nvar Range = require(\"../../range\").Range;\r\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\r\nvar keywordLevels = {\r\n    \"\\\\subparagraph\": 1,\r\n    \"\\\\paragraph\": 2,\r\n    \"\\\\subsubsubsection\": 3,\r\n    \"\\\\subsubsection\": 4,\r\n    \"\\\\subsection\": 5,\r\n    \"\\\\section\": 6,\r\n    \"\\\\chapter\": 7,\r\n    \"\\\\part\": 8,\r\n    \"\\\\begin\": 9,\r\n    \"\\\\end\": 10\r\n};\r\n\r\nvar FoldMode = exports.FoldMode = function() {};\r\n\r\noop.inherits(FoldMode, BaseFoldMode);\r\n\r\n(function() {\r\n\r\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\r\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\r\n\r\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\r\n        var line = session.doc.getLine(row);\r\n        var match = this.foldingStartMarker.exec(line);\r\n        if (match) {\r\n            if (match[1])\r\n                return this.latexBlock(session, row, match[0].length - 1);\r\n            if (match[2])\r\n                return this.latexSection(session, row, match[0].length - 1);\r\n\r\n            return this.openingBracketBlock(session, \"{\", row, match.index);\r\n        }\r\n\r\n        var match = this.foldingStopMarker.exec(line);\r\n        if (match) {\r\n            if (match[1])\r\n                return this.latexBlock(session, row, match[0].length - 1);\r\n\r\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\r\n        }\r\n    };\r\n\r\n    this.latexBlock = function(session, row, column, returnRange) {\r\n        var keywords = {\r\n            \"\\\\begin\": 1,\r\n            \"\\\\end\": -1\r\n        };\r\n\r\n        var stream = new TokenIterator(session, row, column);\r\n        var token = stream.getCurrentToken();\r\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\r\n            return;\r\n\r\n        var val = token.value;\r\n        var dir = keywords[val];\r\n\r\n        var getType = function() {\r\n            var token = stream.stepForward();\r\n            var type = token.type == \"lparen\" ?stream.stepForward().value : \"\";\r\n            if (dir === -1) {\r\n                stream.stepBackward();\r\n                if (type)\r\n                    stream.stepBackward();\r\n            }\r\n            return type;\r\n        };\r\n        var stack = [getType()];\r\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\r\n        var startRow = row;\r\n\r\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\r\n        while(token = stream.step()) {\r\n            if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\r\n                continue;\r\n            var level = keywords[token.value];\r\n            if (!level)\r\n                continue;\r\n            var type = getType();\r\n            if (level === dir)\r\n                stack.unshift(type);\r\n            else if (stack.shift() !== type || !stack.length)\r\n                break;\r\n        }\r\n\r\n        if (stack.length)\r\n            return;\r\n        \r\n        if (dir == 1) {\r\n            stream.stepBackward();\r\n            stream.stepBackward();\r\n        }\r\n        \r\n        if (returnRange)\r\n            return stream.getCurrentTokenRange();\r\n\r\n        var row = stream.getCurrentTokenRow();\r\n        if (dir === -1)\r\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\r\n        else\r\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\r\n    };\r\n\r\n    this.latexSection = function(session, row, column) {\r\n        var stream = new TokenIterator(session, row, column);\r\n        var token = stream.getCurrentToken();\r\n        if (!token || token.type != \"storage.type\")\r\n            return;\r\n\r\n        var startLevel = keywordLevels[token.value] || 0;\r\n        var stackDepth = 0;\r\n        var endRow = row;\r\n\r\n        while(token = stream.stepForward()) {\r\n            if (token.type !== \"storage.type\")\r\n                continue;\r\n            var level = keywordLevels[token.value] || 0;\r\n\r\n            if (level >= 9) {\r\n                if (!stackDepth)\r\n                    endRow = stream.getCurrentTokenRow() - 1;\r\n                stackDepth += level == 9 ? 1 : - 1;\r\n                if (stackDepth < 0)\r\n                    break;\r\n            } else if (level >= startLevel)\r\n                break;\r\n        }\r\n\r\n        if (!stackDepth)\r\n            endRow = stream.getCurrentTokenRow() - 1;\r\n\r\n        while (endRow > row && !/\\S/.test(session.getLine(endRow)))\r\n            endRow--;\r\n\r\n        return new Range(\r\n            row, session.getLine(row).length,\r\n            endRow, session.getLine(endRow).length\r\n        );\r\n    };\r\n\r\n}).call(FoldMode.prototype);\r\n\r\n});\r\n"]}