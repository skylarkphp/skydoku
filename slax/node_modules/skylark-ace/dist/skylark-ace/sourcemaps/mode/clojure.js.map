{"version":3,"sources":["mode/clojure.js"],"names":["define","require","exports","module","oop","TextMode","Mode","ClojureHighlightRules","MatchingParensOutdent","this","HighlightRules","$outdent","$behaviour","$defaultBehaviour","inherits","lineCommentStart","minorIndentFunctions","$toIndent","str","split","map","ch","exec","join","$calculateIndent","line","tab","isParen","baseIndent","$getIndent","delta","i","length","substring","iBefore","fn","indexOf","undefined","getNextLineIndent","state","checkOutdent","input","autoOutdent","doc","row","$id","call","prototype"],"mappings":";;;;;;;AA8BAA,OAAO,SAASC,EAASC,EAASC,GAClC,aAEA,IAAIC,EAAMH,EAAQ,cACdI,EAAWJ,EAAQ,UAAUK,KAC7BC,EAAwBN,EAAQ,6BAA6BM,sBAC7DC,EAAwBP,EAAQ,6BAA6BO,sBAE7DF,EAAO,WACPG,KAAKC,eAAiBH,EACtBE,KAAKE,SAAW,IAAIH,EACpBC,KAAKG,WAAaH,KAAKI,mBAE3BT,EAAIU,SAASR,EAAMD,GAEnB,WAEII,KAAKM,iBAAmB,IACxBN,KAAKO,sBAAwB,OAAQ,QAAS,WAAY,MAAO,UAAW,WAE5EP,KAAKQ,UAAY,SAASC,GACtB,OAAOA,EAAIC,MAAM,IAAIC,IAAI,SAASC,GAC9B,MAAI,KAAKC,KAAKD,GACHA,EAEA,MAEZE,KAAK,KAGZd,KAAKe,iBAAmB,SAASC,EAAMC,GAKnC,IAJA,IAEIC,EAASN,EAFTO,EAAanB,KAAKoB,WAAWJ,GAC7BK,EAAQ,EAGHC,EAAIN,EAAKO,OAAS,EAAGD,GAAK,IAEpB,OADXV,EAAKI,EAAKM,KAEND,IACAH,GAAU,GACI,MAAPN,GAAqB,MAAPA,GAAqB,MAAPA,GACnCS,IACAH,GAAU,GACI,MAAPN,GAAqB,MAAPA,GAAqB,MAAPA,GACnCS,MAEAA,EAAQ,IAXsBC,KAetC,KAAID,EAAQ,GAAKH,GAmBV,OAAGG,EAAQ,IAAMH,EAEblB,KAAKQ,UAAUQ,EAAKQ,UAAU,EAAGF,EAAE,IACpCD,EAAQ,EAEdF,EAAaA,EAAWK,UAAU,EAAGL,EAAWI,OAASN,EAAIM,QAItDJ,EAvBP,IAFA,IAAIM,EADJH,GAAK,EAEDI,EAAK,KACI,CAET,GAAW,OADXd,EAAKI,EAAKM,KACe,OAAPV,EACd,OAA8C,IAA3CZ,KAAKO,qBAAqBoB,QAAQD,GAC1B1B,KAAKQ,UAAUQ,EAAKQ,UAAU,EAAGC,EAAU,GAAKR,GAEhDjB,KAAKQ,UAAUQ,EAAKQ,UAAU,EAAGF,EAAI,IAE7C,QAAWM,IAAPhB,EACP,OAAOZ,KAAKQ,UAAUQ,EAAKQ,UAAU,EAAGC,EAAU,GAAKR,GAE3DS,GAAMV,EAAKM,GACXA,MAeZtB,KAAK6B,kBAAoB,SAASC,EAAOd,EAAMC,GAC3C,OAAOjB,KAAKe,iBAAiBC,EAAMC,IAGvCjB,KAAK+B,aAAe,SAASD,EAAOd,EAAMgB,GACtC,OAAOhC,KAAKE,SAAS6B,aAAaf,EAAMgB,IAG5ChC,KAAKiC,YAAc,SAASH,EAAOI,EAAKC,GACpCnC,KAAKE,SAAS+B,YAAYC,EAAKC,IAGnCnC,KAAKoC,IAAM,oBACZC,KAAKxC,EAAKyC,WAEb7C,EAAQI,KAAOA","file":"../../mode/clojure.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../lib/oop\");\r\nvar TextMode = require(\"./text\").Mode;\r\nvar ClojureHighlightRules = require(\"./clojure_highlight_rules\").ClojureHighlightRules;\r\nvar MatchingParensOutdent = require(\"./matching_parens_outdent\").MatchingParensOutdent;\r\n\r\nvar Mode = function() {\r\n    this.HighlightRules = ClojureHighlightRules;\r\n    this.$outdent = new MatchingParensOutdent();\r\n    this.$behaviour = this.$defaultBehaviour;\r\n};\r\noop.inherits(Mode, TextMode);\r\n\r\n(function() {\r\n\r\n    this.lineCommentStart = \";\";\r\n    this.minorIndentFunctions = [\"defn\", \"defn-\", \"defmacro\", \"def\", \"deftest\", \"testing\"];\r\n\r\n    this.$toIndent = function(str) {\r\n        return str.split('').map(function(ch) {\r\n            if (/\\s/.exec(ch)) {\r\n                return ch;\r\n            } else {\r\n                return ' ';\r\n            }\r\n        }).join('');\r\n    };\r\n\r\n    this.$calculateIndent = function(line, tab) {\r\n        var baseIndent = this.$getIndent(line);\r\n        var delta = 0;\r\n        var isParen, ch;\r\n        // Walk back from end of line, find matching braces\r\n        for (var i = line.length - 1; i >= 0; i--) {\r\n            ch = line[i];\r\n            if (ch === '(') {\r\n                delta--;\r\n                isParen = true;\r\n            } else if (ch === '(' || ch === '[' || ch === '{') {\r\n                delta--;\r\n                isParen = false;\r\n            } else if (ch === ')' || ch === ']' || ch === '}') {\r\n                delta++;\r\n            }\r\n            if (delta < 0) {\r\n                break;\r\n            }\r\n        }\r\n        if (delta < 0 && isParen) {\r\n            // Were more brackets opened than closed and was a ( left open?\r\n            i += 1;\r\n            var iBefore = i;\r\n            var fn = '';\r\n            while (true) {\r\n                ch = line[i];\r\n                if (ch === ' ' || ch === '\\t') {\r\n                    if(this.minorIndentFunctions.indexOf(fn) !== -1) {\r\n                        return this.$toIndent(line.substring(0, iBefore - 1) + tab);\r\n                    } else {\r\n                        return this.$toIndent(line.substring(0, i + 1));\r\n                    }\r\n                } else if (ch === undefined) {\r\n                    return this.$toIndent(line.substring(0, iBefore - 1) + tab);\r\n                }\r\n                fn += line[i];\r\n                i++;\r\n            }\r\n        } else if(delta < 0 && !isParen) {\r\n            // Were more brackets openend than closed and was it not a (?\r\n            return this.$toIndent(line.substring(0, i+1));\r\n        } else if(delta > 0) {\r\n            // Mere more brackets closed than opened? Outdent.\r\n            baseIndent = baseIndent.substring(0, baseIndent.length - tab.length);\r\n            return baseIndent;\r\n        } else {\r\n            // Were they nicely matched? Just indent like line before.\r\n            return baseIndent;\r\n        }\r\n    };\r\n\r\n    this.getNextLineIndent = function(state, line, tab) {\r\n        return this.$calculateIndent(line, tab);\r\n    };\r\n\r\n    this.checkOutdent = function(state, line, input) {\r\n        return this.$outdent.checkOutdent(line, input);\r\n    };\r\n\r\n    this.autoOutdent = function(state, doc, row) {\r\n        this.$outdent.autoOutdent(doc, row);\r\n    };\r\n\r\n    this.$id = \"ace/mode/clojure\";\r\n}).call(Mode.prototype);\r\n\r\nexports.Mode = Mode;\r\n});\r\n"]}