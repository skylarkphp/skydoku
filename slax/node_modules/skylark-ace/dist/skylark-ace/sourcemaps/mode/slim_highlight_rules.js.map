{"version":3,"sources":["mode/slim_highlight_rules.js"],"names":["define","require","exports","module","modes","$modes","oop","TextHighlightRules","SlimHighlightRules","this","$rules","start","token","regex","onMatch","value","state","stack","line","indent","exec","language","match","test","unshift","stateName","next","length","splice","shift","type","embedState","data","getTokenizer","getLineTokens","slice","tokens","val","push","include","mlString","defaultToken","rubyline","misc","normalizeRules","inherits"],"mappings":"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","file":"../../mode/slim_highlight_rules.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2012, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar modes = require(\"../config\").$modes;\r\n\r\nvar oop = require(\"../lib/oop\");\r\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\nvar SlimHighlightRules = function() {\r\n\r\n    this.$rules = {\r\n        \"start\": [\r\n            {\r\n                token: \"keyword\",\r\n                regex: /^(\\s*)(\\w+):\\s*/,\r\n                onMatch: function(value, state, stack, line) {\r\n                    var indent = /^\\s*/.exec(line)[0];\r\n                    var m = value.match(/^(\\s*)(\\w+):/);\r\n                    var language = m[2];\r\n                    if (!/^(javascript|ruby|coffee|markdown|css|scss|sass|less)$/.test(language))\r\n                        language = \"\";\r\n                    stack.unshift(\"language-embed\", [], [indent, language], state);\r\n                    return this.token;\r\n                },\r\n                stateName: \"language-embed\",\r\n                next: [{\r\n                    token: \"string\",\r\n                    regex: /^(\\s*)/,\r\n                    onMatch: function(value, state, stack, line) {\r\n                        var indent = stack[2][0];\r\n                        if (indent.length >= value.length) {\r\n                            stack.splice(0, 3);\r\n                            this.next = stack.shift();\r\n                            return this.token;\r\n                        }\r\n                        this.next = \"\";\r\n                        return [{type: \"text\", value: indent}];\r\n                    },\r\n                    next: \"\"\r\n                }, {\r\n                    token: \"string\",\r\n                    regex: /.+/,\r\n                    onMatch: function(value, state, stack, line) {\r\n                        var indent = stack[2][0];\r\n                        var language = stack[2][1];\r\n                        var embedState = stack[1];\r\n                        \r\n                        if (modes[language]) {\r\n                            var data = modes[language].getTokenizer().getLineTokens(line.slice(indent.length), embedState.slice(0));\r\n                            stack[1] = data.state;\r\n                            return data.tokens;\r\n                        }\r\n                        return this.token;\r\n                    }\r\n                }]\r\n            },\r\n            {\r\n                token: 'constant.begin.javascript.filter.slim',\r\n                regex: '^(\\\\s*)():$'\r\n            }, {\r\n                token: 'constant.begin..filter.slim',\r\n                regex: '^(\\\\s*)(ruby):$'\r\n            }, {\r\n                token: 'constant.begin.coffeescript.filter.slim',\r\n                regex: '^(\\\\s*)():$'\r\n            }, {\r\n                token: 'constant.begin..filter.slim',\r\n                regex: '^(\\\\s*)(markdown):$'\r\n            }, {\r\n                token: 'constant.begin.css.filter.slim',\r\n                regex: '^(\\\\s*)():$'\r\n            }, {\r\n                token: 'constant.begin.scss.filter.slim',\r\n                regex: '^(\\\\s*)():$'\r\n            }, {\r\n                token: 'constant.begin..filter.slim',\r\n                regex: '^(\\\\s*)(sass):$'\r\n            }, {\r\n                token: 'constant.begin..filter.slim',\r\n                regex: '^(\\\\s*)(less):$'\r\n            }, {\r\n                token: 'constant.begin..filter.slim',\r\n                regex: '^(\\\\s*)(erb):$'\r\n            }, {\r\n                token: 'keyword.html.tags.slim',\r\n                regex: '^(\\\\s*)((:?\\\\*(\\\\w)+)|doctype html|abbr|acronym|address|applet|area|article|aside|audio|base|basefont|bdo|big|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|command|datalist|dd|del|details|dialog|dfn|dir|div|dl|dt|embed|fieldset|figure|font|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|iframe|img|input|ins|keygen|kbd|label|legend|link|li|map|mark|menu|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|rp|rt|ruby|samp|script|section|select|small|source|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video|xmp|b|u|s|em|a)(?:([.#](\\\\w|\\\\.)+)+\\\\s?)?\\\\b'\r\n\r\n            }, {\r\n                token: 'keyword.slim',\r\n                regex: '^(\\\\s*)(?:([.#](\\\\w|\\\\.)+)+\\\\s?)'\r\n            }, {\r\n                token: \"string\",\r\n                regex: /^(\\s*)('|\\||\\/|(\\/!))\\s*/,\r\n                onMatch: function(val, state, stack, line) {\r\n                    var indent = /^\\s*/.exec(line)[0];\r\n                    if (stack.length < 1) {\r\n                        stack.push(this.next);\r\n                    }\r\n                    else {\r\n                        stack[0] = \"mlString\";\r\n                    }\r\n\r\n                    if (stack.length < 2) {\r\n                        stack.push(indent.length);\r\n                    }\r\n                    else {\r\n                        stack[1] = indent.length;\r\n                    }\r\n                    return this.token;\r\n                },\r\n                next: \"mlString\"\r\n            }, {\r\n                token: 'keyword.control.slim',\r\n                regex: '^(\\\\s*)(\\\\-|==|=)',\r\n                push: [{\r\n                    token: 'control.end.slim',\r\n                    regex: '$',\r\n                    next: \"pop\"\r\n                }, {\r\n                    include: \"rubyline\"\r\n                }, {\r\n                    include: \"misc\"\r\n                }]\r\n\r\n            }, {\r\n                token: 'paren',\r\n                regex: '\\\\(',\r\n                push: [{\r\n                    token: 'paren',\r\n                    regex: '\\\\)',\r\n                    next: \"pop\"\r\n                }, {\r\n                    include: \"misc\"\r\n                }]\r\n\r\n            }, {\r\n                token: 'paren',\r\n                regex: '\\\\[',\r\n                push: [{\r\n                    token: 'paren',\r\n                    regex: '\\\\]',\r\n                    next: \"pop\"\r\n                }, {\r\n                    include: \"misc\"\r\n                }]\r\n            }, {\r\n                include: \"misc\"\r\n            }\r\n        ],\r\n        \"mlString\": [{\r\n            token: \"indent\",\r\n            regex: /^\\s*/,\r\n            onMatch: function(val, state, stack) {\r\n                var curIndent = stack[1];\r\n\r\n                if (curIndent >= val.length) {\r\n                    this.next = \"start\";\r\n                    stack.splice(0);\r\n                }\r\n                else {\r\n                    this.next = \"mlString\";\r\n                }\r\n                return this.token;\r\n            },\r\n            next: \"start\"\r\n        }, {\r\n            defaultToken: \"string\"\r\n        }],\r\n        \"rubyline\": [{\r\n            token: \"keyword.operator.ruby.embedded.slim\",\r\n            regex: \"(==|=)(<>|><|<'|'<|<|>)?|-\"\r\n        }, {\r\n            token: \"list.ruby.operators.slim\",\r\n            regex: \"(\\\\b)(for|in|do|if|else|elsif|unless|while|yield|not|and|or)\\\\b\"\r\n        }, {\r\n            token: \"string\",\r\n            regex: \"['](.)*?[']\"\r\n        }, {\r\n            token: \"string\",\r\n            regex: \"[\\\"](.)*?[\\\"]\"\r\n        }],\r\n        \"misc\": [{\r\n            token: 'class.variable.slim',\r\n            regex: '\\\\@([a-zA-Z_][a-zA-Z0-9_]*)\\\\b'\r\n        }, {\r\n            token: \"list.meta.slim\",\r\n            regex: \"(\\\\b)(true|false|nil)(\\\\b)\"\r\n        }, {\r\n            token: 'keyword.operator.equals.slim',\r\n            regex: '='\r\n        }, {\r\n            token: \"string\",\r\n            regex: \"['](.)*?[']\"\r\n        }, {\r\n            token: \"string\",\r\n            regex: \"[\\\"](.)*?[\\\"]\"\r\n        }]\r\n    };\r\n    this.normalizeRules();\r\n};\r\n\r\n\r\noop.inherits(SlimHighlightRules, TextHighlightRules);\r\n\r\nexports.SlimHighlightRules = SlimHighlightRules;\r\n});\r\n"]}