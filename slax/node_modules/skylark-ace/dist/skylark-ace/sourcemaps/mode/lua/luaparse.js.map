{"version":3,"sources":["mode/lua/luaparse.js"],"names":["define","require","exports","module","input","options","length","version","defaultOptions","wait","comments","scope","locations","ranges","EOF","StringLiteral","Keyword","Identifier","NumericLiteral","Punctuator","BooleanLiteral","NilLiteral","VarargLiteral","tokenTypes","errors","unexpected","expected","expectedToken","unfinishedString","malformedNumber","ast","labelStatement","label","type","breakStatement","gotoStatement","returnStatement","args","arguments","ifStatement","clauses","ifClause","condition","body","elseifClause","elseClause","whileStatement","doStatement","repeatStatement","localStatement","variables","init","assignmentStatement","callStatement","expression","functionStatement","identifier","parameters","isLocal","forNumericStatement","variable","start","end","step","forGenericStatement","iterators","chunk","name","literal","value","raw","tableKey","key","tableKeyString","tableValue","tableConstructorExpression","fields","binaryExpression","operator","left","right","unaryExpression","argument","memberExpression","base","indexer","indexExpression","index","callExpression","tableCallExpression","stringCallExpression","comment","finishNode","node","trackLocations","location","pop","complete","loc","range","token","previousToken","lookahead","tokenStart","line","lineStart","scopes","scopeDepth","globals","slice","Array","prototype","indexOf","Object","toString","array","element","i","sprintf","format","call","replace","match","raise","error","col","message","apply","SyntaxError","column","raiseUnexpectedToken","found","near","lex","skipWhiteSpace","charCodeAt","scanComment","string","charCode","next","isIdentifierStart","id","isKeyword","scanIdentifierOrKeyword","delimiter","stringStart","readEscapeSequence","isLineTerminator","String","fromCharCode","scanStringLiteral","scanNumericLiteral","isDecDigit","scanPunctuator","readLongString","charAt","isWhiteSpace","character","digit","fractionStart","exponentStart","digitStart","fraction","binaryExponent","binarySign","isHexDigit","parseInt","Math","pow","readHexLiteral","parseFloat","readDecLiteral","sequenceStart","content","isLong","commentStart","lineStartComment","lineComment","push","level","terminator","consume","expect","isBlockFollow","scopeIdentifierName","scopeIdentifier","attachScope","property","indexOfObject","scopeHasName","createLocationMarker","Marker","this","markLocation","pushLocation","marker","parseBlock","statement","block","parseStatement","parseIdentifier","parseExpectedExpression","l","parseFunctionDeclaration","parseLocalStatement","parseIfStatement","expressions","parseExpression","parseReturnStatement","parseFunctionName","parseWhileStatement","parseForStatement","parseRepeatStatement","isLabel","parseGotoStatement","parseLabelStatement","previous","parsePrefixExpression","exp","isCallExpression","parseAssignmentOrCallStatement","parameter","parsePrimaryExpression","parseTableConstructor","parseSubExpression","minPrecedence","precedence","isUnary","binaryPrecedence","parseCallExpression","table","literals","write","_input","parseChunk","Error","parse","_options","undefined","src","prop","dest","hasOwnProperty","extend","factory"],"mappings":"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","file":"../../../mode/lua/luaparse.js","sourcesContent":["define(function(require, exports, module) {\r\n/*global exports:true module:true require:true define:true global:true */\r\n\r\n(function (root, name, factory) {\r\n   factory(exports)\r\n}(this, 'luaparse', function (exports) {\r\n  'use strict';\r\n\r\n  exports.version = '0.1.4';\r\n\r\n  var input, options, length;\r\n\r\n  // Options can be set either globally on the parser object through\r\n  // defaultOptions, or during the parse call.\r\n  var defaultOptions = exports.defaultOptions = {\r\n    // Explicitly tell the parser when the input ends.\r\n      wait: false\r\n    // Store comments as an array in the chunk object.\r\n    , comments: true\r\n    // Track identifier scopes by adding an isLocal attribute to each\r\n    // identifier-node.\r\n    , scope: false\r\n    // Store location information on each syntax node as\r\n    // `loc: { start: { line, column }, end: { line, column } }`.\r\n    , locations: false\r\n    // Store the start and end character locations on each syntax node as\r\n    // `range: [start, end]`.\r\n    , ranges: false\r\n  };\r\n\r\n  // The available tokens expressed as enum flags so they can be checked with\r\n  // bitwise operations.\r\n\r\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\r\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\r\n    , NilLiteral = 128, VarargLiteral = 256;\r\n\r\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\r\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\r\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\r\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\r\n  };\r\n\r\n  // As this parser is a bit different from luas own, the error messages\r\n  // will be different in some situations.\r\n\r\n  var errors = exports.errors = {\r\n      unexpected: 'Unexpected %1 \\'%2\\' near \\'%3\\''\r\n    , expected: '\\'%1\\' expected near \\'%2\\''\r\n    , expectedToken: '%1 expected near \\'%2\\''\r\n    , unfinishedString: 'unfinished string near \\'%1\\''\r\n    , malformedNumber: 'malformed number near \\'%1\\''\r\n  };\r\n\r\n  // ### Abstract Syntax Tree\r\n  //\r\n  // The default AST structure is inspired by the Mozilla Parser API but can\r\n  // easily be customized by overriding these functions.\r\n\r\n  var ast = exports.ast = {\r\n      labelStatement: function(label) {\r\n      return {\r\n          type: 'LabelStatement'\r\n        , label: label\r\n      };\r\n    }\r\n\r\n    , breakStatement: function() {\r\n      return {\r\n          type: 'BreakStatement'\r\n      };\r\n    }\r\n\r\n    , gotoStatement: function(label) {\r\n      return {\r\n          type: 'GotoStatement'\r\n        , label: label\r\n      };\r\n    }\r\n\r\n    , returnStatement: function(args) {\r\n      return {\r\n          type: 'ReturnStatement'\r\n        , 'arguments': args\r\n      };\r\n    }\r\n\r\n    , ifStatement: function(clauses) {\r\n      return {\r\n          type: 'IfStatement'\r\n        , clauses: clauses\r\n      };\r\n    }\r\n    , ifClause: function(condition, body) {\r\n      return {\r\n          type: 'IfClause'\r\n        , condition: condition\r\n        , body: body\r\n      };\r\n    }\r\n    , elseifClause: function(condition, body) {\r\n      return {\r\n          type: 'ElseifClause'\r\n        , condition: condition\r\n        , body: body\r\n      };\r\n    }\r\n    , elseClause: function(body) {\r\n      return {\r\n          type: 'ElseClause'\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , whileStatement: function(condition, body) {\r\n      return {\r\n          type: 'WhileStatement'\r\n        , condition: condition\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , doStatement: function(body) {\r\n      return {\r\n          type: 'DoStatement'\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , repeatStatement: function(condition, body) {\r\n      return {\r\n          type: 'RepeatStatement'\r\n        , condition: condition\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , localStatement: function(variables, init) {\r\n      return {\r\n          type: 'LocalStatement'\r\n        , variables: variables\r\n        , init: init\r\n      };\r\n    }\r\n\r\n    , assignmentStatement: function(variables, init) {\r\n      return {\r\n          type: 'AssignmentStatement'\r\n        , variables: variables\r\n        , init: init\r\n      };\r\n    }\r\n\r\n    , callStatement: function(expression) {\r\n      return {\r\n          type: 'CallStatement'\r\n        , expression: expression\r\n      };\r\n    }\r\n\r\n    , functionStatement: function(identifier, parameters, isLocal, body) {\r\n      return {\r\n          type: 'FunctionDeclaration'\r\n        , identifier: identifier\r\n        , isLocal: isLocal\r\n        , parameters: parameters\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , forNumericStatement: function(variable, start, end, step, body) {\r\n      return {\r\n          type: 'ForNumericStatement'\r\n        , variable: variable\r\n        , start: start\r\n        , end: end\r\n        , step: step\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , forGenericStatement: function(variables, iterators, body) {\r\n      return {\r\n          type: 'ForGenericStatement'\r\n        , variables: variables\r\n        , iterators: iterators\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , chunk: function(body) {\r\n      return {\r\n          type: 'Chunk'\r\n        , body: body\r\n      };\r\n    }\r\n\r\n    , identifier: function(name) {\r\n      return {\r\n          type: 'Identifier'\r\n        , name: name\r\n      };\r\n    }\r\n\r\n    , literal: function(type, value, raw) {\r\n      type = (type === StringLiteral) ? 'StringLiteral'\r\n        : (type === NumericLiteral) ? 'NumericLiteral'\r\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\r\n        : (type === NilLiteral) ? 'NilLiteral'\r\n        : 'VarargLiteral';\r\n\r\n      return {\r\n          type: type\r\n        , value: value\r\n        , raw: raw\r\n      };\r\n    }\r\n\r\n    , tableKey: function(key, value) {\r\n      return {\r\n          type: 'TableKey'\r\n        , key: key\r\n        , value: value\r\n      };\r\n    }\r\n    , tableKeyString: function(key, value) {\r\n      return {\r\n          type: 'TableKeyString'\r\n        , key: key\r\n        , value: value\r\n      };\r\n    }\r\n    , tableValue: function(value) {\r\n      return {\r\n          type: 'TableValue'\r\n        , value: value\r\n      };\r\n    }\r\n\r\n\r\n    , tableConstructorExpression: function(fields) {\r\n      return {\r\n          type: 'TableConstructorExpression'\r\n        , fields: fields\r\n      };\r\n    }\r\n    , binaryExpression: function(operator, left, right) {\r\n      var type = ('and' === operator || 'or' === operator) ?\r\n        'LogicalExpression' :\r\n        'BinaryExpression';\r\n\r\n      return {\r\n          type: type\r\n        , operator: operator\r\n        , left: left\r\n        , right: right\r\n      };\r\n    }\r\n    , unaryExpression: function(operator, argument) {\r\n      return {\r\n          type: 'UnaryExpression'\r\n        , operator: operator\r\n        , argument: argument\r\n      };\r\n    }\r\n    , memberExpression: function(base, indexer, identifier) {\r\n      return {\r\n          type: 'MemberExpression'\r\n        , indexer: indexer\r\n        , identifier: identifier\r\n        , base: base\r\n      };\r\n    }\r\n\r\n    , indexExpression: function(base, index) {\r\n      return {\r\n          type: 'IndexExpression'\r\n        , base: base\r\n        , index: index\r\n      };\r\n    }\r\n\r\n    , callExpression: function(base, args) {\r\n      return {\r\n          type: 'CallExpression'\r\n        , base: base\r\n        , 'arguments': args\r\n      };\r\n    }\r\n\r\n    , tableCallExpression: function(base, args) {\r\n      return {\r\n          type: 'TableCallExpression'\r\n        , base: base\r\n        , 'arguments': args\r\n      };\r\n    }\r\n\r\n    , stringCallExpression: function(base, argument) {\r\n      return {\r\n          type: 'StringCallExpression'\r\n        , base: base\r\n        , argument: argument\r\n      };\r\n    }\r\n\r\n    , comment: function(value, raw) {\r\n      return {\r\n          type: 'Comment'\r\n        , value: value\r\n        , raw: raw\r\n      };\r\n    }\r\n  };\r\n\r\n  // Wrap up the node object.\r\n\r\n  function finishNode(node) {\r\n    // Pop a `Marker` off the location-array and attach its location data.\r\n    if (trackLocations) {\r\n      var location = locations.pop();\r\n      location.complete();\r\n      if (options.locations) node.loc = location.loc;\r\n      if (options.ranges) node.range = location.range;\r\n    }\r\n    return node;\r\n  }\r\n\r\n\r\n\r\n  // Helpers\r\n  // -------\r\n\r\n  var slice = Array.prototype.slice\r\n    , toString = Object.prototype.toString\r\n    , indexOf = function indexOf(array, element) {\r\n      for (var i = 0, length = array.length; i < length; i++) {\r\n        if (array[i] === element) return i;\r\n      }\r\n      return -1;\r\n    };\r\n\r\n  // Iterate through an array of objects and return the index of an object\r\n  // with a matching property.\r\n\r\n  function indexOfObject(array, property, element) {\r\n    for (var i = 0, length = array.length; i < length; i++) {\r\n      if (array[i][property] === element) return i;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  // A sprintf implementation using %index (beginning at 1) to input\r\n  // arguments in the format string.\r\n  //\r\n  // Example:\r\n  //\r\n  //     // Unexpected function in token\r\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\r\n\r\n  function sprintf(format) {\r\n    var args = slice.call(arguments, 1);\r\n    format = format.replace(/%(\\d)/g, function (match, index) {\r\n      return '' + args[index - 1] || '';\r\n    });\r\n    return format;\r\n  }\r\n\r\n  // Returns a new object with the properties from all objectes passed as\r\n  // arguments. Last argument takes precedence.\r\n  //\r\n  // Example:\r\n  //\r\n  //     this.options = extend(options, { output: false });\r\n\r\n  function extend() {\r\n    var args = slice.call(arguments)\r\n      , dest = {}\r\n      , src, prop;\r\n\r\n    for (var i = 0, length = args.length; i < length; i++) {\r\n      src = args[i];\r\n      for (prop in src) if (src.hasOwnProperty(prop)) {\r\n        dest[prop] = src[prop];\r\n      }\r\n    }\r\n    return dest;\r\n  }\r\n\r\n  // ### Error functions\r\n\r\n  // #### Raise an exception.\r\n  //\r\n  // Raise an exception by passing a token, a string format and its paramters.\r\n  //\r\n  // The passed tokens location will automatically be added to the error\r\n  // message if it exists, if not it will default to the lexers current\r\n  // position.\r\n  //\r\n  // Example:\r\n  //\r\n  //     // [1:0] expected [ near (\r\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\r\n\r\n  function raise(token) {\r\n    var message = sprintf.apply(null, slice.call(arguments, 1))\r\n      , error, col;\r\n\r\n    if ('undefined' !== typeof token.line) {\r\n      col = token.range[0] - token.lineStart;\r\n      error = new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message));\r\n      error.line = token.line;\r\n      error.index = token.range[0];\r\n      error.column = col;\r\n    } else {\r\n      col = index - lineStart + 1;\r\n      error = new SyntaxError(sprintf('[%1:%2] %3', line, col, message));\r\n      error.index = index;\r\n      error.line = line;\r\n      error.column = col;\r\n    }\r\n    throw error;\r\n  }\r\n\r\n  // #### Raise an unexpected token error.\r\n  //\r\n  // Example:\r\n  //\r\n  //     // expected <name> near '0'\r\n  //     raiseUnexpectedToken('<name>', token);\r\n\r\n  function raiseUnexpectedToken(type, token) {\r\n    raise(token, errors.expectedToken, type, token.value);\r\n  }\r\n\r\n  // #### Raise a general unexpected error\r\n  //\r\n  // Usage should pass either a token object or a symbol string which was\r\n  // expected. We can also specify a nearby token such as <eof>, this will\r\n  // default to the currently active token.\r\n  //\r\n  // Example:\r\n  //\r\n  //     // Unexpected symbol 'end' near '<eof>'\r\n  //     unexpected(token);\r\n  //\r\n  // If there's no token in the buffer it means we have reached <eof>.\r\n\r\n  function unexpected(found, near) {\r\n    if ('undefined' === typeof near) near = lookahead.value;\r\n    if ('undefined' !== typeof found.type) {\r\n      var type;\r\n      switch (found.type) {\r\n        case StringLiteral:   type = 'string';      break;\r\n        case Keyword:         type = 'keyword';     break;\r\n        case Identifier:      type = 'identifier';  break;\r\n        case NumericLiteral:  type = 'number';      break;\r\n        case Punctuator:      type = 'symbol';      break;\r\n        case BooleanLiteral:  type = 'boolean';     break;\r\n        case NilLiteral:\r\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\r\n      }\r\n      return raise(found, errors.unexpected, type, found.value, near);\r\n    }\r\n    return raise(found, errors.unexpected, 'symbol', found, near);\r\n  }\r\n\r\n  // Lexer\r\n  // -----\r\n  //\r\n  // The lexer, or the tokenizer reads the input string character by character\r\n  // and derives a token left-right. To be as efficient as possible the lexer\r\n  // prioritizes the common cases such as identifiers. It also works with\r\n  // character codes instead of characters as string comparisons was the\r\n  // biggest bottleneck of the parser.\r\n  //\r\n  // If `options.comments` is enabled, all comments encountered will be stored\r\n  // in an array which later will be appended to the chunk object. If disabled,\r\n  // they will simply be disregarded.\r\n  //\r\n  // When the lexer has derived a valid token, it will be returned as an object\r\n  // containing its value and as well as its position in the input string (this\r\n  // is always enabled to provide proper debug messages).\r\n  //\r\n  // `lex()` starts lexing and returns the following token in the stream.\r\n\r\n  var index\r\n    , token\r\n    , previousToken\r\n    , lookahead\r\n    , comments\r\n    , tokenStart\r\n    , line\r\n    , lineStart;\r\n\r\n  exports.lex = lex;\r\n\r\n  function lex() {\r\n    skipWhiteSpace();\r\n\r\n    // Skip comments beginning with --\r\n    while (45 === input.charCodeAt(index) &&\r\n           45 === input.charCodeAt(index + 1)) {\r\n      scanComment();\r\n      skipWhiteSpace();\r\n    }\r\n    if (index >= length) return {\r\n        type : EOF\r\n      , value: '<eof>'\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [index, index]\r\n    };\r\n\r\n    var charCode = input.charCodeAt(index)\r\n      , next = input.charCodeAt(index + 1);\r\n\r\n    // Memorize the range index where the token begins.\r\n    tokenStart = index;\r\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\r\n\r\n    switch (charCode) {\r\n      case 39: case 34: // '\"\r\n        return scanStringLiteral();\r\n\r\n      // 0-9\r\n      case 48: case 49: case 50: case 51: case 52: case 53:\r\n      case 54: case 55: case 56: case 57:\r\n        return scanNumericLiteral();\r\n\r\n      case 46: // .\r\n        // If the dot is followed by a digit it's a float.\r\n        if (isDecDigit(next)) return scanNumericLiteral();\r\n        if (46 === next) {\r\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\r\n          return scanPunctuator('..');\r\n        }\r\n        return scanPunctuator('.');\r\n\r\n      case 61: // =\r\n        if (61 === next) return scanPunctuator('==');\r\n        return scanPunctuator('=');\r\n\r\n      case 62: // >\r\n        if (61 === next) return scanPunctuator('>=');\r\n        return scanPunctuator('>');\r\n\r\n      case 60: // <\r\n        if (61 === next) return scanPunctuator('<=');\r\n        return scanPunctuator('<');\r\n\r\n      case 126: // ~\r\n        if (61 === next) return scanPunctuator('~=');\r\n        return scanPunctuator('~');\r\n\r\n      case 58: // :\r\n        if (58 === next) return scanPunctuator('::');\r\n        return scanPunctuator(':');\r\n\r\n      case 91: // [\r\n        // Check for a multiline string, they begin with [= or [[\r\n        if (91 === next || 61 === next) return scanLongStringLiteral();\r\n        return scanPunctuator('[');\r\n\r\n      // \\* / ^ % , { } ] ( ) ; # - +\r\n      case 42: case 47: case 94: case 37: case 44: case 123: case 125:\r\n      case 93: case 40: case 41: case 59: case 35: case 45: case 43: case 38: case 124:\r\n        return scanPunctuator(input.charAt(index));\r\n    }\r\n\r\n    return unexpected(input.charAt(index));\r\n  }\r\n\r\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\r\n  // tracking the encounted newlines. Newlines are also tracked in all\r\n  // token functions where multiline values are allowed.\r\n\r\n  function skipWhiteSpace() {\r\n    while (index < length) {\r\n      var charCode = input.charCodeAt(index);\r\n      if (isWhiteSpace(charCode)) {\r\n        index++;\r\n      } else if (isLineTerminator(charCode)) {\r\n        line++;\r\n        lineStart = ++index;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\r\n  // simply go through them one by one and defaulting to an identifier if no\r\n  // previous case matched.\r\n\r\n  function scanIdentifierOrKeyword() {\r\n    var value, type;\r\n\r\n    // Slicing the input string is prefered before string concatenation in a\r\n    // loop for performance reasons.\r\n    while (isIdentifierPart(input.charCodeAt(++index)));\r\n    value = input.slice(tokenStart, index);\r\n\r\n    // Decide on the token type and possibly cast the value.\r\n    if (isKeyword(value)) {\r\n      type = Keyword;\r\n    } else if ('true' === value || 'false' === value) {\r\n      type = BooleanLiteral;\r\n      value = ('true' === value);\r\n    } else if ('nil' === value) {\r\n      type = NilLiteral;\r\n      value = null;\r\n    } else {\r\n      type = Identifier;\r\n    }\r\n\r\n    return {\r\n        type: type\r\n      , value: value\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [tokenStart, index]\r\n    };\r\n  }\r\n\r\n  // Once a punctuator reaches this function it should already have been\r\n  // validated so we simply return it as a token.\r\n\r\n  function scanPunctuator(value) {\r\n    index += value.length;\r\n    return {\r\n        type: Punctuator\r\n      , value: value\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [tokenStart, index]\r\n    };\r\n  }\r\n\r\n  // A vararg literal consists of three dots.\r\n\r\n  function scanVarargLiteral() {\r\n    index += 3;\r\n    return {\r\n        type: VarargLiteral\r\n      , value: '...'\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [tokenStart, index]\r\n    };\r\n  }\r\n\r\n  // Find the string literal by matching the delimiter marks used.\r\n\r\n  function scanStringLiteral() {\r\n    var delimiter = input.charCodeAt(index++)\r\n      , stringStart = index\r\n      , string = ''\r\n      , charCode;\r\n\r\n    while (index < length) {\r\n      charCode = input.charCodeAt(index++);\r\n      if (delimiter === charCode) break;\r\n      if (92 === charCode) { // \\\r\n        string += input.slice(stringStart, index - 1) + readEscapeSequence();\r\n        stringStart = index;\r\n      }\r\n      // EOF or `\\n` terminates a string literal. If we haven't found the\r\n      // ending delimiter by now, raise an exception.\r\n      else if (index >= length || isLineTerminator(charCode)) {\r\n        string += input.slice(stringStart, index - 1);\r\n        raise({}, errors.unfinishedString, string + String.fromCharCode(charCode));\r\n      }\r\n    }\r\n    string += input.slice(stringStart, index - 1);\r\n\r\n    return {\r\n        type: StringLiteral\r\n      , value: string\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [tokenStart, index]\r\n    };\r\n  }\r\n\r\n  // Expect a multiline string literal and return it as a regular string\r\n  // literal, if it doesn't validate into a valid multiline string, throw an\r\n  // exception.\r\n\r\n  function scanLongStringLiteral() {\r\n    var string = readLongString();\r\n    // Fail if it's not a multiline literal.\r\n    if (false === string) raise(token, errors.expected, '[', token.value);\r\n\r\n    return {\r\n        type: StringLiteral\r\n      , value: string\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [tokenStart, index]\r\n    };\r\n  }\r\n\r\n  // Numeric literals will be returned as floating-point numbers instead of\r\n  // strings. The raw value should be retrieved from slicing the input string\r\n  // later on in the process.\r\n  //\r\n  // If a hexadecimal number is encountered, it will be converted.\r\n\r\n  function scanNumericLiteral() {\r\n    var character = input.charAt(index)\r\n      , next = input.charAt(index + 1);\r\n\r\n    var value = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\r\n      readHexLiteral() : readDecLiteral();\r\n\r\n    return {\r\n        type: NumericLiteral\r\n      , value: value\r\n      , line: line\r\n      , lineStart: lineStart\r\n      , range: [tokenStart, index]\r\n    };\r\n  }\r\n\r\n  // Lua hexadecimals have an optional fraction part and an optional binary\r\n  // exoponent part. These are not included in JavaScript so we will compute\r\n  // all three parts separately and then sum them up at the end of the function\r\n  // with the following algorithm.\r\n  //\r\n  //     Digit := toDec(digit)\r\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\r\n  //     BinaryExp := 2 ^ binaryExp\r\n  //     Number := ( Digit + Fraction ) * BinaryExp\r\n\r\n  function readHexLiteral() {\r\n    var fraction = 0 // defaults to 0 as it gets summed\r\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\r\n      , binarySign = 1 // positive\r\n      , digit, fractionStart, exponentStart, digitStart;\r\n\r\n    digitStart = index += 2; // Skip 0x part\r\n\r\n    // A minimum of one hex digit is required.\r\n    if (!isHexDigit(input.charCodeAt(index)))\r\n      raise({}, errors.malformedNumber, input.slice(tokenStart, index));\r\n\r\n    while (isHexDigit(input.charCodeAt(index))) index++;\r\n    // Convert the hexadecimal digit to base 10.\r\n    digit = parseInt(input.slice(digitStart, index), 16);\r\n\r\n    // Fraction part i optional.\r\n    if ('.' === input.charAt(index)) {\r\n      fractionStart = ++index;\r\n\r\n      while (isHexDigit(input.charCodeAt(index))) index++;\r\n      fraction = input.slice(fractionStart, index);\r\n\r\n      // Empty fraction parts should default to 0, others should be converted\r\n      // 0.x form so we can use summation at the end.\r\n      fraction = (fractionStart === index) ? 0\r\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\r\n    }\r\n\r\n    // Binary exponents are optional\r\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\r\n      index++;\r\n\r\n      // Sign part is optional and defaults to 1 (positive).\r\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\r\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\r\n\r\n      exponentStart = index;\r\n\r\n      // The binary exponent sign requires a decimal digit.\r\n      if (!isDecDigit(input.charCodeAt(index)))\r\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\r\n\r\n      while (isDecDigit(input.charCodeAt(index))) index++;\r\n      binaryExponent = input.slice(exponentStart, index);\r\n\r\n      // Calculate the binary exponent of the number.\r\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\r\n    }\r\n\r\n    return (digit + fraction) * binaryExponent;\r\n  }\r\n\r\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\r\n  // this we check where the token ends and then parse it with native\r\n  // functions.\r\n\r\n  function readDecLiteral() {\r\n    while (isDecDigit(input.charCodeAt(index))) index++;\r\n    // Fraction part is optional\r\n    if ('.' === input.charAt(index)) {\r\n      index++;\r\n      // Fraction part defaults to 0\r\n      while (isDecDigit(input.charCodeAt(index))) index++;\r\n    }\r\n    // Exponent part is optional.\r\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\r\n      index++;\r\n      // Sign part is optional.\r\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) index++;\r\n      // An exponent is required to contain at least one decimal digit.\r\n      if (!isDecDigit(input.charCodeAt(index)))\r\n        raise({}, errors.malformedNumber, input.slice(tokenStart, index));\r\n\r\n      while (isDecDigit(input.charCodeAt(index))) index++;\r\n    }\r\n\r\n    return parseFloat(input.slice(tokenStart, index));\r\n  }\r\n\r\n\r\n  // Translate escape sequences to the actual characters.\r\n\r\n  function readEscapeSequence() {\r\n    var sequenceStart = index;\r\n    switch (input.charAt(index)) {\r\n      // Lua allow the following escape sequences.\r\n      // We don't escape the bell sequence.\r\n      case 'n': index++; return '\\n';\r\n      case 'r': index++; return '\\r';\r\n      case 't': index++; return '\\t';\r\n      case 'v': index++; return '\\x0B';\r\n      case 'b': index++; return '\\b';\r\n      case 'f': index++; return '\\f';\r\n      // Skips the following span of white-space.\r\n      case 'z': index++; skipWhiteSpace(); return '';\r\n      // Byte representation should for now be returned as is.\r\n      case 'x':\r\n        // \\xXX, where XX is a sequence of exactly two hexadecimal digits\r\n        if (isHexDigit(input.charCodeAt(index + 1)) &&\r\n            isHexDigit(input.charCodeAt(index + 2))) {\r\n          index += 3;\r\n          // Return it as is, without translating the byte.\r\n          return '\\\\' + input.slice(sequenceStart, index);\r\n        }\r\n        return '\\\\' + input.charAt(index++);\r\n      default:\r\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\r\n        if (isDecDigit(input.charCodeAt(index))) {\r\n          while (isDecDigit(input.charCodeAt(++index)));\r\n          return '\\\\' + input.slice(sequenceStart, index);\r\n        }\r\n        // Simply return the \\ as is, it's not escaping any sequence.\r\n        return input.charAt(index++);\r\n    }\r\n  }\r\n\r\n  // Comments begin with -- after which it will be decided if they are\r\n  // multiline comments or not.\r\n  //\r\n  // The multiline functionality works the exact same way as with string\r\n  // literals so we reuse the functionality.\r\n\r\n  function scanComment() {\r\n    tokenStart = index;\r\n    index += 2; // --\r\n\r\n    var character = input.charAt(index)\r\n      , content = ''\r\n      , isLong = false\r\n      , commentStart = index\r\n      , lineStartComment = lineStart\r\n      , lineComment = line;\r\n\r\n    if ('[' === character) {\r\n      content = readLongString();\r\n      // This wasn't a multiline comment after all.\r\n      if (false === content) content = character;\r\n      else isLong = true;\r\n    }\r\n    // Scan until next line as long as it's not a multiline comment.\r\n    if (!isLong) {\r\n      while (index < length) {\r\n        if (isLineTerminator(input.charCodeAt(index))) break;\r\n        index++;\r\n      }\r\n      if (options.comments) content = input.slice(commentStart, index);\r\n    }\r\n\r\n    if (options.comments) {\r\n      var node = ast.comment(content, input.slice(tokenStart, index));\r\n\r\n      // `Marker`s depend on tokens available in the parser and as comments are\r\n      // intercepted in the lexer all location data is set manually.\r\n      if (options.locations) {\r\n        node.loc = {\r\n            start: { line: lineComment, column: tokenStart - lineStartComment }\r\n          , end: { line: line, column: index - lineStart }\r\n        };\r\n      }\r\n      if (options.ranges) {\r\n        node.range = [tokenStart, index];\r\n      }\r\n      comments.push(node);\r\n    }\r\n  }\r\n\r\n  // Read a multiline string by calculating the depth of `=` characters and\r\n  // then appending until an equal depth is found.\r\n\r\n  function readLongString() {\r\n    var level = 0\r\n      , content = ''\r\n      , terminator = false\r\n      , character, stringStart;\r\n\r\n    index++; // [\r\n\r\n    // Calculate the depth of the comment.\r\n    while ('=' === input.charAt(index + level)) level++;\r\n    // Exit, this is not a long string afterall.\r\n    if ('[' !== input.charAt(index + level)) return false;\r\n\r\n    index += level + 1;\r\n\r\n    // If the first character is a newline, ignore it and begin on next line.\r\n    if (isLineTerminator(input.charCodeAt(index))) {\r\n      line++;\r\n      lineStart = index++;\r\n    }\r\n\r\n    stringStart = index;\r\n    while (index < length) {\r\n      character = input.charAt(index++);\r\n\r\n      // We have to keep track of newlines as `skipWhiteSpace()` does not get\r\n      // to scan this part.\r\n      if (isLineTerminator(character.charCodeAt(0))) {\r\n        line++;\r\n        lineStart = index;\r\n      }\r\n\r\n      // Once the delimiter is found, iterate through the depth count and see\r\n      // if it matches.\r\n      if (']' === character) {\r\n        terminator = true;\r\n        for (var i = 0; i < level; i++) {\r\n          if ('=' !== input.charAt(index + i)) terminator = false;\r\n        }\r\n        if (']' !== input.charAt(index + level)) terminator = false;\r\n      }\r\n\r\n      // We reached the end of the multiline string. Get out now.\r\n      if (terminator) break;\r\n    }\r\n    content += input.slice(stringStart, index - 1);\r\n    index += level + 1;\r\n\r\n    return content;\r\n  }\r\n\r\n  // ## Lex functions and helpers.\r\n\r\n  // Read the next token.\r\n  //\r\n  // This is actually done by setting the current token to the lookahead and\r\n  // reading in the new lookahead token.\r\n\r\n  function next() {\r\n    previousToken = token;\r\n    token = lookahead;\r\n    lookahead = lex();\r\n  }\r\n\r\n  // Consume a token if its value matches. Once consumed or not, return the\r\n  // success of the operation.\r\n\r\n  function consume(value) {\r\n    if (value === token.value) {\r\n      next();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Expect the next token value to match. If not, throw an exception.\r\n\r\n  function expect(value) {\r\n    if (value === token.value) next();\r\n    else raise(token, errors.expected, value, token.value);\r\n  }\r\n\r\n  // ### Validation functions\r\n\r\n  function isWhiteSpace(charCode) {\r\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\r\n  }\r\n\r\n  function isLineTerminator(charCode) {\r\n    return 10 === charCode || 13 === charCode;\r\n  }\r\n\r\n  function isDecDigit(charCode) {\r\n    return charCode >= 48 && charCode <= 57;\r\n  }\r\n\r\n  function isHexDigit(charCode) {\r\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\r\n  }\r\n\r\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\r\n  // identifiers cannot use locale-dependet letters.\r\n\r\n  function isIdentifierStart(charCode) {\r\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode;\r\n  }\r\n\r\n  function isIdentifierPart(charCode) {\r\n    return (charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57);\r\n  }\r\n\r\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\r\n  //\r\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\r\n\r\n  function isKeyword(id) {\r\n    switch (id.length) {\r\n      case 2:\r\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\r\n      case 3:\r\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\r\n      case 4:\r\n        return 'else' === id || 'goto' === id || 'then' === id;\r\n      case 5:\r\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\r\n      case 6:\r\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\r\n      case 8:\r\n        return 'function' === id;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function isUnary(token) {\r\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\r\n    if (Keyword === token.type) return 'not' === token.value;\r\n    return false;\r\n  }\r\n\r\n  // @TODO this needs to be rethought.\r\n  function isCallExpression(expression) {\r\n    switch (expression.type) {\r\n      case 'CallExpression':\r\n      case 'TableCallExpression':\r\n      case 'StringCallExpression':\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Check if the token syntactically closes a block.\r\n\r\n  function isBlockFollow(token) {\r\n    if (EOF === token.type) return true;\r\n    if (Keyword !== token.type) return false;\r\n    switch (token.value) {\r\n      case 'else': case 'elseif':\r\n      case 'end': case 'until':\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  // Scope\r\n  // -----\r\n\r\n  // Store each block scope as a an array of identifier names. Each scope is\r\n  // stored in an FILO-array.\r\n  var scopes\r\n    // The current scope index\r\n    , scopeDepth\r\n    // A list of all global identifier nodes.\r\n    , globals;\r\n\r\n  // Create a new scope inheriting all declarations from the previous scope.\r\n  function createScope() {\r\n    scopes.push(Array.apply(null, scopes[scopeDepth++]));\r\n  }\r\n\r\n  // Exit and remove the current scope.\r\n  function exitScope() {\r\n    scopes.pop();\r\n    scopeDepth--;\r\n  }\r\n\r\n  // Add identifier name to the current scope if it doesnt already exist.\r\n  function scopeIdentifierName(name) {\r\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\r\n    scopes[scopeDepth].push(name);\r\n  }\r\n\r\n  // Add identifier to the current scope\r\n  function scopeIdentifier(node) {\r\n    scopeIdentifierName(node.name);\r\n    attachScope(node, true);\r\n  }\r\n\r\n  // Attach scope information to node. If the node is global, store it in the\r\n  // globals array so we can return the information to the user.\r\n  function attachScope(node, isLocal) {\r\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\r\n      globals.push(node);\r\n\r\n    node.isLocal = isLocal;\r\n  }\r\n\r\n  // Is the identifier name available in this scope.\r\n  function scopeHasName(name) {\r\n    return (-1 !== indexOf(scopes[scopeDepth], name));\r\n  }\r\n\r\n  // Location tracking\r\n  // -----------------\r\n  //\r\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\r\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\r\n  // location is added and the data is attached to a syntax node.\r\n\r\n  var locations = []\r\n    , trackLocations;\r\n\r\n  function createLocationMarker() {\r\n    return new Marker(token);\r\n  }\r\n\r\n  function Marker(token) {\r\n    if (options.locations) {\r\n      this.loc = {\r\n          start: {\r\n            line: token.line\r\n          , column: token.range[0] - token.lineStart\r\n        }\r\n        , end: {\r\n            line: 0\r\n          , column: 0\r\n        }\r\n      };\r\n    }\r\n    if (options.ranges) this.range = [token.range[0], 0];\r\n  }\r\n\r\n  // Complete the location data stored in the `Marker` by adding the location\r\n  // of the *previous token* as an end location.\r\n  Marker.prototype.complete = function() {\r\n    if (options.locations) {\r\n      this.loc.end.line = previousToken.line;\r\n      this.loc.end.column = previousToken.range[1] - previousToken.lineStart;\r\n    }\r\n    if (options.ranges) {\r\n      this.range[1] = previousToken.range[1];\r\n    }\r\n  };\r\n\r\n  // Create a new `Marker` and add it to the FILO-array.\r\n  function markLocation() {\r\n    if (trackLocations) locations.push(createLocationMarker());\r\n  }\r\n\r\n  // Push an arbitrary `Marker` object onto the FILO-array.\r\n  function pushLocation(marker) {\r\n    if (trackLocations) locations.push(marker);\r\n  }\r\n\r\n  // Parse functions\r\n  // ---------------\r\n\r\n  // Chunk is the main program object. Syntactically it's the same as a block.\r\n  //\r\n  //     chunk ::= block\r\n\r\n  function parseChunk() {\r\n    next();\r\n    markLocation();\r\n    var body = parseBlock();\r\n    if (EOF !== token.type) unexpected(token);\r\n    // If the body is empty no previousToken exists when finishNode runs.\r\n    if (trackLocations && !body.length) previousToken = token;\r\n    return finishNode(ast.chunk(body));\r\n  }\r\n\r\n  // A block contains a list of statements with an optional return statement\r\n  // as its last statement.\r\n  //\r\n  //     block ::= {stat} [retstat]\r\n\r\n  function parseBlock(terminator) {\r\n    var block = []\r\n      , statement;\r\n\r\n    // Each block creates a new scope.\r\n    if (options.scope) createScope();\r\n\r\n    while (!isBlockFollow(token)) {\r\n      // Return has to be the last statement in a block.\r\n      if ('return' === token.value) {\r\n        block.push(parseStatement());\r\n        break;\r\n      }\r\n      statement = parseStatement();\r\n      // Statements are only added if they are returned, this allows us to\r\n      // ignore some statements, such as EmptyStatement.\r\n      if (statement) block.push(statement);\r\n    }\r\n\r\n    if (options.scope) exitScope();\r\n    // Doesn't really need an ast node\r\n    return block;\r\n  }\r\n\r\n  // There are two types of statements, simple and compound.\r\n  //\r\n  //     statement ::= break | goto | do | while | repeat | return\r\n  //          | if | for | function | local | label | assignment\r\n  //          | functioncall | ';'\r\n\r\n  function parseStatement() {\r\n    markLocation();\r\n    if (Keyword === token.type) {\r\n      switch (token.value) {\r\n        case 'local':    next(); return parseLocalStatement();\r\n        case 'if':       next(); return parseIfStatement();\r\n        case 'return':   next(); return parseReturnStatement();\r\n        case 'function': next();\r\n          var name = parseFunctionName();\r\n          return parseFunctionDeclaration(name);\r\n        case 'while':    next(); return parseWhileStatement();\r\n        case 'for':      next(); return parseForStatement();\r\n        case 'repeat':   next(); return parseRepeatStatement();\r\n        case 'break':    next(); return parseBreakStatement();\r\n        case 'do':       next(); return parseDoStatement();\r\n        case 'goto':     next(); return parseGotoStatement();\r\n      }\r\n    }\r\n\r\n    if (Punctuator === token.type) {\r\n      if (consume('::')) return parseLabelStatement();\r\n    }\r\n    // Assignments memorizes the location and pushes it manually for wrapper\r\n    // nodes. Additionally empty `;` statements should not mark a location.\r\n    if (trackLocations) locations.pop();\r\n\r\n    // When a `;` is encounted, simply eat it without storing it.\r\n    if (consume(';')) return;\r\n\r\n    return parseAssignmentOrCallStatement();\r\n  }\r\n\r\n  // ## Statements\r\n\r\n  //     label ::= '::' Name '::'\r\n\r\n  function parseLabelStatement() {\r\n    var name = token.value\r\n      , label = parseIdentifier();\r\n\r\n    if (options.scope) {\r\n      scopeIdentifierName('::' + name + '::');\r\n      attachScope(label, true);\r\n    }\r\n\r\n    expect('::');\r\n    return finishNode(ast.labelStatement(label));\r\n  }\r\n\r\n  //     break ::= 'break'\r\n\r\n  function parseBreakStatement() {\r\n    return finishNode(ast.breakStatement());\r\n  }\r\n\r\n  //     goto ::= 'goto' Name\r\n\r\n  function parseGotoStatement() {\r\n    var name = token.value\r\n      , label = parseIdentifier();\r\n\r\n    if (options.scope) label.isLabel = scopeHasName('::' + name + '::');\r\n    return finishNode(ast.gotoStatement(label));\r\n  }\r\n\r\n  //     do ::= 'do' block 'end'\r\n\r\n  function parseDoStatement() {\r\n    var body = parseBlock();\r\n    expect('end');\r\n    return finishNode(ast.doStatement(body));\r\n  }\r\n\r\n  //     while ::= 'while' exp 'do' block 'end'\r\n\r\n  function parseWhileStatement() {\r\n    var condition = parseExpectedExpression();\r\n    expect('do');\r\n    var body = parseBlock();\r\n    expect('end');\r\n    return finishNode(ast.whileStatement(condition, body));\r\n  }\r\n\r\n  //     repeat ::= 'repeat' block 'until' exp\r\n\r\n  function parseRepeatStatement() {\r\n    var body = parseBlock();\r\n    expect('until');\r\n    var condition = parseExpectedExpression();\r\n    return finishNode(ast.repeatStatement(condition, body));\r\n  }\r\n\r\n  //     retstat ::= 'return' [exp {',' exp}] [';']\r\n\r\n  function parseReturnStatement() {\r\n    var expressions = [];\r\n\r\n    if ('end' !== token.value) {\r\n      var expression = parseExpression();\r\n      if (null != expression) expressions.push(expression);\r\n      while (consume(',')) {\r\n        expression = parseExpectedExpression();\r\n        expressions.push(expression);\r\n      }\r\n      consume(';'); // grammar tells us ; is optional here.\r\n    }\r\n    return finishNode(ast.returnStatement(expressions));\r\n  }\r\n\r\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\r\n  //     elif ::= 'elseif' exp 'then' block\r\n\r\n  function parseIfStatement() {\r\n    var clauses = []\r\n      , condition\r\n      , body\r\n      , marker;\r\n\r\n    // IfClauses begin at the same location as the parent IfStatement.\r\n    // It ends at the start of `end`, `else`, or `elseif`.\r\n    if (trackLocations) {\r\n      marker = locations[locations.length - 1];\r\n      locations.push(marker);\r\n    }\r\n    condition = parseExpectedExpression();\r\n    expect('then');\r\n    body = parseBlock();\r\n    clauses.push(finishNode(ast.ifClause(condition, body)));\r\n\r\n    if (trackLocations) marker = createLocationMarker();\r\n    while (consume('elseif')) {\r\n      pushLocation(marker);\r\n      condition = parseExpectedExpression();\r\n      expect('then');\r\n      body = parseBlock();\r\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\r\n      if (trackLocations) marker = createLocationMarker();\r\n    }\r\n\r\n    if (consume('else')) {\r\n      // Include the `else` in the location of ElseClause.\r\n      if (trackLocations) {\r\n        marker = new Marker(previousToken);\r\n        locations.push(marker);\r\n      }\r\n      body = parseBlock();\r\n      clauses.push(finishNode(ast.elseClause(body)));\r\n    }\r\n\r\n    expect('end');\r\n    return finishNode(ast.ifStatement(clauses));\r\n  }\r\n\r\n  // There are two types of for statements, generic and numeric.\r\n  //\r\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\r\n  //     for ::= namelist 'in' explist 'do' block 'end'\r\n  //     namelist ::= Name {',' Name}\r\n  //     explist ::= exp {',' exp}\r\n\r\n  function parseForStatement() {\r\n    var variable = parseIdentifier()\r\n      , body;\r\n\r\n    // The start-identifier is local.\r\n    if (options.scope) scopeIdentifier(variable);\r\n\r\n    // If the first expression is followed by a `=` punctuator, this is a\r\n    // Numeric For Statement.\r\n    if (consume('=')) {\r\n      // Start expression\r\n      var start = parseExpectedExpression();\r\n      expect(',');\r\n      // End expression\r\n      var end = parseExpectedExpression();\r\n      // Optional step expression\r\n      var step = consume(',') ? parseExpectedExpression() : null;\r\n\r\n      expect('do');\r\n      body = parseBlock();\r\n      expect('end');\r\n\r\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\r\n    }\r\n    // If not, it's a Generic For Statement\r\n    else {\r\n      // The namelist can contain one or more identifiers.\r\n      var variables = [variable];\r\n      while (consume(',')) {\r\n        variable = parseIdentifier();\r\n        // Each variable in the namelist is locally scoped.\r\n        if (options.scope) scopeIdentifier(variable);\r\n        variables.push(variable);\r\n      }\r\n      expect('in');\r\n      var iterators = [];\r\n\r\n      // One or more expressions in the explist.\r\n      do {\r\n        var expression = parseExpectedExpression();\r\n        iterators.push(expression);\r\n      } while (consume(','));\r\n\r\n      expect('do');\r\n      body = parseBlock();\r\n      expect('end');\r\n\r\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\r\n    }\r\n  }\r\n\r\n  // Local statements can either be variable assignments or function\r\n  // definitions. If a function definition is found, it will be delegated to\r\n  // `parseFunctionDeclaration()` with the isLocal flag.\r\n  //\r\n  // This AST structure might change into a local assignment with a function\r\n  // child.\r\n  //\r\n  //     local ::= 'local' 'function' Name funcdecl\r\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}\r\n\r\n  function parseLocalStatement() {\r\n    var name;\r\n\r\n    if (Identifier === token.type) {\r\n      var variables = []\r\n        , init = [];\r\n\r\n      do {\r\n        name = parseIdentifier();\r\n\r\n        variables.push(name);\r\n      } while (consume(','));\r\n\r\n      if (consume('=')) {\r\n        do {\r\n          var expression = parseExpectedExpression();\r\n          init.push(expression);\r\n        } while (consume(','));\r\n      }\r\n\r\n      // Declarations doesn't exist before the statement has been evaluated.\r\n      // Therefore assignments can't use their declarator. And the identifiers\r\n      // shouldn't be added to the scope until the statement is complete.\r\n      if (options.scope) {\r\n        for (var i = 0, l = variables.length; i < l; i++) {\r\n          scopeIdentifier(variables[i]);\r\n        }\r\n      }\r\n\r\n      return finishNode(ast.localStatement(variables, init));\r\n    }\r\n    if (consume('function')) {\r\n      name = parseIdentifier();\r\n      if (options.scope) scopeIdentifier(name);\r\n\r\n      // MemberExpressions are not allowed in local function statements.\r\n      return parseFunctionDeclaration(name, true);\r\n    } else {\r\n      raiseUnexpectedToken('<name>', token);\r\n    }\r\n  }\r\n\r\n  //     assignment ::= varlist '=' explist\r\n  //     varlist ::= prefixexp {',' prefixexp}\r\n  //     explist ::= exp {',' exp}\r\n  //\r\n  //     call ::= callexp\r\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\r\n\r\n  function parseAssignmentOrCallStatement() {\r\n    // Keep a reference to the previous token for better error messages in case\r\n    // of invalid statement\r\n    var previous = token\r\n      , expression, marker;\r\n\r\n    if (trackLocations) marker = createLocationMarker();\r\n    expression = parsePrefixExpression();\r\n\r\n    if (null == expression) return unexpected(token);\r\n    if (',='.indexOf(token.value) >= 0) {\r\n      var variables = [expression]\r\n        , init = []\r\n        , exp;\r\n\r\n      while (consume(',')) {\r\n        exp = parsePrefixExpression();\r\n        if (null == exp) raiseUnexpectedToken('<expression>', token);\r\n        variables.push(exp);\r\n      }\r\n      expect('=');\r\n      do {\r\n        exp = parseExpectedExpression();\r\n        init.push(exp);\r\n      } while (consume(','));\r\n\r\n      pushLocation(marker);\r\n      return finishNode(ast.assignmentStatement(variables, init));\r\n    }\r\n    if (isCallExpression(expression)) {\r\n      pushLocation(marker);\r\n      return finishNode(ast.callStatement(expression));\r\n    }\r\n    // The prefix expression was neither part of an assignment or a\r\n    // callstatement, however as it was valid it's been consumed, so raise\r\n    // the exception on the previous token to provide a helpful message.\r\n    return unexpected(previous);\r\n  }\r\n\r\n\r\n\r\n  // ### Non-statements\r\n\r\n  //     Identifier ::= Name\r\n\r\n  function parseIdentifier() {\r\n    markLocation();\r\n    var identifier = token.value;\r\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\r\n    next();\r\n    return finishNode(ast.identifier(identifier));\r\n  }\r\n\r\n  // Parse the functions parameters and body block. The name should already\r\n  // have been parsed and passed to this declaration function. By separating\r\n  // this we allow for anonymous functions in expressions.\r\n  //\r\n  // For local functions there's a boolean parameter which needs to be set\r\n  // when parsing the declaration.\r\n  //\r\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\r\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\r\n\r\n  function parseFunctionDeclaration(name, isLocal) {\r\n    var parameters = [];\r\n    expect('(');\r\n\r\n    // The declaration has arguments\r\n    if (!consume(')')) {\r\n      // Arguments are a comma separated list of identifiers, optionally ending\r\n      // with a vararg.\r\n      while (true) {\r\n        if (Identifier === token.type) {\r\n          var parameter = parseIdentifier();\r\n          // Function parameters are local.\r\n          if (options.scope) scopeIdentifier(parameter);\r\n\r\n          parameters.push(parameter);\r\n\r\n          if (consume(',')) continue;\r\n          else if (consume(')')) break;\r\n        }\r\n        // No arguments are allowed after a vararg.\r\n        else if (VarargLiteral === token.type) {\r\n          parameters.push(parsePrimaryExpression());\r\n          expect(')');\r\n          break;\r\n        } else {\r\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\r\n        }\r\n      }\r\n    }\r\n\r\n    var body = parseBlock();\r\n    expect('end');\r\n\r\n    isLocal = isLocal || false;\r\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\r\n  }\r\n\r\n  // Parse the function name as identifiers and member expressions.\r\n  //\r\n  //     Name {'.' Name} [':' Name]\r\n\r\n  function parseFunctionName() {\r\n    var base, name, marker;\r\n\r\n    if (trackLocations) marker = createLocationMarker();\r\n    base = parseIdentifier();\r\n\r\n    if (options.scope) attachScope(base, false);\r\n\r\n    while (consume('.')) {\r\n      pushLocation(marker);\r\n      name = parseIdentifier();\r\n      if (options.scope) attachScope(name, false);\r\n      base = finishNode(ast.memberExpression(base, '.', name));\r\n    }\r\n\r\n    if (consume(':')) {\r\n      pushLocation(marker);\r\n      name = parseIdentifier();\r\n      if (options.scope) attachScope(name, false);\r\n      base = finishNode(ast.memberExpression(base, ':', name));\r\n    }\r\n\r\n    return base;\r\n  }\r\n\r\n  //     tableconstructor ::= '{' [fieldlist] '}'\r\n  //     fieldlist ::= field {fieldsep field} fieldsep\r\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\r\n  //\r\n  //     fieldsep ::= ',' | ';'\r\n\r\n  function parseTableConstructor() {\r\n    var fields = []\r\n      , key, value;\r\n\r\n    while (true) {\r\n      markLocation();\r\n      if (Punctuator === token.type && consume('[')) {\r\n        key = parseExpectedExpression();\r\n        expect(']');\r\n        expect('=');\r\n        value = parseExpectedExpression();\r\n        fields.push(finishNode(ast.tableKey(key, value)));\r\n      } else if (Identifier === token.type) {\r\n        key = parseExpectedExpression();\r\n        if (consume('=')) {\r\n          value = parseExpectedExpression();\r\n          fields.push(finishNode(ast.tableKeyString(key, value)));\r\n        } else {\r\n          fields.push(finishNode(ast.tableValue(key)));\r\n        }\r\n      } else {\r\n        if (null == (value = parseExpression())) {\r\n          locations.pop();\r\n          break;\r\n        }\r\n        fields.push(finishNode(ast.tableValue(value)));\r\n      }\r\n      if (',;'.indexOf(token.value) >= 0) {\r\n        next();\r\n        continue;\r\n      }\r\n      if ('}' === token.value) break;\r\n    }\r\n    expect('}');\r\n    return finishNode(ast.tableConstructorExpression(fields));\r\n  }\r\n\r\n  // Expression parser\r\n  // -----------------\r\n  //\r\n  // Expressions are evaluated and always return a value. If nothing is\r\n  // matched null will be returned.\r\n  //\r\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\r\n  //\r\n  //     primary ::= nil | false | true | Number | String | '...'\r\n  //          | functiondef | tableconstructor\r\n  //\r\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\r\n  //          | '.' Name | ':' Name args | args }\r\n  //\r\n\r\n  function parseExpression() {\r\n    var expression = parseSubExpression(0);\r\n    return expression;\r\n  }\r\n\r\n  // Parse an expression expecting it to be valid.\r\n\r\n  function parseExpectedExpression() {\r\n    var expression = parseExpression();\r\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\r\n    else return expression;\r\n  }\r\n\r\n\r\n  // Return the precedence priority of the operator.\r\n  //\r\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\r\n  // isn't described in this table but in `parseSubExpression()` itself.\r\n  //\r\n  // As this function gets hit on every expression it's been optimized due to\r\n  // the expensive CompareICStub which took ~8% of the parse time.\r\n\r\n  function binaryPrecedence(operator) {\r\n    var charCode = operator.charCodeAt(0)\r\n      , length = operator.length;\r\n\r\n    if (1 === length) {\r\n      switch (charCode) {\r\n        case 94: return 10; // ^\r\n        case 42: case 47: case 37: return 7; // * / %\r\n        case 43: case 45: return 6; // + -\r\n        case 60: case 62: return 3; // < >\r\n        case 38: case 124: return 7; // & |\r\n      }\r\n    } else if (2 === length) {\r\n      switch (charCode) {\r\n        case 46: return 5; // ..\r\n        case 60: case 62: case 61: case 126: return 3; // <= >= == ~=\r\n        case 111: return 1; // or\r\n      }\r\n    } else if (97 === charCode && 'and' === operator) return 2;\r\n    return 0;\r\n  }\r\n\r\n  // Implement an operator-precedence parser to handle binary operator\r\n  // precedence.\r\n  //\r\n  // We use this algorithm because it's compact, it's fast and Lua core uses\r\n  // the same so we can be sure our expressions are parsed in the same manner\r\n  // without excessive amounts of tests.\r\n  //\r\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\r\n\r\n  function parseSubExpression(minPrecedence) {\r\n    var operator = token.value\r\n    // The left-hand side in binary operations.\r\n      , expression, marker;\r\n\r\n    if (trackLocations) marker = createLocationMarker();\r\n\r\n    // UnaryExpression\r\n    if (isUnary(token)) {\r\n      markLocation();\r\n      next();\r\n      var argument = parseSubExpression(8);\r\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\r\n      expression = finishNode(ast.unaryExpression(operator, argument));\r\n    }\r\n    if (null == expression) {\r\n      // PrimaryExpression\r\n      expression = parsePrimaryExpression();\r\n\r\n      // PrefixExpression\r\n      if (null == expression) {\r\n        expression = parsePrefixExpression();\r\n      }\r\n    }\r\n    // This is not a valid left hand expression.\r\n    if (null == expression) return null;\r\n\r\n    var precedence;\r\n    while (true) {\r\n      operator = token.value;\r\n\r\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\r\n        binaryPrecedence(operator) : 0;\r\n\r\n      if (precedence === 0 || precedence <= minPrecedence) break;\r\n      // Right-hand precedence operators\r\n      if ('^' === operator || '..' === operator) precedence--;\r\n      next();\r\n      var right = parseSubExpression(precedence);\r\n      if (null == right) raiseUnexpectedToken('<expression>', token);\r\n      // Push in the marker created before the loop to wrap its entirety.\r\n      if (trackLocations) locations.push(marker);\r\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\r\n\r\n    }\r\n    return expression;\r\n  }\r\n\r\n  //     prefixexp ::= prefix {suffix}\r\n  //     prefix ::= Name | '(' exp ')'\r\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\r\n  //\r\n  //     args ::= '(' [explist] ')' | tableconstructor | String\r\n\r\n  function parsePrefixExpression() {\r\n    var base, name, marker\r\n      // Keep track of the scope, if a parent is local so are the children.\r\n      , isLocal;\r\n\r\n    if (trackLocations) marker = createLocationMarker();\r\n\r\n    // The prefix\r\n    if (Identifier === token.type) {\r\n      name = token.value;\r\n      base = parseIdentifier();\r\n      // Set the parent scope.\r\n      if (options.scope) attachScope(base, isLocal = scopeHasName(name));\r\n    } else if (consume('(')) {\r\n      base = parseExpectedExpression();\r\n      expect(')');\r\n      if (options.scope) isLocal = base.isLocal;\r\n    } else {\r\n      return null;\r\n    }\r\n\r\n    // The suffix\r\n    var expression, identifier;\r\n    while (true) {\r\n      if (Punctuator === token.type) {\r\n        switch (token.value) {\r\n          case '[':\r\n            pushLocation(marker);\r\n            next();\r\n            expression = parseExpectedExpression();\r\n            base = finishNode(ast.indexExpression(base, expression));\r\n            expect(']');\r\n            break;\r\n          case '.':\r\n            pushLocation(marker);\r\n            next();\r\n            identifier = parseIdentifier();\r\n            // Inherit the scope\r\n            if (options.scope) attachScope(identifier, isLocal);\r\n            base = finishNode(ast.memberExpression(base, '.', identifier));\r\n            break;\r\n          case ':':\r\n            pushLocation(marker);\r\n            next();\r\n            identifier = parseIdentifier();\r\n            if (options.scope) attachScope(identifier, isLocal);\r\n            base = finishNode(ast.memberExpression(base, ':', identifier));\r\n            // Once a : is found, this has to be a CallExpression, otherwise\r\n            // throw an error.\r\n            pushLocation(marker);\r\n            base = parseCallExpression(base);\r\n            break;\r\n          case '(': case '{': // args\r\n            pushLocation(marker);\r\n            base = parseCallExpression(base);\r\n            break;\r\n          default:\r\n            return base;\r\n        }\r\n      } else if (StringLiteral === token.type) {\r\n        pushLocation(marker);\r\n        base = parseCallExpression(base);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return base;\r\n  }\r\n\r\n  //     args ::= '(' [explist] ')' | tableconstructor | String\r\n\r\n  function parseCallExpression(base) {\r\n    if (Punctuator === token.type) {\r\n      switch (token.value) {\r\n        case '(':\r\n          next();\r\n\r\n          // List of expressions\r\n          var expressions = [];\r\n          var expression = parseExpression();\r\n          if (null != expression) expressions.push(expression);\r\n          while (consume(',')) {\r\n            expression = parseExpectedExpression();\r\n            expressions.push(expression);\r\n          }\r\n\r\n          expect(')');\r\n          return finishNode(ast.callExpression(base, expressions));\r\n\r\n        case '{':\r\n          markLocation();\r\n          next();\r\n          var table = parseTableConstructor();\r\n          return finishNode(ast.tableCallExpression(base, table));\r\n      }\r\n    } else if (StringLiteral === token.type) {\r\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression()));\r\n    }\r\n\r\n    raiseUnexpectedToken('function arguments', token);\r\n  }\r\n\r\n  //     primary ::= String | Numeric | nil | true | false\r\n  //          | functiondef | tableconstructor | '...'\r\n\r\n  function parsePrimaryExpression() {\r\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\r\n      , value = token.value\r\n      , type = token.type\r\n      , marker;\r\n\r\n    if (trackLocations) marker = createLocationMarker();\r\n\r\n    if (type & literals) {\r\n      pushLocation(marker);\r\n      var raw = input.slice(token.range[0], token.range[1]);\r\n      next();\r\n      return finishNode(ast.literal(type, value, raw));\r\n    } else if (Keyword === type && 'function' === value) {\r\n      pushLocation(marker);\r\n      next();\r\n      return parseFunctionDeclaration(null);\r\n    } else if (consume('{')) {\r\n      pushLocation(marker);\r\n      return parseTableConstructor();\r\n    }\r\n  }\r\n\r\n  // Parser\r\n  // ------\r\n\r\n  // Export the main parser.\r\n  //\r\n  //   - `wait` Hold parsing until end() is called. Defaults to false\r\n  //   - `comments` Store comments. Defaults to true.\r\n  //   - `scope` Track identifier scope. Defaults to false.\r\n  //\r\n  // Example:\r\n  //\r\n  //     var parser = require('luaparser');\r\n  //     parser.parse('i = 0');\r\n\r\n  exports.parse = parse;\r\n\r\n  function parse(_input, _options) {\r\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\r\n      _options = _input;\r\n      _input = undefined;\r\n    }\r\n    if (!_options) _options = {};\r\n\r\n    input = _input || '';\r\n    options = extend(defaultOptions, _options);\r\n\r\n    // Rewind the lexer\r\n    index = 0;\r\n    line = 1;\r\n    lineStart = 0;\r\n    length = input.length;\r\n    // When tracking identifier scope, initialize with an empty scope.\r\n    scopes = [[]];\r\n    scopeDepth = 0;\r\n    globals = [];\r\n    locations = [];\r\n\r\n    if (options.comments) comments = [];\r\n    if (!options.wait) return end();\r\n    return exports;\r\n  }\r\n\r\n  // Write to the source code buffer without beginning the parse.\r\n  exports.write = write;\r\n\r\n  function write(_input) {\r\n    input += String(_input);\r\n    length = input.length;\r\n    return exports;\r\n  }\r\n\r\n  // Send an EOF and begin parsing.\r\n  exports.end = end;\r\n\r\n  function end(_input) {\r\n    if ('undefined' !== typeof _input) write(_input);\r\n\r\n    length = input.length;\r\n    trackLocations = options.locations || options.ranges;\r\n    // Initialize with a lookahead token.\r\n    lookahead = lex();\r\n\r\n    var chunk = parseChunk();\r\n    if (options.comments) chunk.comments = comments;\r\n    if (options.scope) chunk.globals = globals;\r\n\r\n    if (locations.length > 0)\r\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\r\n\r\n    return chunk;\r\n  }\r\n\r\n}));\r\n/* vim: set sw=2 ts=2 et tw=79 : */\r\n\r\n});\r\n"]}