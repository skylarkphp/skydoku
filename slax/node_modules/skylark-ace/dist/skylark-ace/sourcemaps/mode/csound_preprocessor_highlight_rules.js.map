{"version":3,"sources":["mode/csound_preprocessor_highlight_rules.js"],"names":["define","require","exports","module","oop","TextHighlightRules","CsoundPreprocessorHighlightRules","this","semicolonComments","token","regex","comments","push","next","defaultToken","macroUses","numbers","bracedStringContents","quotedStringContents","start","$rules","define directive","macro parameter name list","macro body","macro directive","macro parameter value list","pushRule","macro parameter value quoted string","macro parameter value parenthetical","popRule","inherits","params","onMatch","value","currentState","stack","line","length","Array","isArray","i","oldNext","oldNextIndex","newNextIndex","charAt","prefix","substr","pop","call","prototype"],"mappings":"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","file":"../../mode/csound_preprocessor_highlight_rules.js","sourcesContent":["define(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../lib/oop\");\r\n\r\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\n\r\nvar CsoundPreprocessorHighlightRules = function() {\r\n\r\n    this.semicolonComments = {\r\n        token : \"comment.line.semicolon.csound\",\r\n        regex : \";.*$\"\r\n    };\r\n\r\n    this.comments = [\r\n        {\r\n            token : \"punctuation.definition.comment.begin.csound\",\r\n            regex : \"/\\\\*\",\r\n            push  : [\r\n                {\r\n                    token : \"punctuation.definition.comment.end.csound\",\r\n                    regex : \"\\\\*/\",\r\n                    next  : \"pop\"\r\n                }, {\r\n                    defaultToken: \"comment.block.csound\"\r\n                }\r\n            ]\r\n        }, {\r\n            token : \"comment.line.double-slash.csound\",\r\n            regex : \"//.*$\"\r\n        },\r\n        this.semicolonComments\r\n    ];\r\n\r\n    this.macroUses = [\r\n        {\r\n            token : [\"entity.name.function.preprocessor.csound\", \"punctuation.definition.macro-parameter-value-list.begin.csound\"],\r\n            regex : /(\\$[A-Z_a-z]\\w*\\.?)(\\()/,\r\n            next  : \"macro parameter value list\"\r\n        }, {\r\n            token : \"entity.name.function.preprocessor.csound\",\r\n            regex : /\\$[A-Z_a-z]\\w*(?:\\.|\\b)/\r\n        }\r\n    ];\r\n\r\n    this.numbers = [\r\n        {\r\n            token : \"constant.numeric.float.csound\",\r\n            regex : /(?:\\d+[Ee][+-]?\\d+)|(?:\\d+\\.\\d*|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?/\r\n        }, {\r\n            token : [\"storage.type.number.csound\", \"constant.numeric.integer.hexadecimal.csound\"],\r\n            regex : /(0[Xx])([0-9A-Fa-f]+)/\r\n        }, {\r\n            token : \"constant.numeric.integer.decimal.csound\",\r\n            regex : /\\d+/\r\n        }\r\n    ];\r\n\r\n    this.bracedStringContents = [\r\n        {\r\n            token : \"constant.character.escape.csound\",\r\n            // https://github.com/csound/csound/search?q=unquote_string+path%3AEngine+filename%3Acsound_orc_compile.c\r\n            regex : /\\\\(?:[\\\\abnrt\"]|[0-7]{1,3})/\r\n        },\r\n        // Format specifiers are included in quoted and braced strings. This\r\n        // means that format specifiers are highlighted in all strings, even\r\n        // though only\r\n        //   fprintks        https://csound.github.io/docs/manual/fprintks.html\r\n        //   fprints         https://csound.github.io/docs/manual/fprints.html\r\n        //   printf/printf_i https://csound.github.io/docs/manual/printf.html\r\n        //   printks         https://csound.github.io/docs/manual/printks.html\r\n        //   prints          https://csound.github.io/docs/manual/prints.html\r\n        //   sprintf         https://csound.github.io/docs/manual/sprintf.html\r\n        //   sprintfk        https://csound.github.io/docs/manual/sprintfk.html\r\n        // work with strings that contain format specifiers. In addition, these\r\n        // opcodes’ handling of format specifiers is inconsistent:\r\n        //   - fprintks, fprints, printks, and prints do accept %a and %A\r\n        //     specifiers, but can’t accept %s specifiers.\r\n        //   - printf, printf_i, sprintf, and sprintfk don’t accept %a and %A\r\n        //     specifiers, but do accept %s specifiers.\r\n        // See https://github.com/csound/csound/issues/747 for more information.\r\n        {\r\n            token : \"constant.character.placeholder.csound\",\r\n            regex : /%[#0\\- +]*\\d*(?:\\.\\d+)?[diuoxXfFeEgGaAcs]/\r\n        }, {\r\n            token : \"constant.character.escape.csound\",\r\n            regex : /%%/\r\n        }\r\n    ];\r\n\r\n    this.quotedStringContents = [\r\n        this.macroUses,\r\n        this.bracedStringContents\r\n    ];\r\n\r\n    var start = [\r\n        this.comments,\r\n\r\n        {\r\n            token : \"keyword.preprocessor.csound\",\r\n            regex : /#(?:e(?:nd(?:if)?|lse)\\b|##)|@@?[ \\t]*\\d+/\r\n        }, {\r\n            token : \"keyword.preprocessor.csound\",\r\n            regex : /#include/,\r\n            push  : [\r\n                this.comments,\r\n                {\r\n                    token : \"string.csound\",\r\n                    regex : /([^ \\t])(?:.*?\\1)/,\r\n                    next  : \"pop\"\r\n                }\r\n            ]\r\n        }, {\r\n            token : \"keyword.preprocessor.csound\",\r\n            regex : /#[ \\t]*define/,\r\n            next  : \"define directive\"\r\n        }, {\r\n            token : \"keyword.preprocessor.csound\",\r\n            regex : /#(?:ifn?def|undef)\\b/,\r\n            next  : \"macro directive\"\r\n        },\r\n\r\n        this.macroUses\r\n    ];\r\n\r\n    this.$rules = {\r\n        \"start\": start,\r\n\r\n        \"define directive\": [\r\n            this.comments,\r\n            {\r\n                token : \"entity.name.function.preprocessor.csound\",\r\n                regex : /[A-Z_a-z]\\w*/\r\n            }, {\r\n                token : \"punctuation.definition.macro-parameter-name-list.begin.csound\",\r\n                regex : /\\(/,\r\n                next  : \"macro parameter name list\"\r\n            }, {\r\n                token : \"punctuation.definition.macro.begin.csound\",\r\n                regex : /#/,\r\n                next  : \"macro body\"\r\n            }\r\n        ],\r\n        \"macro parameter name list\": [\r\n            {\r\n                token : \"variable.parameter.preprocessor.csound\",\r\n                regex : /[A-Z_a-z]\\w*/\r\n            }, {\r\n                token : \"punctuation.definition.macro-parameter-name-list.end.csound\",\r\n                regex : /\\)/,\r\n                next  : \"define directive\"\r\n            }\r\n        ],\r\n        \"macro body\": [\r\n            {\r\n                token : \"constant.character.escape.csound\",\r\n                regex : /\\\\#/\r\n            }, {\r\n                token : \"punctuation.definition.macro.end.csound\",\r\n                regex : /#/,\r\n                next  : \"start\"\r\n            },\r\n            start\r\n        ],\r\n\r\n        \"macro directive\": [\r\n            this.comments,\r\n            {\r\n                token : \"entity.name.function.preprocessor.csound\",\r\n                regex : /[A-Z_a-z]\\w*/,\r\n                next  : \"start\"\r\n            }\r\n        ],\r\n\r\n        \"macro parameter value list\": [\r\n            {\r\n                token : \"punctuation.definition.macro-parameter-value-list.end.csound\",\r\n                regex : /\\)/,\r\n                next  : \"start\"\r\n            }, {\r\n                token : \"punctuation.definition.string.begin.csound\",\r\n                regex : /\"/,\r\n                next  : \"macro parameter value quoted string\"\r\n            }, this.pushRule({\r\n                token : \"punctuation.macro-parameter-value-parenthetical.begin.csound\",\r\n                regex : /\\(/,\r\n                next  : \"macro parameter value parenthetical\"\r\n            }), {\r\n                token : \"punctuation.macro-parameter-value-separator.csound\",\r\n                regex : \"[#']\"\r\n            }\r\n        ],\r\n        \"macro parameter value quoted string\": [\r\n            {\r\n                token : \"constant.character.escape.csound\",\r\n                regex : /\\\\[#'()]/\r\n            }, {\r\n                token : \"invalid.illegal.csound\",\r\n                regex : /[#'()]/\r\n            }, {\r\n                token : \"punctuation.definition.string.end.csound\",\r\n                regex : /\"/,\r\n                next  : \"macro parameter value list\"\r\n            },\r\n            this.quotedStringContents,\r\n            {\r\n                defaultToken: \"string.quoted.csound\"\r\n            }\r\n        ],\r\n        \"macro parameter value parenthetical\": [\r\n            {\r\n                token : \"constant.character.escape.csound\",\r\n                regex : /\\\\\\)/\r\n            }, this.popRule({\r\n                token : \"punctuation.macro-parameter-value-parenthetical.end.csound\",\r\n                regex : /\\)/\r\n            }), this.pushRule({\r\n                token : \"punctuation.macro-parameter-value-parenthetical.begin.csound\",\r\n                regex : /\\(/,\r\n                next  : \"macro parameter value parenthetical\"\r\n            }),\r\n            start\r\n        ]\r\n    };\r\n};\r\n\r\noop.inherits(CsoundPreprocessorHighlightRules, TextHighlightRules);\r\n\r\n(function() {\r\n\r\n    this.pushRule = function(params) {\r\n        return {\r\n            regex : params.regex, onMatch: function(value, currentState, stack, line) {\r\n                if (stack.length === 0)\r\n                    stack.push(currentState);\r\n                if (Array.isArray(params.next)) {\r\n                    for (var i = 0; i < params.next.length; i++) {\r\n                        stack.push(params.next[i]);\r\n                    }\r\n                } else {\r\n                    stack.push(params.next);\r\n                }\r\n                this.next = stack[stack.length - 1];\r\n                return params.token;\r\n            },\r\n\r\n            // TODO\r\n            get next() { return Array.isArray(params.next) ? params.next[params.next.length - 1] : params.next; },\r\n            set next(next) {\r\n                if (Array.isArray(params.next)) {\r\n                    var oldNext = params.next[params.next.length - 1];\r\n                    var oldNextIndex = oldNext.length - 1;\r\n                    var newNextIndex = next.length - 1;\r\n                    if (newNextIndex > oldNextIndex) {\r\n                        while (oldNextIndex >= 0 && newNextIndex >= 0) {\r\n                            if (oldNext.charAt(oldNextIndex) !== next.charAt(newNextIndex)) {\r\n                                var prefix = next.substr(0, newNextIndex);\r\n                                for (var i = 0; i < params.next.length; i++) {\r\n                                    params.next[i] = prefix + params.next[i];\r\n                                }\r\n                                break;\r\n                            }\r\n                            oldNextIndex--;\r\n                            newNextIndex--;\r\n                        }\r\n                    }\r\n                } else {\r\n                    params.next = next;\r\n                }\r\n            },\r\n\r\n            // TODO: normalizeRules\r\n            get token() { return params.token; }\r\n        };\r\n    };\r\n\r\n    this.popRule = function(params) {\r\n        return {\r\n            regex : params.regex, onMatch: function(value, currentState, stack, line) {\r\n                stack.pop();\r\n                if (params.next) {\r\n                    stack.push(params.next);\r\n                    this.next = stack[stack.length - 1];\r\n                } else {\r\n                    this.next = stack.length > 1 ? stack[stack.length - 1] : stack.pop();\r\n                }\r\n                return params.token;\r\n            }\r\n        };\r\n    };\r\n\r\n}).call(CsoundPreprocessorHighlightRules.prototype);\r\n\r\nexports.CsoundPreprocessorHighlightRules = CsoundPreprocessorHighlightRules;\r\n});\r\n"]}