{"version":3,"sources":["mode/c9search_highlight_rules.js"],"names":["define","require","exports","module","oop","lang","TextHighlightRules","C9SearchHighlightRules","this","$rules","start","tokenNames","regex","onMatch","val","state","stack","values","splitRegex","exec","types","tokens","type","value","push","m","str","last","lastIndex","skipped","substring","index","length","substr","options","search","parts","split","i","test","escapeRegExp","source","flag","RegExp","e","safeCreateRegexp","token","next","numbers","normalizeRules","inherits"],"mappings":";;;;;;;AA8BAA,OAAO,SAASC,QAASC,QAASC,QAClC,aAEA,IAAIC,EAAMH,QAAQ,cACdI,EAAOJ,QAAQ,eACfK,EAAqBL,QAAQ,0BAA0BK,mBAQ3D,IAAIC,EAAyB,WAIzBC,KAAKC,QACDC,QAEQC,YAAc,mCAAoC,uBAAwB,uBAAwB,2BAClGC,MAAQ,oCACRC,QAAU,SAASC,EAAKC,EAAOC,GAC3B,IAAIC,EAAST,KAAKU,WAAWC,KAAKL,GAC9BM,EAAQZ,KAAKG,WACbU,IACAC,KAAMF,EAAM,GACZG,MAAON,EAAO,KAEdK,KAAMF,EAAM,GACZG,MAAON,EAAO,KAGdA,EAAO,KACU,KAAbA,EAAO,GACPI,EAAO,IAAOC,KAAMF,EAAM,GAAIG,MAAON,EAAO,GAAK,KAEjDI,EAAOG,MAAOF,KAAMF,EAAM,GAAIG,MAAON,EAAO,MAEpD,IAGIQ,EAHAb,EAAQI,EAAM,GACdU,EAAMT,EAAO,GAGbU,EAAO,EACX,GAAIf,GAASA,EAAMO,KAEf,IADAP,EAAMgB,UAAY,EACXH,EAAIb,EAAMO,KAAKO,IAAM,CACxB,IAAIG,EAAUH,EAAII,UAAUH,EAAMF,EAAEM,OAIpC,GAHAJ,EAAOf,EAAMgB,UACTC,GACAR,EAAOG,MAAMF,KAAMF,EAAM,GAAIG,MAAOM,IACpCJ,EAAE,GACFJ,EAAOG,MAAMF,KAAMF,EAAM,GAAIG,MAAOE,EAAE,UACrC,IAAKI,EACN,MAKZ,OAFIF,EAAOD,EAAIM,QACXX,EAAOG,MAAMF,KAAMF,EAAM,GAAIG,MAAOG,EAAIO,OAAON,KAC5CN,KAIXT,MAAQ,6BACRC,QAAS,SAASC,EAAKC,EAAOC,GAC1B,IAIIkB,EAASC,EAJTC,EAAQtB,EAAIuB,MAAM,KACtB,GAAID,EAAMJ,OAAS,EACf,MAAO,OAIX,IAAIM,EAAI,EACJjB,IACAE,MAAOa,EAAME,KAAO,IACpBhB,KAAM,SAENC,MAAOY,EAASC,EAAME,KACtBhB,KAAM,SAENC,MAAO,IAAMa,EAAME,KACnBhB,KAAM,SA6BV,IAzBiB,QAAbc,EAAM,IACNf,EAAOG,MACHD,MAAO,IAAMa,EAAME,KAAO,IAC1BhB,KAAM,SAENC,MAAOa,EAAME,KACbhB,KAAM,SAIdD,EAAOG,MACHD,MAAO,IAAMa,EAAME,KAAO,IAC1BhB,KAAM,SAGNc,EAAME,EAAE,IACRJ,EAAUE,EAAME,EAAE,GAClBjB,EAAOG,MACHD,MAAO,IAAMa,EAAME,EAAE,GAAK,IAC1BhB,KAAM,SAEVgB,GAAK,GAELA,GAAK,EAEFA,IAAMF,EAAMJ,QACfI,EAAME,IAAMjB,EAAOG,MACfD,MAAOa,EAAME,GACbhB,KAAM,SAIVa,IACK,QAAQI,KAAKL,KACdC,EAAS9B,EAAKmC,aAAaL,IAC3B,QAAQI,KAAKL,KACbC,EAAS,MAAQA,EAAS,QAGlC,IAAIvB,EAAQuB,GApHhC,SAA0BM,EAAQC,GAC9B,IACI,OAAO,IAAIC,OAAOF,EAAQC,GAC5B,MAAME,KAiH8BC,CAClB,IAAMV,EAAS,IACf,aAAaI,KAAKL,GAAW,IAAM,MAOvC,OALItB,IACAI,EAAM,GAAKD,EACXC,EAAM,GAAKJ,GAGRS,KAIXT,MAAQ,0BACRkC,MAAQ,OACRC,KAAO,YAGPD,MAAQ,SACRlC,MAAQ,cACRmC,KAAO,YAGfC,UACIpC,MAAQ,OACRkC,MAAQ,qBAERlC,MAAQ,IACRkC,MAAQ,OACRC,KAAO,WAGfvC,KAAKyC,kBAGT7C,EAAI8C,SAAS3C,EAAwBD,GAErCJ,QAAQK,uBAAyBA","file":"../../mode/c9search_highlight_rules.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../lib/oop\");\r\nvar lang = require(\"../lib/lang\");\r\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\n\r\nfunction safeCreateRegexp(source, flag) {\r\n    try {\r\n        return new RegExp(source, flag);\r\n    } catch(e) {}\r\n}\r\n\r\nvar C9SearchHighlightRules = function() {\r\n\r\n    // regexp must not have capturing parentheses. Use (?:) instead.\r\n    // regexps are ordered -> the first match is used\r\n    this.$rules = {\r\n        \"start\" : [\r\n            {\r\n                tokenNames : [\"c9searchresults.constant.numeric\", \"c9searchresults.text\", \"c9searchresults.text\", \"c9searchresults.keyword\"],\r\n                regex : /(^\\s+[0-9]+)(:)(\\d*\\s?)([^\\r\\n]+)/,\r\n                onMatch : function(val, state, stack) {\r\n                    var values = this.splitRegex.exec(val);\r\n                    var types = this.tokenNames;\r\n                    var tokens = [{\r\n                        type: types[0],\r\n                        value: values[1]\r\n                    }, {\r\n                        type: types[1],\r\n                        value: values[2]\r\n                    }];\r\n                    \r\n                    if (values[3]) {\r\n                        if (values[3] == \" \")\r\n                            tokens[1] = { type: types[1], value: values[2] + \" \" };\r\n                        else\r\n                            tokens.push({ type: types[1], value: values[3] });\r\n                    }\r\n                    var regex = stack[1];\r\n                    var str = values[4];\r\n                    \r\n                    var m;\r\n                    var last = 0;\r\n                    if (regex && regex.exec) {\r\n                        regex.lastIndex = 0;\r\n                        while (m = regex.exec(str)) {\r\n                            var skipped = str.substring(last, m.index);\r\n                            last = regex.lastIndex;\r\n                            if (skipped)\r\n                                tokens.push({type: types[2], value: skipped});\r\n                            if (m[0])\r\n                                tokens.push({type: types[3], value: m[0]});\r\n                            else if (!skipped)\r\n                                break;\r\n                        }\r\n                    }\r\n                    if (last < str.length)\r\n                        tokens.push({type: types[2], value: str.substr(last)});\r\n                    return tokens;\r\n                }\r\n            },\r\n            {\r\n                regex : \"^Searching for [^\\\\r\\\\n]*$\",\r\n                onMatch: function(val, state, stack) {\r\n                    var parts = val.split(\"\\x01\");\r\n                    if (parts.length < 3)\r\n                        return \"text\";\r\n\r\n                    var options, search;\r\n                    \r\n                    var i = 0;\r\n                    var tokens = [{\r\n                        value: parts[i++] + \"'\",\r\n                        type: \"text\"\r\n                    }, {\r\n                        value: search = parts[i++],\r\n                        type: \"text\" // \"c9searchresults.keyword\"\r\n                    }, {\r\n                        value: \"'\" + parts[i++],\r\n                        type: \"text\"\r\n                    }];\r\n                    \r\n                    // replaced\r\n                    if (parts[2] !== \" in\") {\r\n                        tokens.push({\r\n                            value: \"'\" + parts[i++] + \"'\",\r\n                            type: \"text\"\r\n                        }, {\r\n                            value: parts[i++],\r\n                            type: \"text\"\r\n                        });\r\n                    }\r\n                    // path\r\n                    tokens.push({\r\n                        value: \" \" + parts[i++] + \" \",\r\n                        type: \"text\"\r\n                    });\r\n                    // options\r\n                    if (parts[i+1]) {\r\n                        options = parts[i+1];\r\n                        tokens.push({\r\n                            value: \"(\" + parts[i+1] + \")\",\r\n                            type: \"text\"\r\n                        });\r\n                        i += 1;\r\n                    } else {\r\n                        i -= 1;\r\n                    }\r\n                    while (i++ < parts.length) {\r\n                        parts[i] && tokens.push({\r\n                            value: parts[i],\r\n                            type: \"text\"\r\n                        });\r\n                    }\r\n                    \r\n                    if (search) {\r\n                        if (!/regex/.test(options))\r\n                            search = lang.escapeRegExp(search);\r\n                        if (/whole/.test(options))\r\n                            search = \"\\\\b\" + search + \"\\\\b\";\r\n                    }\r\n                    \r\n                    var regex = search && safeCreateRegexp(\r\n                        \"(\" + search + \")\",\r\n                        / sensitive/.test(options) ? \"g\" : \"ig\"\r\n                    );\r\n                    if (regex) {\r\n                        stack[0] = state;\r\n                        stack[1] = regex;\r\n                    }\r\n                    \r\n                    return tokens;\r\n                }\r\n            },\r\n            {\r\n                regex : \"^(?=Found \\\\d+ matches)\",\r\n                token : \"text\",\r\n                next : \"numbers\"\r\n            },\r\n            {\r\n                token : \"string\", // single line\r\n                regex : \"^\\\\S:?[^:]+\",\r\n                next : \"numbers\"\r\n            }\r\n        ],\r\n        numbers:[{\r\n            regex : \"\\\\d+\",\r\n            token : \"constant.numeric\"\r\n        }, {\r\n            regex : \"$\",\r\n            token : \"text\",\r\n            next : \"start\"\r\n        }]\r\n    };\r\n    this.normalizeRules();\r\n};\r\n\r\noop.inherits(C9SearchHighlightRules, TextHighlightRules);\r\n\r\nexports.C9SearchHighlightRules = C9SearchHighlightRules;\r\n\r\n});"]}