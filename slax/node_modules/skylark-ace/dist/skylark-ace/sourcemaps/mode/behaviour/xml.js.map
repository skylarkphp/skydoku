{"version":3,"sources":["mode/behaviour/xml.js"],"names":["define","require","exports","module","oop","Behaviour","TokenIterator","is","token","type","lastIndexOf","XmlBehaviour","this","add","state","action","editor","session","text","quote","selected","doc","getTextRange","getSelectionRange","getWrapBehavioursEnabled","selection","cursor","getCursorPosition","rightChar","getLine","row","substring","column","iterator","getCurrentToken","stepBackward","rightSpace","match","range","isMultiLine","start","end","position","tokenEndColumn","getCurrentTokenColumn","value","length","nextToken","stepForward","test","slice","tokenRow","getCurrentTokenRow","tokenColumn","element","voidElements","hasOwnProperty","toLowerCase","line","indexOf","tag","getTokenAt","nextIndent","$getIndent","indent","getTabString","inherits"],"mappings":"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","file":"../../../mode/behaviour/xml.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../../lib/oop\");\r\nvar Behaviour = require(\"../behaviour\").Behaviour;\r\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\r\nvar lang = require(\"../../lib/lang\");\r\n\r\nfunction is(token, type) {\r\n    return token && token.type.lastIndexOf(type + \".xml\") > -1;\r\n}\r\n\r\nvar XmlBehaviour = function () {\r\n\r\n    this.add(\"string_dquotes\", \"insertion\", function (state, action, editor, session, text) {\r\n        if (text == '\"' || text == \"'\") {\r\n            var quote = text;\r\n            var selected = session.doc.getTextRange(editor.getSelectionRange());\r\n            if (selected !== \"\" && selected !== \"'\" && selected != '\"' && editor.getWrapBehavioursEnabled()) {\r\n                return {\r\n                    text: quote + selected + quote,\r\n                    selection: false\r\n                };\r\n            }\r\n\r\n            var cursor = editor.getCursorPosition();\r\n            var line = session.doc.getLine(cursor.row);\r\n            var rightChar = line.substring(cursor.column, cursor.column + 1);\r\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\r\n            var token = iterator.getCurrentToken();\r\n\r\n            if (rightChar == quote && (is(token, \"attribute-value\") || is(token, \"string\"))) {\r\n                // Ignore input and move right one if we're typing over the closing quote.\r\n                return {\r\n                    text: \"\",\r\n                    selection: [1, 1]\r\n                };\r\n            }\r\n\r\n            if (!token)\r\n                token = iterator.stepBackward();\r\n\r\n            if (!token)\r\n                return;\r\n\r\n            while (is(token, \"tag-whitespace\") || is(token, \"whitespace\")) {\r\n                token = iterator.stepBackward();\r\n            }\r\n            var rightSpace = !rightChar || rightChar.match(/\\s/);\r\n            if (is(token, \"attribute-equals\") && (rightSpace || rightChar == '>') || (is(token, \"decl-attribute-equals\") && (rightSpace || rightChar == '?'))) {\r\n                return {\r\n                    text: quote + quote,\r\n                    selection: [1, 1]\r\n                };\r\n            }\r\n        }\r\n    });\r\n\r\n    this.add(\"string_dquotes\", \"deletion\", function(state, action, editor, session, range) {\r\n        var selected = session.doc.getTextRange(range);\r\n        if (!range.isMultiLine() && (selected == '\"' || selected == \"'\")) {\r\n            var line = session.doc.getLine(range.start.row);\r\n            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);\r\n            if (rightChar == selected) {\r\n                range.end.column++;\r\n                return range;\r\n            }\r\n        }\r\n    });\r\n\r\n    this.add(\"autoclosing\", \"insertion\", function (state, action, editor, session, text) {\r\n        if (text == '>') {\r\n            var position = editor.getSelectionRange().start;\r\n            var iterator = new TokenIterator(session, position.row, position.column);\r\n            var token = iterator.getCurrentToken() || iterator.stepBackward();\r\n\r\n            // exit if we're not in a tag\r\n            if (!token || !(is(token, \"tag-name\") || is(token, \"tag-whitespace\") || is(token, \"attribute-name\") || is(token, \"attribute-equals\") || is(token, \"attribute-value\")))\r\n                return;\r\n\r\n            // exit if we're inside of a quoted attribute value\r\n            if (is(token, \"reference.attribute-value\"))\r\n                return;\r\n            if (is(token, \"attribute-value\")) {\r\n                var tokenEndColumn = iterator.getCurrentTokenColumn() + token.value.length;\r\n                if (position.column < tokenEndColumn)\r\n                    return;\r\n                if (position.column == tokenEndColumn) {\r\n                    var nextToken = iterator.stepForward();\r\n                    // TODO also handle non-closed string at the end of the line\r\n                    if (nextToken && is(nextToken, \"attribute-value\"))\r\n                        return;\r\n                    iterator.stepBackward();\r\n                }\r\n            }\r\n            \r\n            if (/^\\s*>/.test(session.getLine(position.row).slice(position.column)))\r\n                return;\r\n\r\n            // find tag name\r\n            while (!is(token, \"tag-name\")) {\r\n                token = iterator.stepBackward();\r\n                if (token.value == \"<\") {\r\n                    token = iterator.stepForward();\r\n                    break;\r\n                }\r\n            }\r\n\r\n            var tokenRow = iterator.getCurrentTokenRow();\r\n            var tokenColumn = iterator.getCurrentTokenColumn();\r\n\r\n            // exit if the tag is ending\r\n            if (is(iterator.stepBackward(), \"end-tag-open\"))\r\n                return;\r\n\r\n            var element = token.value;\r\n            if (tokenRow == position.row)\r\n                element = element.substring(0, position.column - tokenColumn);\r\n\r\n            if (this.voidElements.hasOwnProperty(element.toLowerCase()))\r\n                 return;\r\n\r\n            return {\r\n               text: \">\" + \"</\" + element + \">\",\r\n               selection: [1, 1]\r\n            };\r\n        }\r\n    });\r\n\r\n    this.add(\"autoindent\", \"insertion\", function (state, action, editor, session, text) {\r\n        if (text == \"\\n\") {\r\n            var cursor = editor.getCursorPosition();\r\n            var line = session.getLine(cursor.row);\r\n            var iterator = new TokenIterator(session, cursor.row, cursor.column);\r\n            var token = iterator.getCurrentToken();\r\n\r\n            if (token && token.type.indexOf(\"tag-close\") !== -1) {\r\n                if (token.value == \"/>\")\r\n                    return;\r\n                //get tag name\r\n                while (token && token.type.indexOf(\"tag-name\") === -1) {\r\n                    token = iterator.stepBackward();\r\n                }\r\n\r\n                if (!token) {\r\n                    return;\r\n                }\r\n\r\n                var tag = token.value;\r\n                var row = iterator.getCurrentTokenRow();\r\n\r\n                //don't indent after closing tag\r\n                token = iterator.stepBackward();\r\n                if (!token || token.type.indexOf(\"end-tag\") !== -1) {\r\n                    return;\r\n                }\r\n\r\n                if (this.voidElements && !this.voidElements[tag]) {\r\n                    var nextToken = session.getTokenAt(cursor.row, cursor.column+1);\r\n                    var line = session.getLine(row);\r\n                    var nextIndent = this.$getIndent(line);\r\n                    var indent = nextIndent + session.getTabString();\r\n\r\n                    if (nextToken && nextToken.value === \"</\") {\r\n                        return {\r\n                            text: \"\\n\" + indent + \"\\n\" + nextIndent,\r\n                            selection: [1, indent.length, 1, indent.length]\r\n                        };\r\n                    } else {\r\n                        return {\r\n                            text: \"\\n\" + indent\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n};\r\n\r\noop.inherits(XmlBehaviour, Behaviour);\r\n\r\nexports.XmlBehaviour = XmlBehaviour;\r\n});\r\n"]}