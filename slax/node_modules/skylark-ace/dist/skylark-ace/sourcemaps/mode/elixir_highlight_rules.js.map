{"version":3,"sources":["mode/elixir_highlight_rules.js"],"names":["define","require","exports","module","oop","TextHighlightRules","ElixirHighlightRules","this","$rules","start","token","regex","push","next","include","defaultToken","comment","TODO","originalRegex","#escaped_char","#interpolated_elixir","todo","#nest_curly_and_self","#regex_sub","normalizeRules","metaData","fileTypes","firstLineMatch","foldingStartMarker","foldingStopMarker","keyEquivalent","name","scopeName","inherits"],"mappings":"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","file":"../../mode/elixir_highlight_rules.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2012, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\n/* This file was autogenerated from https://raw.githubusercontent.com/elixir-lang/elixir-tmbundle/master/Syntaxes/Elixir.tmLanguage (uuid: ) */\r\n/****************************************************************************************\r\n * IT MIGHT NOT BE PERFECT ...But it's a good start from an existing *.tmlanguage file. *\r\n * fileTypes                                                                            *\r\n ****************************************************************************************/\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"../lib/oop\");\r\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\r\n\r\nvar ElixirHighlightRules = function() {\r\n    // regexp must not have capturing parentheses. Use (?:) instead.\r\n    // regexps are ordered -> the first match is used\r\n\r\n    this.$rules = { start: \r\n       [ { token: \r\n            [ 'meta.module.elixir',\r\n              'keyword.control.module.elixir',\r\n              'meta.module.elixir',\r\n              'entity.name.type.module.elixir' ],\r\n           regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)' },\r\n         { token: 'comment.documentation.heredoc',\r\n           regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\r\n           push: \r\n            [ { token: 'comment.documentation.heredoc',\r\n                regex: '\\\\s*\"\"\"',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'comment.documentation.heredoc' } ],\r\n           comment: '@doc with heredocs is treated as documentation' },\r\n         { token: 'comment.documentation.heredoc',\r\n           regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\r\n           push: \r\n            [ { token: 'comment.documentation.heredoc',\r\n                regex: '\\\\s*\"\"\"',\r\n                next: 'pop' },\r\n              { defaultToken: 'comment.documentation.heredoc' } ],\r\n           comment: '@doc with heredocs is treated as documentation' },\r\n         { token: 'comment.documentation.heredoc',\r\n           regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\r\n           push: \r\n            [ { token: 'comment.documentation.heredoc',\r\n                regex: '\\\\s*\\'\\'\\'',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'comment.documentation.heredoc' } ],\r\n           comment: '@doc with heredocs is treated as documentation' },\r\n         { token: 'comment.documentation.heredoc',\r\n           regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\r\n           push: \r\n            [ { token: 'comment.documentation.heredoc',\r\n                regex: '\\\\s*\\'\\'\\'',\r\n                next: 'pop' },\r\n              { defaultToken: 'comment.documentation.heredoc' } ],\r\n           comment: '@doc with heredocs is treated as documentation' },\r\n         { token: 'comment.documentation.false',\r\n           regex: '@(?:module|type)?doc false',\r\n           comment: '@doc false is treated as documentation' },\r\n         { token: 'comment.documentation.string',\r\n           regex: '@(?:module|type)?doc \"',\r\n           push: \r\n            [ { token: 'comment.documentation.string',\r\n                regex: '\"',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'comment.documentation.string' } ],\r\n           comment: '@doc with string is treated as documentation' },\r\n         { token: 'keyword.control.elixir',\r\n           regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|require|alias|use|quote|unquote|super)\\\\b(?![?!])' },\r\n         { token: 'keyword.operator.elixir',\r\n           regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\r\n           comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation' },\r\n         { token: 'constant.language.elixir',\r\n           regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])' },\r\n         { token: 'variable.language.elixir',\r\n           regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])' },\r\n         { token: \r\n            [ 'punctuation.definition.variable.elixir',\r\n              'variable.other.readwrite.module.elixir' ],\r\n           regex: '(@)([a-zA-Z_]\\\\w*)' },\r\n         { token: \r\n            [ 'punctuation.definition.variable.elixir',\r\n              'variable.other.anonymous.elixir' ],\r\n           regex: '(&)(\\\\d*)' },\r\n         { token: 'variable.other.constant.elixir',\r\n           regex: '\\\\b[A-Z]\\\\w*\\\\b' },\r\n         { token: 'constant.numeric.elixir',\r\n           regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b' },\r\n         { token: 'punctuation.definition.constant.elixir',\r\n           regex: ':\\'',\r\n           push: \r\n            [ { token: 'punctuation.definition.constant.elixir',\r\n                regex: '\\'',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'constant.other.symbol.single-quoted.elixir' } ] },\r\n         { token: 'punctuation.definition.constant.elixir',\r\n           regex: ':\"',\r\n           push: \r\n            [ { token: 'punctuation.definition.constant.elixir',\r\n                regex: '\"',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'constant.other.symbol.double-quoted.elixir' } ] },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '(?:\\'\\'\\')',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?>\\'\\'\\')',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '^\\\\s*\\'\\'\\'',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'support.function.variable.quoted.single.heredoc.elixir' } ],\r\n           comment: 'Single-quoted heredocs' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '\\'',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\'',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'support.function.variable.quoted.single.elixir' } ],\r\n           comment: 'single quoted string (allows for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '(?:\"\"\")',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?>\"\"\")',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '^\\\\s*\"\"\"',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.quoted.double.heredoc.elixir' } ],\r\n           comment: 'Double-quoted heredocs' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '\"',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\"',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.quoted.double.elixir' } ],\r\n           comment: 'double quoted string (allows for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[a-z](?:\"\"\")',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '~[a-z](?>\"\"\")',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '^\\\\s*\"\"\"',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.quoted.double.heredoc.elixir' } ],\r\n           comment: 'Double-quoted heredocs sigils' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[a-z]\\\\{',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\}[a-z]*',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.interpolated.elixir' } ],\r\n           comment: 'sigil (allow for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[a-z]\\\\[',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\][a-z]*',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.interpolated.elixir' } ],\r\n           comment: 'sigil (allow for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[a-z]\\\\<',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\>[a-z]*',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.interpolated.elixir' } ],\r\n           comment: 'sigil (allow for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[a-z]\\\\(',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\)[a-z]*',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.interpolated.elixir' } ],\r\n           comment: 'sigil (allow for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[a-z][^\\\\w]',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '[^\\\\w][a-z]*',\r\n                next: 'pop' },\r\n              { include: '#interpolated_elixir' },\r\n              { include: '#escaped_char' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.interpolated.elixir' } ],\r\n           comment: 'sigil (allow for interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[A-Z](?:\"\"\")',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '~[A-Z](?>\"\"\")',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '^\\\\s*\"\"\"',\r\n                next: 'pop' },\r\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\r\n           comment: 'Double-quoted heredocs sigils' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[A-Z]\\\\{',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\}[a-z]*',\r\n                next: 'pop' },\r\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\r\n           comment: 'sigil (without interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[A-Z]\\\\[',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\][a-z]*',\r\n                next: 'pop' },\r\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\r\n           comment: 'sigil (without interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[A-Z]\\\\<',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\>[a-z]*',\r\n                next: 'pop' },\r\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\r\n           comment: 'sigil (without interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[A-Z]\\\\(',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '\\\\)[a-z]*',\r\n                next: 'pop' },\r\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\r\n           comment: 'sigil (without interpolation)' },\r\n         { token: 'punctuation.definition.string.begin.elixir',\r\n           regex: '~[A-Z][^\\\\w]',\r\n           push: \r\n            [ { token: 'punctuation.definition.string.end.elixir',\r\n                regex: '[^\\\\w][a-z]*',\r\n                next: 'pop' },\r\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\r\n           comment: 'sigil (without interpolation)' },\r\n         { token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\r\n           regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\r\n           comment: 'symbols' },\r\n         { token: 'punctuation.definition.constant.elixir',\r\n           regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\r\n           comment: 'symbols' },\r\n         { token: \r\n            [ 'punctuation.definition.comment.elixir',\r\n              'comment.line.number-sign.elixir' ],\r\n           regex: '(#)(.*)' },\r\n         { token: 'constant.numeric.elixir',\r\n           regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\r\n           comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t' },\r\n        /* { token: 'punctuation.separator.variable.elixir',\r\n           regex: '(?<=\\\\{|do|\\\\{\\\\s|do\\\\s)\\\\|',\r\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\r\n           originalRegex: '(?<=\\\\{|do|\\\\{\\\\s|do\\\\s)(\\\\|)',\r\n           push: \r\n            [ { token: 'punctuation.separator.variable.elixir',\r\n                regex: '\\\\|',\r\n                next: 'pop' },\r\n              { token: 'variable.other.block.elixir',\r\n                regex: '[_a-zA-Z][_a-zA-Z0-9]*' },\r\n              { token: 'punctuation.separator.variable.elixir', regex: ',' } ] },*/\r\n         { token: 'keyword.operator.assignment.augmented.elixir',\r\n           regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&=' },\r\n         { token: 'keyword.operator.comparison.elixir',\r\n           regex: '===?|!==?|<=?|>=?' },\r\n         { token: 'keyword.operator.bitwise.elixir',\r\n           regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}' },\r\n         { token: 'keyword.operator.logical.elixir',\r\n           regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\r\n           originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b' },\r\n         { token: 'keyword.operator.arithmetic.elixir',\r\n           regex: '\\\\*|\\\\+|\\\\-|/' },\r\n         { token: 'keyword.operator.other.elixir',\r\n           regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>' },\r\n         { token: 'keyword.operator.assignment.elixir', regex: '=' },\r\n         { token: 'punctuation.separator.other.elixir', regex: ':' },\r\n         { token: 'punctuation.separator.statement.elixir',\r\n           regex: '\\\\;' },\r\n         { token: 'punctuation.separator.object.elixir', regex: ',' },\r\n         { token: 'punctuation.separator.method.elixir', regex: '\\\\.' },\r\n         { token: 'punctuation.section.scope.elixir', regex: '\\\\{|\\\\}' },\r\n         { token: 'punctuation.section.array.elixir', regex: '\\\\[|\\\\]' },\r\n         { token: 'punctuation.section.function.elixir',\r\n           regex: '\\\\(|\\\\)' } ],\r\n      '#escaped_char': \r\n       [ { token: 'constant.character.escape.elixir',\r\n           regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)' } ],\r\n      '#interpolated_elixir': \r\n       [ { token: \r\n            [ 'source.elixir.embedded.source',\r\n              'source.elixir.embedded.source.empty' ],\r\n           regex: '(#\\\\{)(\\\\})' },\r\n         { todo: \r\n            { token: 'punctuation.section.embedded.elixir',\r\n              regex: '#\\\\{',\r\n              push: \r\n               [ { token: 'punctuation.section.embedded.elixir',\r\n                   regex: '\\\\}',\r\n                   next: 'pop' },\r\n                 { include: '#nest_curly_and_self' },\r\n                 { include: '$self' },\r\n                 { defaultToken: 'source.elixir.embedded.source' } ] } } ],\r\n      '#nest_curly_and_self': \r\n       [ { token: 'punctuation.section.scope.elixir',\r\n           regex: '\\\\{',\r\n           push: \r\n            [ { token: 'punctuation.section.scope.elixir',\r\n                regex: '\\\\}',\r\n                next: 'pop' },\r\n              { include: '#nest_curly_and_self' } ] },\r\n         { include: '$self' } ],\r\n      '#regex_sub': \r\n       [ { include: '#interpolated_elixir' },\r\n         { include: '#escaped_char' },\r\n         { token: \r\n            [ 'punctuation.definition.arbitrary-repitition.elixir',\r\n              'string.regexp.arbitrary-repitition.elixir',\r\n              'string.regexp.arbitrary-repitition.elixir',\r\n              'punctuation.definition.arbitrary-repitition.elixir' ],\r\n           regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})' },\r\n         { token: 'punctuation.definition.character-class.elixir',\r\n           regex: '\\\\[(?:\\\\^?\\\\])?',\r\n           push: \r\n            [ { token: 'punctuation.definition.character-class.elixir',\r\n                regex: '\\\\]',\r\n                next: 'pop' },\r\n              { include: '#escaped_char' },\r\n              { defaultToken: 'string.regexp.character-class.elixir' } ] },\r\n         { token: 'punctuation.definition.group.elixir',\r\n           regex: '\\\\(',\r\n           push: \r\n            [ { token: 'punctuation.definition.group.elixir',\r\n                regex: '\\\\)',\r\n                next: 'pop' },\r\n              { include: '#regex_sub' },\r\n              { defaultToken: 'string.regexp.group.elixir' } ] },\r\n         { token: \r\n            [ 'punctuation.definition.comment.elixir',\r\n              'comment.line.number-sign.elixir' ],\r\n           regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\r\n           originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\r\n           comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.' } ] };\r\n    \r\n    this.normalizeRules();\r\n};\r\n\r\nElixirHighlightRules.metaData = { comment: 'Textmate bundle for Elixir Programming Language.',\r\n      fileTypes: [ 'ex', 'exs' ],\r\n      firstLineMatch: '^#!/.*\\\\belixir',\r\n      foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\r\n      foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\r\n      keyEquivalent: '^~E',\r\n      name: 'Elixir',\r\n      scopeName: 'source.elixir' };\r\n\r\n\r\noop.inherits(ElixirHighlightRules, TextHighlightRules);\r\n\r\nexports.ElixirHighlightRules = ElixirHighlightRules;\r\n});"]}