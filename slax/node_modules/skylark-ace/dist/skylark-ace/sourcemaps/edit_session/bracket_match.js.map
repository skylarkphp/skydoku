{"version":3,"sources":["edit_session/bracket_match.js"],"names":["define","require","exports","module","TokenIterator","Range","BracketMatch","this","findMatchingBracket","position","chr","column","charBeforeCursor","getLine","row","charAt","match","$findClosingBracket","$findOpeningBracket","getBracketRange","pos","range","line","before","bracketPos","fromPoints","end","start","cursor","$brackets",")","(","]","[","{","}","<",">","bracket","typeRe","openBracket","depth","iterator","token","getCurrentToken","stepForward","RegExp","type","replace","valueIndex","getCurrentTokenColumn","value","getCurrentTokenRow","stepBackward","test","length","closingBracket","valueLength"],"mappings":"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","file":"../../edit_session/bracket_match.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\r\nvar Range = require(\"../range\").Range;\r\n\r\n\r\nfunction BracketMatch() {\r\n\r\n    this.findMatchingBracket = function(position, chr) {\r\n        if (position.column == 0) return null;\r\n\r\n        var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column-1);\r\n        if (charBeforeCursor == \"\") return null;\r\n\r\n        var match = charBeforeCursor.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\r\n        if (!match)\r\n            return null;\r\n\r\n        if (match[1])\r\n            return this.$findClosingBracket(match[1], position);\r\n        else\r\n            return this.$findOpeningBracket(match[2], position);\r\n    };\r\n    \r\n    this.getBracketRange = function(pos) {\r\n        var line = this.getLine(pos.row);\r\n        var before = true, range;\r\n\r\n        var chr = line.charAt(pos.column-1);\r\n        var match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\r\n        if (!match) {\r\n            chr = line.charAt(pos.column);\r\n            pos = {row: pos.row, column: pos.column + 1};\r\n            match = chr && chr.match(/([\\(\\[\\{])|([\\)\\]\\}])/);\r\n            before = false;\r\n        }\r\n        if (!match)\r\n            return null;\r\n\r\n        if (match[1]) {\r\n            var bracketPos = this.$findClosingBracket(match[1], pos);\r\n            if (!bracketPos)\r\n                return null;\r\n            range = Range.fromPoints(pos, bracketPos);\r\n            if (!before) {\r\n                range.end.column++;\r\n                range.start.column--;\r\n            }\r\n            range.cursor = range.end;\r\n        } else {\r\n            var bracketPos = this.$findOpeningBracket(match[2], pos);\r\n            if (!bracketPos)\r\n                return null;\r\n            range = Range.fromPoints(bracketPos, pos);\r\n            if (!before) {\r\n                range.start.column++;\r\n                range.end.column--;\r\n            }\r\n            range.cursor = range.start;\r\n        }\r\n        \r\n        return range;\r\n    };\r\n\r\n    this.$brackets = {\r\n        \")\": \"(\",\r\n        \"(\": \")\",\r\n        \"]\": \"[\",\r\n        \"[\": \"]\",\r\n        \"{\": \"}\",\r\n        \"}\": \"{\",\r\n        \"<\": \">\",\r\n        \">\": \"<\"\r\n    };\r\n\r\n    this.$findOpeningBracket = function(bracket, position, typeRe) {\r\n        var openBracket = this.$brackets[bracket];\r\n        var depth = 1;\r\n\r\n        var iterator = new TokenIterator(this, position.row, position.column);\r\n        var token = iterator.getCurrentToken();\r\n        if (!token)\r\n            token = iterator.stepForward();\r\n        if (!token)\r\n            return;\r\n        \r\n         if (!typeRe){\r\n            typeRe = new RegExp(\r\n                \"(\\\\.?\" +\r\n                token.type.replace(\".\", \"\\\\.\").replace(\"rparen\", \".paren\")\r\n                    .replace(/\\b(?:end)\\b/, \"(?:start|begin|end)\")\r\n                + \")+\"\r\n            );\r\n        }\r\n        \r\n        // Start searching in token, just before the character at position.column\r\n        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;\r\n        var value = token.value;\r\n        \r\n        while (true) {\r\n        \r\n            while (valueIndex >= 0) {\r\n                var chr = value.charAt(valueIndex);\r\n                if (chr == openBracket) {\r\n                    depth -= 1;\r\n                    if (depth == 0) {\r\n                        return {row: iterator.getCurrentTokenRow(),\r\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\r\n                    }\r\n                }\r\n                else if (chr == bracket) {\r\n                    depth += 1;\r\n                }\r\n                valueIndex -= 1;\r\n            }\r\n\r\n            // Scan backward through the document, looking for the next token\r\n            // whose type matches typeRe\r\n            do {\r\n                token = iterator.stepBackward();\r\n            } while (token && !typeRe.test(token.type));\r\n\r\n            if (token == null)\r\n                break;\r\n                \r\n            value = token.value;\r\n            valueIndex = value.length - 1;\r\n        }\r\n        \r\n        return null;\r\n    };\r\n\r\n    this.$findClosingBracket = function(bracket, position, typeRe) {\r\n        var closingBracket = this.$brackets[bracket];\r\n        var depth = 1;\r\n\r\n        var iterator = new TokenIterator(this, position.row, position.column);\r\n        var token = iterator.getCurrentToken();\r\n        if (!token)\r\n            token = iterator.stepForward();\r\n        if (!token)\r\n            return;\r\n\r\n        if (!typeRe){\r\n            typeRe = new RegExp(\r\n                \"(\\\\.?\" +\r\n                token.type.replace(\".\", \"\\\\.\").replace(\"lparen\", \".paren\")\r\n                    .replace(/\\b(?:start|begin)\\b/, \"(?:start|begin|end)\")\r\n                + \")+\"\r\n            );\r\n        }\r\n\r\n        // Start searching in token, after the character at position.column\r\n        var valueIndex = position.column - iterator.getCurrentTokenColumn();\r\n\r\n        while (true) {\r\n\r\n            var value = token.value;\r\n            var valueLength = value.length;\r\n            while (valueIndex < valueLength) {\r\n                var chr = value.charAt(valueIndex);\r\n                if (chr == closingBracket) {\r\n                    depth -= 1;\r\n                    if (depth == 0) {\r\n                        return {row: iterator.getCurrentTokenRow(),\r\n                            column: valueIndex + iterator.getCurrentTokenColumn()};\r\n                    }\r\n                }\r\n                else if (chr == bracket) {\r\n                    depth += 1;\r\n                }\r\n                valueIndex += 1;\r\n            }\r\n\r\n            // Scan forward through the document, looking for the next token\r\n            // whose type matches typeRe\r\n            do {\r\n                token = iterator.stepForward();\r\n            } while (token && !typeRe.test(token.type));\r\n\r\n            if (token == null)\r\n                break;\r\n\r\n            valueIndex = 0;\r\n        }\r\n        \r\n        return null;\r\n    };\r\n}\r\nexports.BracketMatch = BracketMatch;\r\n\r\n});\r\n"]}