{"version":3,"sources":["edit_session/folding.js"],"names":["define","require","exports","module","Range","FoldLine","Fold","TokenIterator","Folding","this","getFoldAt","row","column","side","foldLine","getFoldLine","folds","i","length","fold","range","contains","isEnd","isStart","getFoldsInRange","start","end","foldLines","$foldData","foundFolds","cmp","compareRange","j","push","getFoldsInRangeList","ranges","Array","isArray","forEach","concat","getAllFolds","getFoldStringAt","trim","str","lastFold","compareEnd","getLine","substring","docRow","startFoldLine","foldData","indexOf","getNextFoldLine","getFoldedRowCount","first","last","rowCount","$addFoldLine","sort","a","b","addFold","placeholder","added","collapseChildren","$clipRangeToDocument","startRow","startColumn","endRow","endColumn","Error","startFold","endFold","addSubFold","removeFold","removeFolds","subFold","sameRow","foldLineNext","merge","$useWrapMode","$updateWrapData","$updateRowLengthCache","$modified","_signal","data","action","addFolds","splice","pop","shift","newFoldLine","split","$updating","cloneFolds","expandFold","subFolds","restoreRange","foldAll","expandFolds","unfold","location","expandInner","getLength","fromPoints","isRowFolded","startFoldRow","getRowFoldEnd","getRowFoldStart","getFoldDisplayLine","doc","textLine","walk","lastColumn","Math","max","getDisplayLine","line","$cloneFoldData","fd","map","clone","toggleFold","tryToUnfold","bracketPos","selection","getRange","isEmpty","cursor","findMatchingBracket","comparePoint","getCommentFoldRange","toString","isMultiLine","getTextRange","dir","iterator","token","getCurrentToken","type","test","match","re","RegExp","stepBackward","stepForward","getCurrentTokenRow","getCurrentTokenColumn","lastRow","state","getState","$row","value","depth","undefined","foldWidgets","getFoldWidget","getFoldWidgetRange","e","$foldStyles","manual","markbegin","markbeginend","$foldStyle","setFoldStyle","style","Object","keys","join","mode","$foldMode","$setFolding","foldMode","off","$updateFoldWidgets","$tokenizerUpdateFoldWidgets","bind","updateFoldWidgets","tokenizerUpdateFoldWidgets","on","getParentFoldRangeData","ignoreCurrent","fw","firstRange","c","onFoldWidgetClick","options","children","domEvent","shiftKey","all","ctrlKey","metaKey","siblings","altKey","$toggleFoldWidget","el","target","srcElement","className","isEqual","toggleFoldWidget","toggleParent","getCursor","delta","firstRow","len","args","unshift","apply","rows"],"mappings":"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","file":"../../edit_session/folding.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar Range = require(\"../range\").Range;\r\nvar FoldLine = require(\"./fold_line\").FoldLine;\r\nvar Fold = require(\"./fold\").Fold;\r\nvar TokenIterator = require(\"../token_iterator\").TokenIterator;\r\n\r\nfunction Folding() {\r\n    /*\r\n     * Looks up a fold at a given row/column. Possible values for side:\r\n     *   -1: ignore a fold if fold.start = row/column\r\n     *   +1: ignore a fold if fold.end = row/column\r\n     */\r\n    this.getFoldAt = function(row, column, side) {\r\n        var foldLine = this.getFoldLine(row);\r\n        if (!foldLine)\r\n            return null;\r\n\r\n        var folds = foldLine.folds;\r\n        for (var i = 0; i < folds.length; i++) {\r\n            var fold = folds[i];\r\n            if (fold.range.contains(row, column)) {\r\n                if (side == 1 && fold.range.isEnd(row, column)) {\r\n                    continue;\r\n                } else if (side == -1 && fold.range.isStart(row, column)) {\r\n                    continue;\r\n                }\r\n                return fold;\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * Returns all folds in the given range. Note, that this will return folds\r\n     *\r\n     */\r\n    this.getFoldsInRange = function(range) {\r\n        var start = range.start;\r\n        var end = range.end;\r\n        var foldLines = this.$foldData;\r\n        var foundFolds = [];\r\n\r\n        start.column += 1;\r\n        end.column -= 1;\r\n\r\n        for (var i = 0; i < foldLines.length; i++) {\r\n            var cmp = foldLines[i].range.compareRange(range);\r\n            if (cmp == 2) {\r\n                // Range is before foldLine. No intersection. This means,\r\n                // there might be other foldLines that intersect.\r\n                continue;\r\n            }\r\n            else if (cmp == -2) {\r\n                // Range is after foldLine. There can't be any other foldLines then,\r\n                // so let's give up.\r\n                break;\r\n            }\r\n\r\n            var folds = foldLines[i].folds;\r\n            for (var j = 0; j < folds.length; j++) {\r\n                var fold = folds[j];\r\n                cmp = fold.range.compareRange(range);\r\n                if (cmp == -2) {\r\n                    break;\r\n                } else if (cmp == 2) {\r\n                    continue;\r\n                } else\r\n                // WTF-state: Can happen due to -1/+1 to start/end column.\r\n                if (cmp == 42) {\r\n                    break;\r\n                }\r\n                foundFolds.push(fold);\r\n            }\r\n        }\r\n        start.column -= 1;\r\n        end.column += 1;\r\n\r\n        return foundFolds;\r\n    };\r\n\r\n    this.getFoldsInRangeList = function(ranges) {\r\n        if (Array.isArray(ranges)) {\r\n            var folds = [];\r\n            ranges.forEach(function(range) {\r\n                folds = folds.concat(this.getFoldsInRange(range));\r\n            }, this);\r\n        } else {\r\n            var folds = this.getFoldsInRange(ranges);\r\n        }\r\n        return folds;\r\n    };\r\n    \r\n    /*\r\n     * Returns all folds in the document\r\n     */\r\n    this.getAllFolds = function() {\r\n        var folds = [];\r\n        var foldLines = this.$foldData;\r\n        \r\n        for (var i = 0; i < foldLines.length; i++)\r\n            for (var j = 0; j < foldLines[i].folds.length; j++)\r\n                folds.push(foldLines[i].folds[j]);\r\n\r\n        return folds;\r\n    };\r\n\r\n    /*\r\n     * Returns the string between folds at the given position.\r\n     * E.g.\r\n     *  foo<fold>b|ar<fold>wolrd -> \"bar\"\r\n     *  foo<fold>bar<fold>wol|rd -> \"world\"\r\n     *  foo<fold>bar<fo|ld>wolrd -> <null>\r\n     *\r\n     * where | means the position of row/column\r\n     *\r\n     * The trim option determs if the return string should be trimed according\r\n     * to the \"side\" passed with the trim value:\r\n     *\r\n     * E.g.\r\n     *  foo<fold>b|ar<fold>wolrd -trim=-1> \"b\"\r\n     *  foo<fold>bar<fold>wol|rd -trim=+1> \"rld\"\r\n     *  fo|o<fold>bar<fold>wolrd -trim=00> \"foo\"\r\n     */\r\n    this.getFoldStringAt = function(row, column, trim, foldLine) {\r\n        foldLine = foldLine || this.getFoldLine(row);\r\n        if (!foldLine)\r\n            return null;\r\n\r\n        var lastFold = {\r\n            end: { column: 0 }\r\n        };\r\n        // TODO: Refactor to use getNextFoldTo function.\r\n        var str, fold;\r\n        for (var i = 0; i < foldLine.folds.length; i++) {\r\n            fold = foldLine.folds[i];\r\n            var cmp = fold.range.compareEnd(row, column);\r\n            if (cmp == -1) {\r\n                str = this\r\n                    .getLine(fold.start.row)\r\n                    .substring(lastFold.end.column, fold.start.column);\r\n                break;\r\n            }\r\n            else if (cmp === 0) {\r\n                return null;\r\n            }\r\n            lastFold = fold;\r\n        }\r\n        if (!str)\r\n            str = this.getLine(fold.start.row).substring(lastFold.end.column);\r\n\r\n        if (trim == -1)\r\n            return str.substring(0, column - lastFold.end.column);\r\n        else if (trim == 1)\r\n            return str.substring(column - lastFold.end.column);\r\n        else\r\n            return str;\r\n    };\r\n\r\n    this.getFoldLine = function(docRow, startFoldLine) {\r\n        var foldData = this.$foldData;\r\n        var i = 0;\r\n        if (startFoldLine)\r\n            i = foldData.indexOf(startFoldLine);\r\n        if (i == -1)\r\n            i = 0;\r\n        for (i; i < foldData.length; i++) {\r\n            var foldLine = foldData[i];\r\n            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {\r\n                return foldLine;\r\n            } else if (foldLine.end.row > docRow) {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    // returns the fold which starts after or contains docRow\r\n    this.getNextFoldLine = function(docRow, startFoldLine) {\r\n        var foldData = this.$foldData;\r\n        var i = 0;\r\n        if (startFoldLine)\r\n            i = foldData.indexOf(startFoldLine);\r\n        if (i == -1)\r\n            i = 0;\r\n        for (i; i < foldData.length; i++) {\r\n            var foldLine = foldData[i];\r\n            if (foldLine.end.row >= docRow) {\r\n                return foldLine;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    this.getFoldedRowCount = function(first, last) {\r\n        var foldData = this.$foldData, rowCount = last-first+1;\r\n        for (var i = 0; i < foldData.length; i++) {\r\n            var foldLine = foldData[i],\r\n                end = foldLine.end.row,\r\n                start = foldLine.start.row;\r\n            if (end >= last) {\r\n                if (start < last) {\r\n                    if (start >= first)\r\n                        rowCount -= last-start;\r\n                    else\r\n                        rowCount = 0; // in one fold\r\n                }\r\n                break;\r\n            } else if (end >= first){\r\n                if (start >= first) // fold inside range\r\n                    rowCount -=  end-start;\r\n                else\r\n                    rowCount -=  end-first+1;\r\n            }\r\n        }\r\n        return rowCount;\r\n    };\r\n\r\n    this.$addFoldLine = function(foldLine) {\r\n        this.$foldData.push(foldLine);\r\n        this.$foldData.sort(function(a, b) {\r\n            return a.start.row - b.start.row;\r\n        });\r\n        return foldLine;\r\n    };\r\n\r\n    /**\r\n     * Adds a new fold.\r\n     *\r\n     * @returns\r\n     *      The new created Fold object or an existing fold object in case the\r\n     *      passed in range fits an existing fold exactly.\r\n     */\r\n    this.addFold = function(placeholder, range) {\r\n        var foldData = this.$foldData;\r\n        var added = false;\r\n        var fold;\r\n        \r\n        if (placeholder instanceof Fold)\r\n            fold = placeholder;\r\n        else {\r\n            fold = new Fold(range, placeholder);\r\n            fold.collapseChildren = range.collapseChildren;\r\n        }\r\n        this.$clipRangeToDocument(fold.range);\r\n\r\n        var startRow = fold.start.row;\r\n        var startColumn = fold.start.column;\r\n        var endRow = fold.end.row;\r\n        var endColumn = fold.end.column;\r\n\r\n        // --- Some checking ---\r\n        if (!(startRow < endRow || \r\n            startRow == endRow && startColumn <= endColumn - 2))\r\n            throw new Error(\"The range has to be at least 2 characters width\");\r\n\r\n        var startFold = this.getFoldAt(startRow, startColumn, 1);\r\n        var endFold = this.getFoldAt(endRow, endColumn, -1);\r\n        if (startFold && endFold == startFold)\r\n            return startFold.addSubFold(fold);\r\n\r\n        if (startFold && !startFold.range.isStart(startRow, startColumn))\r\n            this.removeFold(startFold);\r\n        \r\n        if (endFold && !endFold.range.isEnd(endRow, endColumn))\r\n            this.removeFold(endFold);\r\n        \r\n        // Check if there are folds in the range we create the new fold for.\r\n        var folds = this.getFoldsInRange(fold.range);\r\n        if (folds.length > 0) {\r\n            // Remove the folds from fold data.\r\n            this.removeFolds(folds);\r\n            // Add the removed folds as subfolds on the new fold.\r\n            folds.forEach(function(subFold) {\r\n                fold.addSubFold(subFold);\r\n            });\r\n        }\r\n\r\n        for (var i = 0; i < foldData.length; i++) {\r\n            var foldLine = foldData[i];\r\n            if (endRow == foldLine.start.row) {\r\n                foldLine.addFold(fold);\r\n                added = true;\r\n                break;\r\n            } else if (startRow == foldLine.end.row) {\r\n                foldLine.addFold(fold);\r\n                added = true;\r\n                if (!fold.sameRow) {\r\n                    // Check if we might have to merge two FoldLines.\r\n                    var foldLineNext = foldData[i + 1];\r\n                    if (foldLineNext && foldLineNext.start.row == endRow) {\r\n                        // We need to merge!\r\n                        foldLine.merge(foldLineNext);\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            } else if (endRow <= foldLine.start.row) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!added)\r\n            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));\r\n\r\n        if (this.$useWrapMode)\r\n            this.$updateWrapData(foldLine.start.row, foldLine.start.row);\r\n        else\r\n            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);\r\n\r\n        // Notify that fold data has changed.\r\n        this.$modified = true;\r\n        this._signal(\"changeFold\", { data: fold, action: \"add\" });\r\n\r\n        return fold;\r\n    };\r\n\r\n    this.addFolds = function(folds) {\r\n        folds.forEach(function(fold) {\r\n            this.addFold(fold);\r\n        }, this);\r\n    };\r\n\r\n    this.removeFold = function(fold) {\r\n        var foldLine = fold.foldLine;\r\n        var startRow = foldLine.start.row;\r\n        var endRow = foldLine.end.row;\r\n\r\n        var foldLines = this.$foldData;\r\n        var folds = foldLine.folds;\r\n        // Simple case where there is only one fold in the FoldLine such that\r\n        // the entire fold line can get removed directly.\r\n        if (folds.length == 1) {\r\n            foldLines.splice(foldLines.indexOf(foldLine), 1);\r\n        } else\r\n        // If the fold is the last fold of the foldLine, just remove it.\r\n        if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {\r\n            folds.pop();\r\n            foldLine.end.row = folds[folds.length - 1].end.row;\r\n            foldLine.end.column = folds[folds.length - 1].end.column;\r\n        } else\r\n        // If the fold is the first fold of the foldLine, just remove it.\r\n        if (foldLine.range.isStart(fold.start.row, fold.start.column)) {\r\n            folds.shift();\r\n            foldLine.start.row = folds[0].start.row;\r\n            foldLine.start.column = folds[0].start.column;\r\n        } else\r\n        // We know there are more then 2 folds and the fold is not at the edge.\r\n        // This means, the fold is somewhere in between.\r\n        //\r\n        // If the fold is in one row, we just can remove it.\r\n        if (fold.sameRow) {\r\n            folds.splice(folds.indexOf(fold), 1);\r\n        } else\r\n        // The fold goes over more then one row. This means remvoing this fold\r\n        // will cause the fold line to get splitted up. newFoldLine is the second part\r\n        {\r\n            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);\r\n            folds = newFoldLine.folds;\r\n            folds.shift();\r\n            newFoldLine.start.row = folds[0].start.row;\r\n            newFoldLine.start.column = folds[0].start.column;\r\n        }\r\n\r\n        if (!this.$updating) {\r\n            if (this.$useWrapMode)\r\n                this.$updateWrapData(startRow, endRow);\r\n            else\r\n                this.$updateRowLengthCache(startRow, endRow);\r\n        }\r\n        \r\n        // Notify that fold data has changed.\r\n        this.$modified = true;\r\n        this._signal(\"changeFold\", { data: fold, action: \"remove\" });\r\n    };\r\n\r\n    this.removeFolds = function(folds) {\r\n        // We need to clone the folds array passed in as it might be the folds\r\n        // array of a fold line and as we call this.removeFold(fold), folds\r\n        // are removed from folds and changes the current index.\r\n        var cloneFolds = [];\r\n        for (var i = 0; i < folds.length; i++) {\r\n            cloneFolds.push(folds[i]);\r\n        }\r\n\r\n        cloneFolds.forEach(function(fold) {\r\n            this.removeFold(fold);\r\n        }, this);\r\n        this.$modified = true;\r\n    };\r\n\r\n    this.expandFold = function(fold) {\r\n        this.removeFold(fold);\r\n        fold.subFolds.forEach(function(subFold) {\r\n            fold.restoreRange(subFold);\r\n            this.addFold(subFold);\r\n        }, this);\r\n        if (fold.collapseChildren > 0) {\r\n            this.foldAll(fold.start.row+1, fold.end.row, fold.collapseChildren-1);\r\n        }\r\n        fold.subFolds = [];\r\n    };\r\n\r\n    this.expandFolds = function(folds) {\r\n        folds.forEach(function(fold) {\r\n            this.expandFold(fold);\r\n        }, this);\r\n    };\r\n\r\n    this.unfold = function(location, expandInner) {\r\n        var range, folds;\r\n        if (location == null) {\r\n            range = new Range(0, 0, this.getLength(), 0);\r\n            expandInner = true;\r\n        } else if (typeof location == \"number\")\r\n            range = new Range(location, 0, location, this.getLine(location).length);\r\n        else if (\"row\" in location)\r\n            range = Range.fromPoints(location, location);\r\n        else\r\n            range = location;\r\n        \r\n        folds = this.getFoldsInRangeList(range);\r\n        if (expandInner) {\r\n            this.removeFolds(folds);\r\n        } else {\r\n            var subFolds = folds;\r\n            // TODO: might be better to remove and add folds in one go instead of using\r\n            // expandFolds several times.\r\n            while (subFolds.length) {\r\n                this.expandFolds(subFolds);\r\n                subFolds = this.getFoldsInRangeList(range);\r\n            }\r\n        }\r\n        if (folds.length)\r\n            return folds;\r\n    };\r\n\r\n    /*\r\n     * Checks if a given documentRow is folded. This is true if there are some\r\n     * folded parts such that some parts of the line is still visible.\r\n     **/\r\n    this.isRowFolded = function(docRow, startFoldRow) {\r\n        return !!this.getFoldLine(docRow, startFoldRow);\r\n    };\r\n\r\n    this.getRowFoldEnd = function(docRow, startFoldRow) {\r\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\r\n        return foldLine ? foldLine.end.row : docRow;\r\n    };\r\n\r\n    this.getRowFoldStart = function(docRow, startFoldRow) {\r\n        var foldLine = this.getFoldLine(docRow, startFoldRow);\r\n        return foldLine ? foldLine.start.row : docRow;\r\n    };\r\n\r\n    this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {\r\n        if (startRow == null)\r\n            startRow = foldLine.start.row;\r\n        if (startColumn == null)\r\n            startColumn = 0;\r\n        if (endRow == null)\r\n            endRow = foldLine.end.row;\r\n        if (endColumn == null)\r\n            endColumn = this.getLine(endRow).length;\r\n        \r\n\r\n        // Build the textline using the FoldLine walker.\r\n        var doc = this.doc;\r\n        var textLine = \"\";\r\n\r\n        foldLine.walk(function(placeholder, row, column, lastColumn) {\r\n            if (row < startRow)\r\n                return;\r\n            if (row == startRow) {\r\n                if (column < startColumn)\r\n                    return;\r\n                lastColumn = Math.max(startColumn, lastColumn);\r\n            }\r\n\r\n            if (placeholder != null) {\r\n                textLine += placeholder;\r\n            } else {\r\n                textLine += doc.getLine(row).substring(lastColumn, column);\r\n            }\r\n        }, endRow, endColumn);\r\n        return textLine;\r\n    };\r\n\r\n    this.getDisplayLine = function(row, endColumn, startRow, startColumn) {\r\n        var foldLine = this.getFoldLine(row);\r\n\r\n        if (!foldLine) {\r\n            var line;\r\n            line = this.doc.getLine(row);\r\n            return line.substring(startColumn || 0, endColumn || line.length);\r\n        } else {\r\n            return this.getFoldDisplayLine(\r\n                foldLine, row, endColumn, startRow, startColumn);\r\n        }\r\n    };\r\n\r\n    this.$cloneFoldData = function() {\r\n        var fd = [];\r\n        fd = this.$foldData.map(function(foldLine) {\r\n            var folds = foldLine.folds.map(function(fold) {\r\n                return fold.clone();\r\n            });\r\n            return new FoldLine(fd, folds);\r\n        });\r\n\r\n        return fd;\r\n    };\r\n\r\n    this.toggleFold = function(tryToUnfold) {\r\n        var selection = this.selection;\r\n        var range = selection.getRange();\r\n        var fold;\r\n        var bracketPos;\r\n\r\n        if (range.isEmpty()) {\r\n            var cursor = range.start;\r\n            fold = this.getFoldAt(cursor.row, cursor.column);\r\n\r\n            if (fold) {\r\n                this.expandFold(fold);\r\n                return;\r\n            } else if (bracketPos = this.findMatchingBracket(cursor)) {\r\n                if (range.comparePoint(bracketPos) == 1) {\r\n                    range.end = bracketPos;\r\n                } else {\r\n                    range.start = bracketPos;\r\n                    range.start.column++;\r\n                    range.end.column--;\r\n                }\r\n            } else if (bracketPos = this.findMatchingBracket({row: cursor.row, column: cursor.column + 1})) {\r\n                if (range.comparePoint(bracketPos) == 1)\r\n                    range.end = bracketPos;\r\n                else\r\n                    range.start = bracketPos;\r\n\r\n                range.start.column++;\r\n            } else {\r\n                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;\r\n            }\r\n        } else {\r\n            var folds = this.getFoldsInRange(range);\r\n            if (tryToUnfold && folds.length) {\r\n                this.expandFolds(folds);\r\n                return;\r\n            } else if (folds.length == 1 ) {\r\n                fold = folds[0];\r\n            }\r\n        }\r\n\r\n        if (!fold)\r\n            fold = this.getFoldAt(range.start.row, range.start.column);\r\n\r\n        if (fold && fold.range.toString() == range.toString()) {\r\n            this.expandFold(fold);\r\n            return;\r\n        }\r\n\r\n        var placeholder = \"...\";\r\n        if (!range.isMultiLine()) {\r\n            placeholder = this.getTextRange(range);\r\n            if (placeholder.length < 4)\r\n                return;\r\n            placeholder = placeholder.trim().substring(0, 2) + \"..\";\r\n        }\r\n\r\n        this.addFold(placeholder, range);\r\n    };\r\n\r\n    this.getCommentFoldRange = function(row, column, dir) {\r\n        var iterator = new TokenIterator(this, row, column);\r\n        var token = iterator.getCurrentToken();\r\n        var type = token.type;\r\n        if (token && /^comment|string/.test(type)) {\r\n            type = type.match(/comment|string/)[0];\r\n            if (type == \"comment\")\r\n                type += \"|doc-start\";\r\n            var re = new RegExp(type);\r\n            var range = new Range();\r\n            if (dir != 1) {\r\n                do {\r\n                    token = iterator.stepBackward();\r\n                } while (token && re.test(token.type));\r\n                iterator.stepForward();\r\n            }\r\n            \r\n            range.start.row = iterator.getCurrentTokenRow();\r\n            range.start.column = iterator.getCurrentTokenColumn() + 2;\r\n\r\n            iterator = new TokenIterator(this, row, column);\r\n            \r\n            if (dir != -1) {\r\n                var lastRow = -1;\r\n                do {\r\n                    token = iterator.stepForward();\r\n                    if (lastRow == -1) {\r\n                        var state = this.getState(iterator.$row);\r\n                        if (!re.test(state))\r\n                            lastRow = iterator.$row;\r\n                    } else if (iterator.$row > lastRow) {\r\n                        break;\r\n                    }\r\n                } while (token && re.test(token.type));\r\n                token = iterator.stepBackward();\r\n            } else\r\n                token = iterator.getCurrentToken();\r\n\r\n            range.end.row = iterator.getCurrentTokenRow();\r\n            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;\r\n            return range;\r\n        }\r\n    };\r\n\r\n    this.foldAll = function(startRow, endRow, depth) {\r\n        if (depth == undefined)\r\n            depth = 100000; // JSON.stringify doesn't hanle Infinity\r\n        var foldWidgets = this.foldWidgets;\r\n        if (!foldWidgets)\r\n            return; // mode doesn't support folding\r\n        endRow = endRow || this.getLength();\r\n        startRow = startRow || 0;\r\n        for (var row = startRow; row < endRow; row++) {\r\n            if (foldWidgets[row] == null)\r\n                foldWidgets[row] = this.getFoldWidget(row);\r\n            if (foldWidgets[row] != \"start\")\r\n                continue;\r\n\r\n            var range = this.getFoldWidgetRange(row);\r\n            // sometimes range can be incompatible with existing fold\r\n            // TODO change addFold to return null istead of throwing\r\n            if (range && range.isMultiLine()\r\n                && range.end.row <= endRow\r\n                && range.start.row >= startRow\r\n            ) {\r\n                row = range.end.row;\r\n                try {\r\n                    // addFold can change the range\r\n                    var fold = this.addFold(\"...\", range);\r\n                    if (fold)\r\n                        fold.collapseChildren = depth;\r\n                } catch(e) {}\r\n            }\r\n        }\r\n    };\r\n    \r\n    // structured folding\r\n    this.$foldStyles = {\r\n        \"manual\": 1,\r\n        \"markbegin\": 1,\r\n        \"markbeginend\": 1\r\n    };\r\n    this.$foldStyle = \"markbegin\";\r\n    this.setFoldStyle = function(style) {\r\n        if (!this.$foldStyles[style])\r\n            throw new Error(\"invalid fold style: \" + style + \"[\" + Object.keys(this.$foldStyles).join(\", \") + \"]\");\r\n        \r\n        if (this.$foldStyle == style)\r\n            return;\r\n\r\n        this.$foldStyle = style;\r\n        \r\n        if (style == \"manual\")\r\n            this.unfold();\r\n        \r\n        // reset folding\r\n        var mode = this.$foldMode;\r\n        this.$setFolding(null);\r\n        this.$setFolding(mode);\r\n    };\r\n\r\n    this.$setFolding = function(foldMode) {\r\n        if (this.$foldMode == foldMode)\r\n            return;\r\n            \r\n        this.$foldMode = foldMode;\r\n        \r\n        this.off('change', this.$updateFoldWidgets);\r\n        this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\r\n        this._signal(\"changeAnnotation\");\r\n        \r\n        if (!foldMode || this.$foldStyle == \"manual\") {\r\n            this.foldWidgets = null;\r\n            return;\r\n        }\r\n        \r\n        this.foldWidgets = [];\r\n        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);\r\n        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);\r\n        \r\n        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);\r\n        this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);\r\n        this.on('change', this.$updateFoldWidgets);\r\n        this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);\r\n    };\r\n\r\n    this.getParentFoldRangeData = function (row, ignoreCurrent) {\r\n        var fw = this.foldWidgets;\r\n        if (!fw || (ignoreCurrent && fw[row]))\r\n            return {};\r\n\r\n        var i = row - 1, firstRange;\r\n        while (i >= 0) {\r\n            var c = fw[i];\r\n            if (c == null)\r\n                c = fw[i] = this.getFoldWidget(i);\r\n\r\n            if (c == \"start\") {\r\n                var range = this.getFoldWidgetRange(i);\r\n                if (!firstRange)\r\n                    firstRange = range;\r\n                if (range && range.end.row >= row)\r\n                    break;\r\n            }\r\n            i--;\r\n        }\r\n\r\n        return {\r\n            range: i !== -1 && range,\r\n            firstRange: firstRange\r\n        };\r\n    };\r\n\r\n    this.onFoldWidgetClick = function(row, e) {\r\n        e = e.domEvent;\r\n        var options = {\r\n            children: e.shiftKey,\r\n            all: e.ctrlKey || e.metaKey,\r\n            siblings: e.altKey\r\n        };\r\n        \r\n        var range = this.$toggleFoldWidget(row, options);\r\n        if (!range) {\r\n            var el = (e.target || e.srcElement);\r\n            if (el && /ace_fold-widget/.test(el.className))\r\n                el.className += \" ace_invalid\";\r\n        }\r\n    };\r\n    \r\n    this.$toggleFoldWidget = function(row, options) {\r\n        if (!this.getFoldWidget)\r\n            return;\r\n        var type = this.getFoldWidget(row);\r\n        var line = this.getLine(row);\r\n\r\n        var dir = type === \"end\" ? -1 : 1;\r\n        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);\r\n\r\n        if (fold) {\r\n            if (options.children || options.all)\r\n                this.removeFold(fold);\r\n            else\r\n                this.expandFold(fold);\r\n            return fold;\r\n        }\r\n\r\n        var range = this.getFoldWidgetRange(row, true);\r\n        // sometimes singleline folds can be missed by the code above\r\n        if (range && !range.isMultiLine()) {\r\n            fold = this.getFoldAt(range.start.row, range.start.column, 1);\r\n            if (fold && range.isEqual(fold.range)) {\r\n                this.removeFold(fold);\r\n                return fold;\r\n            }\r\n        }\r\n        \r\n        if (options.siblings) {\r\n            var data = this.getParentFoldRangeData(row);\r\n            if (data.range) {\r\n                var startRow = data.range.start.row + 1;\r\n                var endRow = data.range.end.row;\r\n            }\r\n            this.foldAll(startRow, endRow, options.all ? 10000 : 0);\r\n        } else if (options.children) {\r\n            endRow = range ? range.end.row : this.getLength();\r\n            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);\r\n        } else if (range) {\r\n            if (options.all) \r\n                range.collapseChildren = 10000;\r\n            this.addFold(\"...\", range);\r\n        }\r\n        \r\n        return range;\r\n    };\r\n    \r\n    \r\n    \r\n    this.toggleFoldWidget = function(toggleParent) {\r\n        var row = this.selection.getCursor().row;\r\n        row = this.getRowFoldStart(row);\r\n        var range = this.$toggleFoldWidget(row, {});\r\n        \r\n        if (range)\r\n            return;\r\n        // handle toggleParent\r\n        var data = this.getParentFoldRangeData(row, true);\r\n        range = data.range || data.firstRange;\r\n        \r\n        if (range) {\r\n            row = range.start.row;\r\n            var fold = this.getFoldAt(row, this.getLine(row).length, 1);\r\n\r\n            if (fold) {\r\n                this.removeFold(fold);\r\n            } else {\r\n                this.addFold(\"...\", range);\r\n            }\r\n        }\r\n    };\r\n\r\n    this.updateFoldWidgets = function(delta) {\r\n        var firstRow = delta.start.row;\r\n        var len = delta.end.row - firstRow;\r\n\r\n        if (len === 0) {\r\n            this.foldWidgets[firstRow] = null;\r\n        } else if (delta.action == 'remove') {\r\n            this.foldWidgets.splice(firstRow, len + 1, null);\r\n        } else {\r\n            var args = Array(len + 1);\r\n            args.unshift(firstRow, 1);\r\n            this.foldWidgets.splice.apply(this.foldWidgets, args);\r\n        }\r\n    };\r\n    this.tokenizerUpdateFoldWidgets = function(e) {\r\n        var rows = e.data;\r\n        if (rows.first != rows.last) {\r\n            if (this.foldWidgets.length > rows.first)\r\n                this.foldWidgets.splice(rows.first, this.foldWidgets.length);\r\n        }\r\n    };\r\n}\r\n\r\nexports.Folding = Folding;\r\n\r\n});\r\n"]}