{"version":3,"sources":["bidihandler.js"],"names":["define","require","exports","module","bidiUtil","lang","bidiRE","BidiHandler","session","this","bidiMap","currentRow","charWidths","EOL","showInvisibles","isRtlDir","$isRtl","line","wrapIndent","EOF","RLE","contentWidth","fontMetrics","rtlLineOffset","wrapOffset","isMoveLeftOperation","seenBidi","test","getValue","isBidiRow","screenRow","docRow","splitIndex","updateRowLine","updateBidiMap","bidiLevels","onChange","delta","action","lines","join","getDocumentRow","rowCache","$screenRowCache","length","index","$getRowCacheIndex","$docRowCache","getSplitIndex","currentIndex","prevIndex","undefined","endOfLine","getLength","getLine","charAt","$useWrapMode","splits","$wrapData","indent","L","substring","DOT","size","shift","replace","ch","i","isFullWidth","charCodeAt","getScreenTabSize","stringRepeat","$main","textContent","substr","getBoundingClientRect","width","textCharTypes","hasBidiCharacters","doBidiReorder","markAsDirty","updateCharacterWidths","characterWidth","$characterSize","bidiCharWidth","$measureCharWidth","EN","ON_R","R","AN","R_H","B","setShowInvisibles","setEolChar","eolChar","setContentWidth","isRtlLine","row","setRtlDirection","editor","cursor","getCursorPosition","selection","getSelectionAnchor","$bidiHandler","doc","insert","column","removeInLine","getPosLeft","col","leftBoundary","logicalIdx","getOverwrite","visualIdx","getVisualFromLogicalIdx","levels","left","getSelections","startCol","endCol","level","map","selections","offset","selColMin","Math","min","selColMax","max","isSelected","isSelectedPrev","selectionStart","logIdx","visIdx","logicalFromVisual","push","offsetToCol","posX","charWidth","call","prototype"],"mappings":"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","file":"../bidihandler.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar bidiUtil = require(\"./lib/bidiutil\");\r\nvar lang = require(\"./lib/lang\");\r\nvar bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\u202B]/;\r\n\r\n/**\r\n * This object is used to ensure Bi-Directional support (for languages with text flowing from right to left, like Arabic or Hebrew)\r\n * including correct caret positioning, text selection mouse and keyboard arrows functioning\r\n * @class BidiHandler\r\n **/\r\n\r\n/**\r\n * Creates a new `BidiHandler` object\r\n * @param {EditSession} session The session to use\r\n *\r\n * @constructor\r\n **/\r\nvar BidiHandler = function(session) {\r\n    this.session = session;\r\n    this.bidiMap = {};\r\n    /* current screen row */\r\n    this.currentRow = null;\r\n    this.bidiUtil = bidiUtil;\r\n    /* Arabic/Hebrew character width differs from regular character width */\r\n    this.charWidths = [];\r\n    this.EOL = \"\\xAC\";\r\n    this.showInvisibles = true;\r\n    this.isRtlDir = false;\r\n    this.$isRtl = false;\r\n    this.line = \"\";\r\n    this.wrapIndent = 0;\r\n    this.EOF = \"\\xB6\";\r\n    this.RLE = \"\\u202B\";\r\n    this.contentWidth = 0;\r\n    this.fontMetrics = null;\r\n    this.rtlLineOffset = 0;\r\n    this.wrapOffset = 0;\r\n    this.isMoveLeftOperation = false;\r\n    this.seenBidi = bidiRE.test(session.getValue());\r\n};\r\n\r\n(function() {\r\n    /**\r\n     * Returns 'true' if row contains Bidi characters, in such case\r\n     * creates Bidi map to be used in operations related to selection\r\n     * (keyboard arrays, mouse click, select)\r\n     * @param {Number} the screen row to be checked\r\n     * @param {Number} the document row to be checked [optional]\r\n     * @param {Number} the wrapped screen line index [ optional]\r\n    **/\r\n    this.isBidiRow = function(screenRow, docRow, splitIndex) {\r\n        if (!this.seenBidi)\r\n            return false;\r\n        if (screenRow !== this.currentRow) {\r\n            this.currentRow = screenRow;\r\n            this.updateRowLine(docRow, splitIndex);\r\n            this.updateBidiMap();\r\n        }\r\n        return this.bidiMap.bidiLevels;\r\n    };\r\n\r\n    this.onChange = function(delta) {\r\n        if (!this.seenBidi) {\r\n            if (delta.action == \"insert\" && bidiRE.test(delta.lines.join(\"\\n\"))) {\r\n                this.seenBidi = true;\r\n                this.currentRow = null;\r\n            }\r\n        } \r\n        else {\r\n            this.currentRow = null;\r\n        }\r\n    };\r\n\r\n    this.getDocumentRow = function() {\r\n        var docRow = 0;\r\n        var rowCache = this.session.$screenRowCache;\r\n        if (rowCache.length) {\r\n            var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);\r\n            if (index >= 0)\r\n                docRow = this.session.$docRowCache[index];\r\n        }\r\n\r\n        return docRow;\r\n    };\r\n\r\n    this.getSplitIndex = function() {\r\n        var splitIndex = 0;\r\n        var rowCache = this.session.$screenRowCache;\r\n        if (rowCache.length) {\r\n            var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);\r\n            while (this.currentRow - splitIndex > 0) {\r\n                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);\r\n                if (currentIndex !== prevIndex)\r\n                    break;\r\n\r\n                prevIndex = currentIndex;\r\n                splitIndex++;\r\n            }\r\n        } else {\r\n            splitIndex = this.currentRow;\r\n        }\r\n\r\n        return splitIndex;\r\n    };\r\n\r\n    this.updateRowLine = function(docRow, splitIndex) {\r\n        if (docRow === undefined)\r\n            docRow = this.getDocumentRow();\r\n            \r\n        var isLastRow = (docRow === this.session.getLength() - 1),\r\n            endOfLine = isLastRow ? this.EOF : this.EOL;\r\n\r\n        this.wrapIndent = 0;\r\n        this.line = this.session.getLine(docRow);\r\n        this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;\r\n        if (this.session.$useWrapMode) {\r\n            var splits = this.session.$wrapData[docRow];\r\n            if (splits) {\r\n                if (splitIndex === undefined)\r\n                    splitIndex = this.getSplitIndex();\r\n\r\n                if(splitIndex > 0 && splits.length) {\r\n                    this.wrapIndent = splits.indent;\r\n                    this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];\r\n                    this.line = (splitIndex < splits.length) ?\r\n                        this.line.substring(splits[splitIndex - 1], splits[splitIndex]) :\r\n                            this.line.substring(splits[splits.length - 1]);\r\n                } else {\r\n                    this.line = this.line.substring(0, splits[splitIndex]);\r\n                }\r\n            }\r\n            if (splitIndex == splits.length)\r\n                this.line += (this.showInvisibles) ? endOfLine : bidiUtil.DOT;\r\n        } else {\r\n            this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;\r\n        }\r\n            \r\n        /* replace tab and wide characters by commensurate spaces */\r\n        var session = this.session, shift = 0, size;\r\n        this.line = this.line.replace(/\\t|[\\u1100-\\u2029, \\u202F-\\uFFE6]/g, function(ch, i){\r\n            if (ch === '\\t' || session.isFullWidth(ch.charCodeAt(0))) {\r\n                size = (ch === '\\t') ? session.getScreenTabSize(i + shift) : 2;\r\n                shift += size - 1;\r\n                return lang.stringRepeat(bidiUtil.DOT, size);\r\n            }\r\n            return ch;\r\n        });\r\n\r\n        if (this.isRtlDir) {\r\n            this.fontMetrics.$main.textContent = (this.line.charAt(this.line.length - 1) == bidiUtil.DOT) ? this.line.substr(0, this.line.length - 1) : this.line;\r\n            this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;\r\n        }\r\n    };\r\n    \r\n    this.updateBidiMap = function() {\r\n        var textCharTypes = [];\r\n        if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {\r\n             this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);\r\n        } else {\r\n            this.bidiMap = {};\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Resets stored info related to current screen row\r\n    **/\r\n    this.markAsDirty = function() {\r\n        this.currentRow = null;\r\n    };\r\n\r\n    /**\r\n     * Updates array of character widths\r\n     * @param {Object} font metrics\r\n     *\r\n    **/\r\n    this.updateCharacterWidths = function(fontMetrics) {\r\n        if (this.characterWidth === fontMetrics.$characterSize.width)\r\n            return;\r\n\r\n        this.fontMetrics = fontMetrics;\r\n        var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;\r\n        var bidiCharWidth = fontMetrics.$measureCharWidth(\"\\u05d4\");\r\n\r\n        this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;\r\n        this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;\r\n        this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;\r\n        this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;\r\n\r\n        this.currentRow = null;\r\n    };\r\n\r\n    this.setShowInvisibles = function(showInvisibles) {\r\n        this.showInvisibles = showInvisibles;\r\n        this.currentRow = null;\r\n    };\r\n\r\n    this.setEolChar = function(eolChar) {\r\n        this.EOL = eolChar; \r\n    };\r\n\r\n    this.setContentWidth = function(width) {\r\n        this.contentWidth = width;\r\n    };\r\n\r\n    this.isRtlLine = function(row) {\r\n        if (this.$isRtl) return true;\r\n        if (row != undefined)\r\n            return (this.session.getLine(row).charAt(0) == this.RLE);\r\n        else\r\n            return this.isRtlDir; \r\n    };\r\n\r\n    this.setRtlDirection = function(editor, isRtlDir) {\r\n        var cursor = editor.getCursorPosition(); \r\n        for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {\r\n            if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)\r\n                editor.session.doc.removeInLine(row, 0, 1);\r\n            else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)\r\n                editor.session.doc.insert({column: 0, row: row}, editor.session.$bidiHandler.RLE);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Returns offset of character at position defined by column.\r\n     * @param {Number} the screen column position\r\n     *\r\n     * @return {int} horizontal pixel offset of given screen column\r\n     **/\r\n    this.getPosLeft = function(col) {\r\n        col -= this.wrapIndent;\r\n        var leftBoundary = (this.line.charAt(0) === this.RLE) ? 1 : 0;\r\n        var logicalIdx = (col > leftBoundary) ? (this.session.getOverwrite() ? col : col - 1) : leftBoundary;\r\n        var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap),\r\n            levels = this.bidiMap.bidiLevels, left = 0;\r\n\r\n        if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)\r\n            visualIdx++;\r\n            \r\n        for (var i = 0; i < visualIdx; i++) {\r\n            left += this.charWidths[levels[i]];\r\n        }\r\n\r\n        if (!this.session.getOverwrite() && (col > leftBoundary) && (levels[visualIdx] % 2 === 0))\r\n            left += this.charWidths[levels[visualIdx]];\r\n\r\n        if (this.wrapIndent)\r\n            left += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\r\n\r\n        if (this.isRtlDir)\r\n            left += this.rtlLineOffset;\r\n\r\n        return left;\r\n    };\r\n\r\n    /**\r\n     * Returns 'selections' - array of objects defining set of selection rectangles\r\n     * @param {Number} the start column position\r\n     * @param {Number} the end column position\r\n     *\r\n     * @return {Array of Objects} Each object contains 'left' and 'width' values defining selection rectangle.\r\n    **/\r\n    this.getSelections = function(startCol, endCol) {\r\n        var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0,\r\n            selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent,\r\n                isSelected = false, isSelectedPrev = false, selectionStart = 0;\r\n            \r\n        if (this.wrapIndent)\r\n            offset += this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\r\n\r\n        for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {\r\n            logIdx = map.logicalFromVisual[visIdx];\r\n            level = levels[visIdx];\r\n            isSelected = (logIdx >= selColMin) && (logIdx < selColMax);\r\n            if (isSelected && !isSelectedPrev) {\r\n                selectionStart = offset;\r\n            } else if (!isSelected && isSelectedPrev) {\r\n                selections.push({left: selectionStart, width: offset - selectionStart});\r\n            }\r\n            offset += this.charWidths[level];\r\n            isSelectedPrev = isSelected;\r\n        }\r\n\r\n        if (isSelected && (visIdx === levels.length)) {\r\n            selections.push({left: selectionStart, width: offset - selectionStart});\r\n        }\r\n\r\n        if(this.isRtlDir) {\r\n            for (var i = 0; i < selections.length; i++) {\r\n                selections[i].left += this.rtlLineOffset;\r\n            }\r\n        }\r\n        return selections;\r\n    };\r\n\r\n    /**\r\n     * Converts character coordinates on the screen to respective document column number\r\n     * @param {int} character horizontal offset\r\n     *\r\n     * @return {Number} screen column number corresponding to given pixel offset\r\n    **/\r\n    this.offsetToCol = function(posX) {\r\n        if(this.isRtlDir)\r\n            posX -= this.rtlLineOffset;\r\n\r\n        var logicalIdx = 0, posX = Math.max(posX, 0),\r\n            offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels,\r\n                charWidth = this.charWidths[levels[visualIdx]];\r\n\r\n        if (this.wrapIndent)\r\n           posX -= this.isRtlDir ? (-1 * this.wrapOffset) : this.wrapOffset;\r\n    \r\n        while(posX > offset + charWidth/2) {\r\n            offset += charWidth;\r\n            if(visualIdx === levels.length - 1) {\r\n                /* quit when we on the right of the last character, flag this by charWidth = 0 */\r\n                charWidth = 0;\r\n                break;\r\n            }\r\n            charWidth = this.charWidths[levels[++visualIdx]];\r\n        }\r\n    \r\n        if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && (levels[visualIdx] % 2 === 0)){\r\n        /* Bidi character on the left and None Bidi character on the right */\r\n            if(posX < offset)\r\n                visualIdx--;\r\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\r\n\r\n        } else if (visualIdx > 0 && (levels[visualIdx - 1] % 2 === 0) && (levels[visualIdx] % 2 !== 0)){\r\n        /* None Bidi character on the left and Bidi character on the right */\r\n            logicalIdx = 1 + ((posX > offset) ? this.bidiMap.logicalFromVisual[visualIdx]\r\n                    : this.bidiMap.logicalFromVisual[visualIdx - 1]);\r\n\r\n        } else if ((this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && (levels[visualIdx - 1] % 2 === 0))\r\n                || (!this.isRtlDir && visualIdx === 0 && (levels[visualIdx] % 2 !== 0))){\r\n        /* To the right of last character, which is None Bidi, in RTL direction or */\r\n        /* to the left of first Bidi character, in LTR direction */\r\n            logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];\r\n        } else {\r\n            /* Tweak visual position when Bidi character on the left in order to map it to corresponding logical position */\r\n            if (visualIdx > 0 && (levels[visualIdx - 1] % 2 !== 0) && charWidth !== 0)\r\n                visualIdx--;\r\n\r\n            /* Regular case */\r\n            logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];\r\n        }\r\n\r\n        if (logicalIdx === 0 && this.isRtlDir)\r\n            logicalIdx++;\r\n\r\n        return (logicalIdx + this.wrapIndent);\r\n    };\r\n\r\n}).call(BidiHandler.prototype);\r\n\r\nexports.BidiHandler = BidiHandler;\r\n});\r\n"]}