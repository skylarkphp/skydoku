{"version":3,"sources":["undomanager.js"],"names":["define","require","exports","module","UndoManager","this","$maxRev","$fromUndo","reset","addSession","session","$session","add","delta","allowMerge","$lastDelta","lastDeltas","$undoStack","push","id","$rev","action","addSelection","selection","rev","selections","value","startNewGroup","markIgnored","from","to","stack","i","length","ignore","getSelection","after","getRevision","getDeltas","end","start","slice","getChangedRanges","getChangedLines","undo","dontSelect","pos","deltaSet","swapped","swapGroups","rearrangeUndoStack","$redoStackBaseRev","$redoStack","pop","undoSelectionRange","undoChanges","$syncRev","redo","diff","redoStack","deltaSets","deltas","j","moveDeltasByOne","rebaseRedoStack","forEach","x","redoSelectionRange","redoChanges","nextDelta","mark","canUndo","canRedo","bookmark","undefined","isAtBookmark","toJSON","fromJSON","hasUndo","hasRedo","isClean","markClean","$prettyPrint","stringifyDelta","call","prototype","Range","cmp","comparePoints","clonePos","row","column","d","Array","isArray","map","join","type","lines","stringifyRange","r","swap","d1","d2","i1","i2","shift","ds1","ds2","selectionBefore","selectionAfter","xform","c1","fromPoints","before","splitDelta","shiftPos","filter","Boolean","dir","c","rowsBefore","otherLines","splice","col","substring","substr","cloneDelta","xformed"],"mappings":"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","file":"../undomanager.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\n/**\r\n * This object maintains the undo stack for an [[EditSession `EditSession`]].\r\n * @class UndoManager\r\n **/\r\n\r\n/**\r\n * Resets the current undo state and creates a new `UndoManager`.\r\n * \r\n * @constructor\r\n **/\r\nvar UndoManager = function() {\r\n    this.$maxRev = 0;\r\n    this.$fromUndo = false;\r\n    this.reset();\r\n};\r\n\r\n(function() {\r\n    \r\n    this.addSession = function(session) {\r\n        this.$session = session;\r\n    };\r\n    /**\r\n     * Provides a means for implementing your own undo manager. `options` has one property, `args`, an [[Array `Array`]], with two elements:\r\n     *\r\n     * - `args[0]` is an array of deltas\r\n     * - `args[1]` is the document to associate with\r\n     *\r\n     * @param {Object} options Contains additional properties\r\n     *\r\n     **/\r\n    this.add = function(delta, allowMerge, session) {\r\n        if (this.$fromUndo) return;\r\n        if (delta == this.$lastDelta) return;\r\n        if (allowMerge === false || !this.lastDeltas) {\r\n            this.lastDeltas = [];\r\n            this.$undoStack.push(this.lastDeltas);\r\n            delta.id = this.$rev = ++this.$maxRev;\r\n        }\r\n        if (delta.action == \"remove\" || delta.action == \"insert\")\r\n            this.$lastDelta = delta;\r\n        this.lastDeltas.push(delta);\r\n    };\r\n    \r\n    this.addSelection = function(selection, rev) {\r\n        this.selections.push({\r\n            value: selection,\r\n            rev: rev || this.$rev\r\n        });\r\n    };\r\n    \r\n    this.startNewGroup = function() {\r\n        this.lastDeltas = null;\r\n        return this.$rev;\r\n    };\r\n    \r\n    this.markIgnored = function(from, to) {\r\n        if (to == null) to = this.$rev + 1;\r\n        var stack = this.$undoStack;\r\n        for (var i = stack.length; i--;) {\r\n            var delta = stack[i][0];\r\n            if (delta.id <= from)\r\n                break;\r\n            if (delta.id < to)\r\n                delta.ignore = true;\r\n        }\r\n        this.lastDeltas = null;\r\n    };\r\n    \r\n    this.getSelection = function(rev, after) {\r\n        var stack = this.selections;\r\n        for (var i = stack.length; i--;) {\r\n            var selection = stack[i];\r\n            if (selection.rev < rev) {\r\n                if (after)\r\n                    selection = stack[i + 1];\r\n                return selection;\r\n            }\r\n        }\r\n    };\r\n    \r\n    this.getRevision = function() {\r\n        return this.$rev;\r\n    };\r\n    \r\n    this.getDeltas = function(from, to) {\r\n        if (to == null) to = this.$rev + 1;\r\n        var stack = this.$undoStack;\r\n        var end = null, start = 0;\r\n        for (var i = stack.length; i--;) {\r\n            var delta = stack[i][0];\r\n            if (delta.id < to && !end)\r\n                end = i+1;\r\n            if (delta.id <= from) {\r\n                start = i + 1;\r\n                break;\r\n            }\r\n        }\r\n        return stack.slice(start, end);\r\n    };\r\n    \r\n    this.getChangedRanges = function(from, to) {\r\n        if (to == null) to = this.$rev + 1;\r\n        \r\n    };\r\n    \r\n    this.getChangedLines = function(from, to) {\r\n        if (to == null) to = this.$rev + 1;\r\n        \r\n    };\r\n    \r\n    /**\r\n     * [Perform an undo operation on the document, reverting the last change.]{: #UndoManager.undo}\r\n     * @param {Boolean} dontSelect {:dontSelect}\r\n     *\r\n     * @returns {Range} The range of the undo.\r\n     **/\r\n    this.undo = function(session, dontSelect) {\r\n        this.lastDeltas = null;\r\n        var stack = this.$undoStack;\r\n        \r\n        if (!rearrangeUndoStack(stack, stack.length))\r\n            return;\r\n        \r\n        if (!session)\r\n            session = this.$session;\r\n        \r\n        if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)\r\n            this.$redoStack = [];\r\n        \r\n        this.$fromUndo = true;\r\n        \r\n        var deltaSet = stack.pop();\r\n        var undoSelectionRange = null;\r\n        if (deltaSet && deltaSet.length) {\r\n            undoSelectionRange = session.undoChanges(deltaSet, dontSelect);\r\n            this.$redoStack.push(deltaSet);\r\n            this.$syncRev();\r\n        }\r\n        \r\n        this.$fromUndo = false;\r\n\r\n        return undoSelectionRange;\r\n    };\r\n    \r\n    /**\r\n     * [Perform a redo operation on the document, reimplementing the last change.]{: #UndoManager.redo}\r\n     * @param {Boolean} dontSelect {:dontSelect}\r\n     *\r\n     **/\r\n    this.redo = function(session, dontSelect) {\r\n        this.lastDeltas = null;\r\n        \r\n        if (!session)\r\n            session = this.$session;\r\n        \r\n        this.$fromUndo = true;\r\n        if (this.$redoStackBaseRev != this.$rev) {\r\n            var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);\r\n            rebaseRedoStack(this.$redoStack, diff);\r\n            this.$redoStackBaseRev = this.$rev;\r\n            this.$redoStack.forEach(function(x) {\r\n                x[0].id = ++this.$maxRev;\r\n            }, this);\r\n        }\r\n        var deltaSet = this.$redoStack.pop();\r\n        var redoSelectionRange = null;\r\n        \r\n        if (deltaSet) {\r\n            redoSelectionRange = session.redoChanges(deltaSet, dontSelect);\r\n            this.$undoStack.push(deltaSet);\r\n            this.$syncRev();\r\n        }\r\n        this.$fromUndo = false;\r\n        \r\n        return redoSelectionRange;\r\n    };\r\n    \r\n    this.$syncRev = function() {\r\n        var stack = this.$undoStack;\r\n        var nextDelta = stack[stack.length - 1];\r\n        var id = nextDelta && nextDelta[0].id || 0;\r\n        this.$redoStackBaseRev = id;\r\n        this.$rev = id;\r\n    };\r\n\r\n    /**\r\n     * Destroys the stack of undo and redo redo operations.\r\n     **/\r\n    this.reset = function() {\r\n        this.lastDeltas = null;\r\n        this.$lastDelta = null;\r\n        this.$undoStack = [];\r\n        this.$redoStack = [];\r\n        this.$rev = 0;\r\n        this.mark = 0;\r\n        this.$redoStackBaseRev = this.$rev;\r\n        this.selections = [];\r\n    };\r\n\r\n    \r\n    /**\r\n     * Returns `true` if there are undo operations left to perform.\r\n     * @returns {Boolean}\r\n     **/\r\n    this.canUndo = function() {\r\n        return this.$undoStack.length > 0;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if there are redo operations left to perform.\r\n     * @returns {Boolean}\r\n     **/\r\n    this.canRedo = function() {\r\n        return this.$redoStack.length > 0;\r\n    };\r\n    \r\n    /**\r\n     * Marks the current status clean\r\n     **/\r\n    this.bookmark = function(rev) {\r\n        if (rev == undefined)\r\n            rev = this.$rev;\r\n        this.mark = rev;\r\n    };\r\n\r\n    /**\r\n     * Returns if the current status is clean\r\n     * @returns {Boolean}\r\n     **/\r\n    this.isAtBookmark = function() {\r\n        return this.$rev === this.mark;\r\n    };\r\n    \r\n    this.toJSON = function() {\r\n        \r\n    };\r\n    \r\n    this.fromJSON = function() {\r\n        \r\n    };\r\n    \r\n    this.hasUndo = this.canUndo;\r\n    this.hasRedo = this.canRedo;\r\n    this.isClean = this.isAtBookmark;\r\n    this.markClean = this.bookmark;\r\n    \r\n    this.$prettyPrint = function(delta) {\r\n        if (delta) return stringifyDelta(delta);\r\n        return stringifyDelta(this.$undoStack) + \"\\n---\\n\" + stringifyDelta(this.$redoStack);\r\n    };\r\n}).call(UndoManager.prototype);\r\n\r\nfunction rearrangeUndoStack(stack, pos) {\r\n    for (var i = pos; i--; ) {\r\n        var deltaSet = stack[i];\r\n        if (deltaSet && !deltaSet[0].ignore) {\r\n            while(i < pos - 1) {\r\n                var swapped = swapGroups(stack[i], stack[i + 1]);\r\n                stack[i] = swapped[0];\r\n                stack[i + 1] = swapped[1];\r\n                i++;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nvar Range = require(\"./range\").Range;\r\nvar cmp = Range.comparePoints;\r\nvar comparePoints = Range.comparePoints;\r\n\r\nfunction $updateMarkers(delta) {\r\n    var isInsert = delta.action == \"insert\";\r\n    var start = delta.start;\r\n    var end = delta.end;\r\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\r\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\r\n    if (isInsert) end = start;\r\n\r\n    for (var i in this.marks) {\r\n        var point = this.marks[i];\r\n        var cmp = comparePoints(point, start);\r\n        if (cmp < 0) {\r\n            continue; // delta starts after the range\r\n        }\r\n        if (cmp === 0) {\r\n            if (isInsert) {\r\n                if (point.bias == 1) {\r\n                    cmp = 1;\r\n                }\r\n                else {\r\n                    point.bias == -1;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        var cmp2 = isInsert ? cmp : comparePoints(point, end);\r\n        if (cmp2 > 0) {\r\n            point.row += rowShift;\r\n            point.column += point.row == end.row ? colShift : 0;\r\n            continue;\r\n        }\r\n        if (!isInsert && cmp2 <= 0) {\r\n            point.row = start.row;\r\n            point.column = start.column;\r\n            if (cmp2 === 0)\r\n                point.bias = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction clonePos(pos) {\r\n    return {row: pos.row,column: pos.column};\r\n}\r\nfunction cloneDelta(d) {\r\n    return {\r\n        start: clonePos(d.start),\r\n        end: clonePos(d.end),\r\n        action: d.action,\r\n        lines: d.lines.slice()\r\n    };\r\n}\r\nfunction stringifyDelta(d) {\r\n    d = d || this;\r\n    if (Array.isArray(d)) {\r\n        return d.map(stringifyDelta).join(\"\\n\");\r\n    }\r\n    var type = \"\";\r\n    if (d.action) {\r\n        type = d.action == \"insert\" ? \"+\" : \"-\";\r\n        type += \"[\" + d.lines + \"]\";\r\n    } else if (d.value) {\r\n        if (Array.isArray(d.value)) {\r\n            type = d.value.map(stringifyRange).join(\"\\n\");\r\n        } else {\r\n            type = stringifyRange(d.value);\r\n        }\r\n    }\r\n    if (d.start) {\r\n        type += stringifyRange(d);\r\n    }\r\n    if (d.id || d.rev) {\r\n        type += \"\\t(\" + (d.id || d.rev) + \")\";\r\n    }\r\n    return type;\r\n}\r\nfunction stringifyRange(r) {\r\n    return r.start.row + \":\" + r.start.column \r\n        + \"=>\" + r.end.row + \":\" + r.end.column;\r\n}\r\n/*\r\n * i i  d1  d2\r\n *      |/  |/  d2.s >= d1.e shift(d2, d1, -1)\r\n *              d2.s <= d1.s shift(d1, d2, +1)\r\n *       d1.s < d2.s < d1.e // can split\r\n * \r\n * i r  d1  d2\r\n *      |/  |\\  d2.s >= d1.e shift(d2, d1, -1)\r\n *              d2.e <= d1.s shift(d1, d2, -1)\r\n *       else // can't swap\r\n * \r\n * r i  d1  d2\r\n *      |\\  |/  d2.s >= d1.s shift(d2, d1, +1)\r\n *              d2.s <= d1.s shift(d1, d2, +1)\r\n *       // no else\r\n * \r\n * r r  d1  d2\r\n *      |\\  |\\  d2.s >= d1.s shift(d2, d1, +1)\r\n *              d2.e <= d1.s shift(d1, d2, -1)\r\n *       d2.s < d1.s < d2.e // can split\r\n */\r\n\r\nfunction swap(d1, d2) {\r\n    var i1 = d1.action == \"insert\";\r\n    var i2 = d2.action == \"insert\";\r\n    \r\n    if (i1 && i2) {\r\n        if (cmp(d2.start, d1.end) >= 0) {\r\n            shift(d2, d1, -1);\r\n        } else if (cmp(d2.start, d1.start) <= 0) {\r\n            shift(d1, d2, +1);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else if (i1 && !i2) {\r\n        if (cmp(d2.start, d1.end) >= 0) {\r\n            shift(d2, d1, -1);\r\n        } else if (cmp(d2.end, d1.start) <= 0) {\r\n            shift(d1, d2, -1);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else if (!i1 && i2) {\r\n        if (cmp(d2.start, d1.start) >= 0) {\r\n            shift(d2, d1, +1);\r\n        } else if (cmp(d2.start, d1.start) <= 0) {\r\n            shift(d1, d2, +1);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else if (!i1 && !i2) {\r\n        if (cmp(d2.start, d1.start) >= 0) {\r\n            shift(d2, d1, +1);\r\n        } else if (cmp(d2.end, d1.start) <= 0) {\r\n            shift(d1, d2, -1);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return [d2, d1];\r\n}\r\nfunction swapGroups(ds1, ds2) {\r\n    for (var i = ds1.length; i--; ) {\r\n        for (var j = 0; j < ds2.length; j++) {\r\n            if (!swap(ds1[i], ds2[j])) {\r\n                // rollback, we have to undo ds2 first\r\n                while (i < ds1.length) {\r\n                    while (j--) {\r\n                        swap(ds2[j], ds1[i]);\r\n                    }\r\n                    j = ds2.length;\r\n                    i++;\r\n                }                \r\n                return [ds1, ds2];\r\n            }\r\n        }\r\n    }\r\n    ds1.selectionBefore = ds2.selectionBefore = \r\n    ds1.selectionAfter = ds2.selectionAfter = null;\r\n    return [ds2, ds1];\r\n}\r\n\r\n/*\r\n      d2          xform(d1, c1) = [d2, c2]\r\n    o<---o        xform(c1, d1) = [c2, d2]\r\n c2 |    | d1     \r\n    o<---o\r\n      c1\r\n*/\r\nfunction xform(d1, c1) {\r\n    var i1 = d1.action == \"insert\";\r\n    var i2 = c1.action == \"insert\";\r\n    \r\n    if (i1 && i2) {\r\n        if (cmp(d1.start, c1.start) < 0) {\r\n            shift(c1, d1, 1);\r\n        } else {\r\n            shift(d1, c1, 1);\r\n        }\r\n    } else if (i1 && !i2) {\r\n        if (cmp(d1.start, c1.end) >= 0) {\r\n            shift(d1, c1, -1);\r\n        } else if (cmp(d1.start, c1.start) <= 0) {\r\n            shift(c1, d1, +1);\r\n        } else {\r\n            shift(d1, Range.fromPoints(c1.start, d1.start), -1);\r\n            shift(c1, d1, +1);\r\n        }\r\n    } else if (!i1 && i2) {\r\n        if (cmp(c1.start, d1.end) >= 0) {\r\n            shift(c1, d1, -1);\r\n        } else if (cmp(c1.start, d1.start) <= 0) {\r\n            shift(d1, c1, +1);\r\n        } else {\r\n            shift(c1, Range.fromPoints(d1.start, c1.start), -1);\r\n            shift(d1, c1, +1);\r\n        }\r\n    } else if (!i1 && !i2) {\r\n        if (cmp(c1.start, d1.end) >= 0) {\r\n            shift(c1, d1, -1);\r\n        } else if (cmp(c1.end, d1.start) <= 0) {\r\n            shift(d1, c1, -1);\r\n        } else {\r\n            var before, after;\r\n            if (cmp(d1.start, c1.start) < 0) {\r\n                before = d1;\r\n                d1 = splitDelta(d1, c1.start);\r\n            }\r\n            if (cmp(d1.end, c1.end) > 0) {\r\n                after = splitDelta(d1, c1.end);\r\n            }\r\n\r\n            shiftPos(c1.end, d1.start, d1.end, -1);\r\n            if (after && !before) {\r\n                d1.lines = after.lines;\r\n                d1.start = after.start;\r\n                d1.end = after.end;\r\n                after = d1;\r\n            }\r\n\r\n            return [c1, before, after].filter(Boolean);\r\n        }\r\n    }\r\n    return [c1, d1];\r\n}\r\n    \r\nfunction shift(d1, d2, dir) {\r\n    shiftPos(d1.start, d2.start, d2.end, dir);\r\n    shiftPos(d1.end, d2.start, d2.end, dir);\r\n}\r\nfunction shiftPos(pos, start, end, dir) {\r\n    if (pos.row == (dir == 1 ? start : end).row) {\r\n        pos.column += dir * (end.column - start.column);\r\n    }\r\n    pos.row += dir * (end.row - start.row);\r\n}\r\nfunction splitDelta(c, pos) {\r\n    var lines = c.lines;\r\n    var end = c.end;\r\n    c.end = clonePos(pos);    \r\n    var rowsBefore = c.end.row - c.start.row;\r\n    var otherLines = lines.splice(rowsBefore, lines.length);\r\n    \r\n    var col = rowsBefore ? pos.column : pos.column - c.start.column;\r\n    lines.push(otherLines[0].substring(0, col));\r\n    otherLines[0] = otherLines[0].substr(col)   ; \r\n    var rest = {\r\n        start: clonePos(pos),\r\n        end: end,\r\n        lines: otherLines,\r\n        action: c.action\r\n    };\r\n    return rest;\r\n}\r\n\r\nfunction moveDeltasByOne(redoStack, d) {\r\n    d = cloneDelta(d);\r\n    for (var j = redoStack.length; j--;) {\r\n        var deltaSet = redoStack[j];\r\n        for (var i = 0; i < deltaSet.length; i++) {\r\n            var x = deltaSet[i];\r\n            var xformed = xform(x, d);\r\n            d = xformed[0];\r\n            if (xformed.length != 2) {\r\n                if (xformed[2]) {\r\n                    deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);\r\n                    i++;\r\n                } else if (!xformed[1]) {\r\n                    deltaSet.splice(i, 1);\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n        if (!deltaSet.length) {\r\n            redoStack.splice(j, 1); \r\n        }\r\n    }\r\n    return redoStack;\r\n}\r\nfunction rebaseRedoStack(redoStack, deltaSets) {\r\n    for (var i = 0; i < deltaSets.length; i++) {\r\n        var deltas = deltaSets[i];\r\n        for (var j = 0; j < deltas.length; j++) {\r\n            moveDeltasByOne(redoStack, deltas[j]);\r\n        }\r\n    }\r\n}\r\n\r\nexports.UndoManager = UndoManager;\r\n\r\n});\r\n"]}