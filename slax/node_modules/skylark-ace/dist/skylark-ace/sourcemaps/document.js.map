{"version":3,"sources":["document.js"],"names":["define","require","exports","module","oop","applyDelta","EventEmitter","Range","Anchor","Document","textOrLines","this","$lines","length","Array","isArray","insertMergedLines","row","column","insert","implement","setValue","text","len","getLength","remove","getLine","getValue","getAllLines","join","getNewLineCharacter","createAnchor","split","$split","replace","$detectNewLine","match","$autoNewLine","_signal","$newLineMode","setNewLineMode","newLineMode","getNewLineMode","isNewLine","getLines","firstRow","lastRow","slice","getTextRange","range","getLinesForRange","lines","start","end","substring","l","insertLines","console","warn","insertFullLines","removeLines","removeFullLines","insertNewLine","position","insertInLine","clippedPos","pos","action","clonePos","undefined","line","Math","min","max","$clipPosition","concat","removeInLine","startColumn","endColumn","deleteFirstNewLine","deleteLastNewLine","startRow","startCol","endRow","endCol","deletedLines","removeNewLine","fromPoints","isEmpty","applyDeltas","deltas","i","revertDeltas","revertDelta","delta","doNotValidate","isInsert","comparePoints","$splitAndapplyLargeDelta","MAX","from","to","chunk","push","indexToPosition","index","newlineLength","positionToIndex","call","prototype"],"mappings":"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","file":"../document.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\n\r\nvar oop = require(\"./lib/oop\");\r\nvar applyDelta = require(\"./apply_delta\").applyDelta;\r\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\r\nvar Range = require(\"./range\").Range;\r\nvar Anchor = require(\"./anchor\").Anchor;\r\n\r\n/**\r\n * Contains the text of the document. Document can be attached to several [[EditSession `EditSession`]]s. \r\n * At its core, `Document`s are just an array of strings, with each row in the document matching up to the array index.\r\n *\r\n * @class Document\r\n **/\r\n\r\n/**\r\n *\r\n * Creates a new `Document`. If `text` is included, the `Document` contains those strings; otherwise, it's empty.\r\n * @param {String | Array} text The starting text\r\n * @constructor\r\n **/\r\n\r\nvar Document = function(textOrLines) {\r\n    this.$lines = [\"\"];\r\n\r\n    // There has to be one line at least in the document. If you pass an empty\r\n    // string to the insert function, nothing will happen. Workaround.\r\n    if (textOrLines.length === 0) {\r\n        this.$lines = [\"\"];\r\n    } else if (Array.isArray(textOrLines)) {\r\n        this.insertMergedLines({row: 0, column: 0}, textOrLines);\r\n    } else {\r\n        this.insert({row: 0, column:0}, textOrLines);\r\n    }\r\n};\r\n\r\n(function() {\r\n\r\n    oop.implement(this, EventEmitter);\r\n\r\n    /**\r\n     * Replaces all the lines in the current `Document` with the value of `text`.\r\n     *\r\n     * @param {String} text The text to use\r\n     **/\r\n    this.setValue = function(text) {\r\n        var len = this.getLength() - 1;\r\n        this.remove(new Range(0, 0, len, this.getLine(len).length));\r\n        this.insert({row: 0, column: 0}, text);\r\n    };\r\n\r\n    /**\r\n     * Returns all the lines in the document as a single string, joined by the new line character.\r\n     **/\r\n    this.getValue = function() {\r\n        return this.getAllLines().join(this.getNewLineCharacter());\r\n    };\r\n\r\n    /** \r\n     * Creates a new `Anchor` to define a floating point in the document.\r\n     * @param {Number} row The row number to use\r\n     * @param {Number} column The column number to use\r\n     *\r\n     **/\r\n    this.createAnchor = function(row, column) {\r\n        return new Anchor(this, row, column);\r\n    };\r\n\r\n    /** \r\n     * Splits a string of text on any newline (`\\n`) or carriage-return (`\\r`) characters.\r\n     *\r\n     * @method $split\r\n     * @param {String} text The text to work with\r\n     * @returns {String} A String array, with each index containing a piece of the original `text` string.\r\n     *\r\n     **/\r\n\r\n    // check for IE split bug\r\n    if (\"aaa\".split(/a/).length === 0) {\r\n        this.$split = function(text) {\r\n            return text.replace(/\\r\\n|\\r/g, \"\\n\").split(\"\\n\");\r\n        };\r\n    } else {\r\n        this.$split = function(text) {\r\n            return text.split(/\\r\\n|\\r|\\n/);\r\n        };\r\n    }\r\n\r\n\r\n    this.$detectNewLine = function(text) {\r\n        var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m);\r\n        this.$autoNewLine = match ? match[1] : \"\\n\";\r\n        this._signal(\"changeNewLineMode\");\r\n    };\r\n\r\n    /**\r\n     * Returns the newline character that's being used, depending on the value of `newLineMode`. \r\n     * @returns {String} If `newLineMode == windows`, `\\r\\n` is returned.  \r\n     *  If `newLineMode == unix`, `\\n` is returned.  \r\n     *  If `newLineMode == auto`, the value of `autoNewLine` is returned.\r\n     *\r\n     **/\r\n    this.getNewLineCharacter = function() {\r\n        switch (this.$newLineMode) {\r\n          case \"windows\":\r\n            return \"\\r\\n\";\r\n          case \"unix\":\r\n            return \"\\n\";\r\n          default:\r\n            return this.$autoNewLine || \"\\n\";\r\n        }\r\n    };\r\n\r\n    this.$autoNewLine = \"\";\r\n    this.$newLineMode = \"auto\";\r\n    /**\r\n     * [Sets the new line mode.]{: #Document.setNewLineMode.desc}\r\n     * @param {String} newLineMode [The newline mode to use; can be either `windows`, `unix`, or `auto`]{: #Document.setNewLineMode.param}\r\n     *\r\n     **/\r\n    this.setNewLineMode = function(newLineMode) {\r\n        if (this.$newLineMode === newLineMode)\r\n            return;\r\n\r\n        this.$newLineMode = newLineMode;\r\n        this._signal(\"changeNewLineMode\");\r\n    };\r\n\r\n    /**\r\n     * [Returns the type of newlines being used; either `windows`, `unix`, or `auto`]{: #Document.getNewLineMode}\r\n     * @returns {String}\r\n     **/\r\n    this.getNewLineMode = function() {\r\n        return this.$newLineMode;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if `text` is a newline character (either `\\r\\n`, `\\r`, or `\\n`).\r\n     * @param {String} text The text to check\r\n     *\r\n     **/\r\n    this.isNewLine = function(text) {\r\n        return (text == \"\\r\\n\" || text == \"\\r\" || text == \"\\n\");\r\n    };\r\n\r\n    /**\r\n     * Returns a verbatim copy of the given line as it is in the document\r\n     * @param {Number} row The row index to retrieve\r\n     *\r\n     **/\r\n    this.getLine = function(row) {\r\n        return this.$lines[row] || \"\";\r\n    };\r\n\r\n    /**\r\n     * Returns an array of strings of the rows between `firstRow` and `lastRow`. This function is inclusive of `lastRow`.\r\n     * @param {Number} firstRow The first row index to retrieve\r\n     * @param {Number} lastRow The final row index to retrieve\r\n     *\r\n     **/\r\n    this.getLines = function(firstRow, lastRow) {\r\n        return this.$lines.slice(firstRow, lastRow + 1);\r\n    };\r\n\r\n    /**\r\n     * Returns all lines in the document as string array.\r\n     **/\r\n    this.getAllLines = function() {\r\n        return this.getLines(0, this.getLength());\r\n    };\r\n\r\n    /**\r\n     * Returns the number of rows in the document.\r\n     **/\r\n    this.getLength = function() {\r\n        return this.$lines.length;\r\n    };\r\n\r\n    /**\r\n     * Returns all the text within `range` as a single string.\r\n     * @param {Range} range The range to work with.\r\n     * \r\n     * @returns {String}\r\n     **/\r\n    this.getTextRange = function(range) {\r\n        return this.getLinesForRange(range).join(this.getNewLineCharacter());\r\n    };\r\n    \r\n    /**\r\n     * Returns all the text within `range` as an array of lines.\r\n     * @param {Range} range The range to work with.\r\n     * \r\n     * @returns {Array}\r\n     **/\r\n    this.getLinesForRange = function(range) {\r\n        var lines;\r\n        if (range.start.row === range.end.row) {\r\n            // Handle a single-line range.\r\n            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];\r\n        } else {\r\n            // Handle a multi-line range.\r\n            lines = this.getLines(range.start.row, range.end.row);\r\n            lines[0] = (lines[0] || \"\").substring(range.start.column);\r\n            var l = lines.length - 1;\r\n            if (range.end.row - range.start.row == l)\r\n                lines[l] = lines[l].substring(0, range.end.column);\r\n        }\r\n        return lines;\r\n    };\r\n\r\n    // Deprecated methods retained for backwards compatibility.\r\n    this.insertLines = function(row, lines) {\r\n        console.warn(\"Use of document.insertLines is deprecated. Use the insertFullLines method instead.\");\r\n        return this.insertFullLines(row, lines);\r\n    };\r\n    this.removeLines = function(firstRow, lastRow) {\r\n        console.warn(\"Use of document.removeLines is deprecated. Use the removeFullLines method instead.\");\r\n        return this.removeFullLines(firstRow, lastRow);\r\n    };\r\n    this.insertNewLine = function(position) {\r\n        console.warn(\"Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.\");\r\n        return this.insertMergedLines(position, [\"\", \"\"]);\r\n    };\r\n\r\n    /**\r\n     * Inserts a block of `text` at the indicated `position`.\r\n     * @param {Object} position The position to start inserting at; it's an object that looks like `{ row: row, column: column}`\r\n     * @param {String} text A chunk of text to insert\r\n     * @returns {Object} The position ({row, column}) of the last line of `text`. If the length of `text` is 0, this function simply returns `position`. \r\n     *\r\n     **/\r\n    this.insert = function(position, text) {\r\n        // Only detect new lines if the document has no line break yet.\r\n        if (this.getLength() <= 1)\r\n            this.$detectNewLine(text);\r\n        \r\n        return this.insertMergedLines(position, this.$split(text));\r\n    };\r\n    \r\n    /**\r\n     * Inserts `text` into the `position` at the current row. This method also triggers the `\"change\"` event.\r\n     * \r\n     * This differs from the `insert` method in two ways:\r\n     *   1. This does NOT handle newline characters (single-line text only).\r\n     *   2. This is faster than the `insert` method for single-line text insertions.\r\n     * \r\n     * @param {Object} position The position to insert at; it's an object that looks like `{ row: row, column: column}`\r\n     * @param {String} text A chunk of text\r\n     * @returns {Object} Returns an object containing the final row and column, like this:  \r\n     *     ```\r\n     *     {row: endRow, column: 0}\r\n     *     ```\r\n     **/\r\n    this.insertInLine = function(position, text) {\r\n        var start = this.clippedPos(position.row, position.column);\r\n        var end = this.pos(position.row, position.column + text.length);\r\n        \r\n        this.applyDelta({\r\n            start: start,\r\n            end: end,\r\n            action: \"insert\",\r\n            lines: [text]\r\n        }, true);\r\n        \r\n        return this.clonePos(end);\r\n    };\r\n    \r\n    this.clippedPos = function(row, column) {\r\n        var length = this.getLength();\r\n        if (row === undefined) {\r\n            row = length;\r\n        } else if (row < 0) {\r\n            row = 0;\r\n        } else if (row >= length) {\r\n            row = length - 1;\r\n            column = undefined;\r\n        }\r\n        var line = this.getLine(row);\r\n        if (column == undefined)\r\n            column = line.length;\r\n        column = Math.min(Math.max(column, 0), line.length);\r\n        return {row: row, column: column};\r\n    };\r\n    \r\n    this.clonePos = function(pos) {\r\n        return {row: pos.row, column: pos.column};\r\n    };\r\n    \r\n    this.pos = function(row, column) {\r\n        return {row: row, column: column};\r\n    };\r\n    \r\n    this.$clipPosition = function(position) {\r\n        var length = this.getLength();\r\n        if (position.row >= length) {\r\n            position.row = Math.max(0, length - 1);\r\n            position.column = this.getLine(length - 1).length;\r\n        } else {\r\n            position.row = Math.max(0, position.row);\r\n            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);\r\n        }\r\n        return position;\r\n    };\r\n\r\n    /**\r\n     * Fires whenever the document changes.\r\n     *\r\n     * Several methods trigger different `\"change\"` events. Below is a list of each action type, followed by each property that's also available:\r\n     *\r\n     *  * `\"insert\"`\r\n     *    * `range`: the [[Range]] of the change within the document\r\n     *    * `lines`: the lines being added\r\n     *  * `\"remove\"`\r\n     *    * `range`: the [[Range]] of the change within the document\r\n     *    * `lines`: the lines being removed\r\n     *\r\n     * @event change\r\n     * @param {Object} e Contains at least one property called `\"action\"`. `\"action\"` indicates the action that triggered the change. Each action also has a set of additional properties.\r\n     *\r\n     **/\r\n    \r\n    /**\r\n     * Inserts the elements in `lines` into the document as full lines (does not merge with existing line), starting at the row index given by `row`. This method also triggers the `\"change\"` event.\r\n     * @param {Number} row The index of the row to insert at\r\n     * @param {Array} lines An array of strings\r\n     * @returns {Object} Contains the final row and column, like this:  \r\n     *   ```\r\n     *   {row: endRow, column: 0}\r\n     *   ```  \r\n     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  \r\n     *   ``` \r\n     *   {row: row, column: 0}\r\n     *   ```\r\n     *\r\n     **/\r\n    this.insertFullLines = function(row, lines) {\r\n        // Clip to document.\r\n        // Allow one past the document end.\r\n        row = Math.min(Math.max(row, 0), this.getLength());\r\n        \r\n        // Calculate insertion point.\r\n        var column = 0;\r\n        if (row < this.getLength()) {\r\n            // Insert before the specified row.\r\n            lines = lines.concat([\"\"]);\r\n            column = 0;\r\n        } else {\r\n            // Insert after the last row in the document.\r\n            lines = [\"\"].concat(lines);\r\n            row--;\r\n            column = this.$lines[row].length;\r\n        }\r\n        \r\n        // Insert.\r\n        this.insertMergedLines({row: row, column: column}, lines);\r\n    };\r\n\r\n    /**\r\n     * Inserts the elements in `lines` into the document, starting at the position index given by `row`. This method also triggers the `\"change\"` event.\r\n     * @param {Number} row The index of the row to insert at\r\n     * @param {Array} lines An array of strings\r\n     * @returns {Object} Contains the final row and column, like this:  \r\n     *   ```\r\n     *   {row: endRow, column: 0}\r\n     *   ```  \r\n     *   If `lines` is empty, this function returns an object containing the current row, and column, like this:  \r\n     *   ``` \r\n     *   {row: row, column: 0}\r\n     *   ```\r\n     *\r\n     **/    \r\n    this.insertMergedLines = function(position, lines) {\r\n        var start = this.clippedPos(position.row, position.column);\r\n        var end = {\r\n            row: start.row + lines.length - 1,\r\n            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length\r\n        };\r\n        \r\n        this.applyDelta({\r\n            start: start,\r\n            end: end,\r\n            action: \"insert\",\r\n            lines: lines\r\n        });\r\n        \r\n        return this.clonePos(end);\r\n    };\r\n\r\n    /**\r\n     * Removes the `range` from the document.\r\n     * @param {Range} range A specified Range to remove\r\n     * @returns {Object} Returns the new `start` property of the range, which contains `startRow` and `startColumn`. If `range` is empty, this function returns the unmodified value of `range.start`.\r\n     *\r\n     **/\r\n    this.remove = function(range) {\r\n        var start = this.clippedPos(range.start.row, range.start.column);\r\n        var end = this.clippedPos(range.end.row, range.end.column);\r\n        this.applyDelta({\r\n            start: start,\r\n            end: end,\r\n            action: \"remove\",\r\n            lines: this.getLinesForRange({start: start, end: end})\r\n        });\r\n        return this.clonePos(start);\r\n    };\r\n\r\n    /**\r\n     * Removes the specified columns from the `row`. This method also triggers a `\"change\"` event.\r\n     * @param {Number} row The row to remove from\r\n     * @param {Number} startColumn The column to start removing at \r\n     * @param {Number} endColumn The column to stop removing at\r\n     * @returns {Object} Returns an object containing `startRow` and `startColumn`, indicating the new row and column values.<br/>If `startColumn` is equal to `endColumn`, this function returns nothing.\r\n     *\r\n     **/\r\n    this.removeInLine = function(row, startColumn, endColumn) {\r\n        var start = this.clippedPos(row, startColumn);\r\n        var end = this.clippedPos(row, endColumn);\r\n        \r\n        this.applyDelta({\r\n            start: start,\r\n            end: end,\r\n            action: \"remove\",\r\n            lines: this.getLinesForRange({start: start, end: end})\r\n        }, true);\r\n        \r\n        return this.clonePos(start);\r\n    };\r\n\r\n    /**\r\n     * Removes a range of full lines. This method also triggers the `\"change\"` event.\r\n     * @param {Number} firstRow The first row to be removed\r\n     * @param {Number} lastRow The last row to be removed\r\n     * @returns {[String]} Returns all the removed lines.\r\n     *\r\n     **/\r\n    this.removeFullLines = function(firstRow, lastRow) {\r\n        // Clip to document.\r\n        firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);\r\n        lastRow  = Math.min(Math.max(0, lastRow ), this.getLength() - 1);\r\n        \r\n        // Calculate deletion range.\r\n        // Delete the ending new line unless we're at the end of the document.\r\n        // If we're at the end of the document, delete the starting new line.\r\n        var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;\r\n        var deleteLastNewLine  = lastRow  < this.getLength() - 1;\r\n        var startRow = ( deleteFirstNewLine ? firstRow - 1                  : firstRow                    );\r\n        var startCol = ( deleteFirstNewLine ? this.getLine(startRow).length : 0                           );\r\n        var endRow   = ( deleteLastNewLine  ? lastRow + 1                   : lastRow                     );\r\n        var endCol   = ( deleteLastNewLine  ? 0                             : this.getLine(endRow).length ); \r\n        var range = new Range(startRow, startCol, endRow, endCol);\r\n        \r\n        // Store delelted lines with bounding newlines ommitted (maintains previous behavior).\r\n        var deletedLines = this.$lines.slice(firstRow, lastRow + 1);\r\n        \r\n        this.applyDelta({\r\n            start: range.start,\r\n            end: range.end,\r\n            action: \"remove\",\r\n            lines: this.getLinesForRange(range)\r\n        });\r\n        \r\n        // Return the deleted lines.\r\n        return deletedLines;\r\n    };\r\n\r\n    /**\r\n     * Removes the new line between `row` and the row immediately following it. This method also triggers the `\"change\"` event.\r\n     * @param {Number} row The row to check\r\n     *\r\n     **/\r\n    this.removeNewLine = function(row) {\r\n        if (row < this.getLength() - 1 && row >= 0) {\r\n            this.applyDelta({\r\n                start: this.pos(row, this.getLine(row).length),\r\n                end: this.pos(row + 1, 0),\r\n                action: \"remove\",\r\n                lines: [\"\", \"\"]\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Replaces a range in the document with the new `text`.\r\n     * @param {Range} range A specified Range to replace\r\n     * @param {String} text The new text to use as a replacement\r\n     * @returns {Object} Returns an object containing the final row and column, like this:\r\n     *     {row: endRow, column: 0}\r\n     * If the text and range are empty, this function returns an object containing the current `range.start` value.\r\n     * If the text is the exact same as what currently exists, this function returns an object containing the current `range.end` value.\r\n     *\r\n     **/\r\n    this.replace = function(range, text) {\r\n        if (!(range instanceof Range))\r\n            range = Range.fromPoints(range.start, range.end);\r\n        if (text.length === 0 && range.isEmpty())\r\n            return range.start;\r\n\r\n        // Shortcut: If the text we want to insert is the same as it is already\r\n        // in the document, we don't have to replace anything.\r\n        if (text == this.getTextRange(range))\r\n            return range.end;\r\n\r\n        this.remove(range);\r\n        var end;\r\n        if (text) {\r\n            end = this.insert(range.start, text);\r\n        }\r\n        else {\r\n            end = range.start;\r\n        }\r\n        \r\n        return end;\r\n    };\r\n\r\n    /**\r\n     * Applies all changes in `deltas` to the document.\r\n     * @param {Array} deltas An array of delta objects (can include \"insert\" and \"remove\" actions)\r\n     **/\r\n    this.applyDeltas = function(deltas) {\r\n        for (var i=0; i<deltas.length; i++) {\r\n            this.applyDelta(deltas[i]);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Reverts all changes in `deltas` from the document.\r\n     * @param {Array} deltas An array of delta objects (can include \"insert\" and \"remove\" actions)\r\n     **/\r\n    this.revertDeltas = function(deltas) {\r\n        for (var i=deltas.length-1; i>=0; i--) {\r\n            this.revertDelta(deltas[i]);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Applies `delta` to the document.\r\n     * @param {Object} delta A delta object (can include \"insert\" and \"remove\" actions)\r\n     **/\r\n    this.applyDelta = function(delta, doNotValidate) {\r\n        var isInsert = delta.action == \"insert\";\r\n        // An empty range is a NOOP.\r\n        if (isInsert ? delta.lines.length <= 1 && !delta.lines[0]\r\n            : !Range.comparePoints(delta.start, delta.end)) {\r\n            return;\r\n        }\r\n        \r\n        if (isInsert && delta.lines.length > 20000) {\r\n            this.$splitAndapplyLargeDelta(delta, 20000);\r\n        }\r\n        else {\r\n            applyDelta(this.$lines, delta, doNotValidate);\r\n            this._signal(\"change\", delta);\r\n        }\r\n    };\r\n    \r\n    this.$splitAndapplyLargeDelta = function(delta, MAX) {\r\n        // Split large insert deltas. This is necessary because:\r\n        //    1. We need to support splicing delta lines into the document via $lines.splice.apply(...)\r\n        //    2. fn.apply() doesn't work for a large number of params. The smallest threshold is on chrome 40 ~42000.\r\n        // we use 20000 to leave some space for actual stack\r\n        // \r\n        // To Do: Ideally we'd be consistent and also split 'delete' deltas. We don't do this now, because delete\r\n        //        delta handling is too slow. If we make delete delta handling faster we can split all large deltas\r\n        //        as shown in https://gist.github.com/aldendaniels/8367109#file-document-snippet-js\r\n        //        If we do this, update validateDelta() to limit the number of lines in a delete delta.\r\n        var lines = delta.lines;\r\n        var l = lines.length - MAX + 1;\r\n        var row = delta.start.row; \r\n        var column = delta.start.column;\r\n        for (var from = 0, to = 0; from < l; from = to) {\r\n            to += MAX - 1;\r\n            var chunk = lines.slice(from, to);\r\n            chunk.push(\"\");\r\n            this.applyDelta({\r\n                start: this.pos(row + from, column),\r\n                end: this.pos(row + to, column = 0),\r\n                action: delta.action,\r\n                lines: chunk\r\n            }, true);\r\n        }\r\n        // Update remaining delta.\r\n        delta.lines = lines.slice(from);\r\n        delta.start.row = row + from;\r\n        delta.start.column = column;\r\n        this.applyDelta(delta, true);\r\n    };\r\n    \r\n    /**\r\n     * Reverts `delta` from the document.\r\n     * @param {Object} delta A delta object (can include \"insert\" and \"remove\" actions)\r\n     **/\r\n    this.revertDelta = function(delta) {\r\n        this.applyDelta({\r\n            start: this.clonePos(delta.start),\r\n            end: this.clonePos(delta.end),\r\n            action: (delta.action == \"insert\" ? \"remove\" : \"insert\"),\r\n            lines: delta.lines.slice()\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Converts an index position in a document to a `{row, column}` object.\r\n     *\r\n     * Index refers to the \"absolute position\" of a character in the document. For example:\r\n     *\r\n     * ```javascript\r\n     * var x = 0; // 10 characters, plus one for newline\r\n     * var y = -1;\r\n     * ```\r\n     * \r\n     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.\r\n     *\r\n     * @param {Number} index An index to convert\r\n     * @param {Number} startRow=0 The row from which to start the conversion\r\n     * @returns {Object} A `{row, column}` object of the `index` position\r\n     */\r\n    this.indexToPosition = function(index, startRow) {\r\n        var lines = this.$lines || this.getAllLines();\r\n        var newlineLength = this.getNewLineCharacter().length;\r\n        for (var i = startRow || 0, l = lines.length; i < l; i++) {\r\n            index -= lines[i].length + newlineLength;\r\n            if (index < 0)\r\n                return {row: i, column: index + lines[i].length + newlineLength};\r\n        }\r\n        return {row: l-1, column: index + lines[l-1].length + newlineLength};\r\n    };\r\n\r\n    /**\r\n     * Converts the `{row, column}` position in a document to the character's index.\r\n     *\r\n     * Index refers to the \"absolute position\" of a character in the document. For example:\r\n     *\r\n     * ```javascript\r\n     * var x = 0; // 10 characters, plus one for newline\r\n     * var y = -1;\r\n     * ```\r\n     * \r\n     * Here, `y` is an index 15: 11 characters for the first row, and 5 characters until `y` in the second.\r\n     *\r\n     * @param {Object} pos The `{row, column}` to convert\r\n     * @param {Number} startRow=0 The row from which to start the conversion\r\n     * @returns {Number} The index position in the document\r\n     */\r\n    this.positionToIndex = function(pos, startRow) {\r\n        var lines = this.$lines || this.getAllLines();\r\n        var newlineLength = this.getNewLineCharacter().length;\r\n        var index = 0;\r\n        var row = Math.min(pos.row, lines.length);\r\n        for (var i = startRow || 0; i < row; ++i)\r\n            index += lines[i].length + newlineLength;\r\n\r\n        return index + pos.column;\r\n    };\r\n\r\n}).call(Document.prototype);\r\n\r\nexports.Document = Document;\r\n});\r\n"]}