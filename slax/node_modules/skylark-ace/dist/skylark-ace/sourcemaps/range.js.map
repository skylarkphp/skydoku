{"version":3,"sources":["range.js"],"names":["define","require","exports","module","Range","startRow","startColumn","endRow","endColumn","this","start","row","column","end","isEqual","range","toString","contains","compare","compareRange","cmp","comparePoint","p","containsRange","intersects","isEnd","isStart","setStart","setEnd","inside","insideStart","insideEnd","isMultiLine","compareStart","compareEnd","compareInside","clipRows","firstRow","lastRow","fromPoints","extend","isEmpty","clone","collapseRows","Math","max","toScreenRange","session","screenPosStart","documentToScreenPosition","screenPosEnd","moveBy","call","prototype","comparePoints","p1","p2"],"mappings":"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","file":"../range.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\n\"use strict\";\r\nvar comparePoints = function(p1, p2) {\r\n    return p1.row - p2.row || p1.column - p2.column;\r\n};\r\n/**\r\n * This object is used in various places to indicate a region within the editor. To better visualize how this works, imagine a rectangle. Each quadrant of the rectangle is analogous to a range, as ranges contain a starting row and starting column, and an ending row, and ending column.\r\n * @class Range\r\n **/\r\n\r\n/**\r\n * Creates a new `Range` object with the given starting and ending row and column points.\r\n * @param {Number} startRow The starting row\r\n * @param {Number} startColumn The starting column\r\n * @param {Number} endRow The ending row\r\n * @param {Number} endColumn The ending column\r\n *\r\n * @constructor\r\n **/\r\nvar Range = function(startRow, startColumn, endRow, endColumn) {\r\n    this.start = {\r\n        row: startRow,\r\n        column: startColumn\r\n    };\r\n\r\n    this.end = {\r\n        row: endRow,\r\n        column: endColumn\r\n    };\r\n};\r\n\r\n(function() {\r\n    /**\r\n     * Returns `true` if and only if the starting row and column, and ending row and column, are equivalent to those given by `range`.\r\n     * @param {Range} range A range to check against\r\n     *\r\n     * @return {Boolean}\r\n     **/\r\n    this.isEqual = function(range) {\r\n        return this.start.row === range.start.row &&\r\n            this.end.row === range.end.row &&\r\n            this.start.column === range.start.column &&\r\n            this.end.column === range.end.column;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Returns a string containing the range's row and column information, given like this:\r\n     * ```\r\n     *    [start.row/start.column] -> [end.row/end.column]\r\n     * ```\r\n     * @return {String}\r\n     **/\r\n    this.toString = function() {\r\n        return (\"Range: [\" + this.start.row + \"/\" + this.start.column +\r\n            \"] -> [\" + this.end.row + \"/\" + this.end.column + \"]\");\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Returns `true` if the `row` and `column` provided are within the given range. This can better be expressed as returning `true` if:\r\n     * ```javascript\r\n     *    this.start.row <= row <= this.end.row &&\r\n     *    this.start.column <= column <= this.end.column\r\n     * ```\r\n     * @param {Number} row A row to check for\r\n     * @param {Number} column A column to check for\r\n     * @returns {Boolean}\r\n     * @related Range.compare\r\n     **/\r\n\r\n    this.contains = function(row, column) {\r\n        return this.compare(row, column) == 0;\r\n    };\r\n\r\n    /**\r\n     * Compares `this` range (A) with another range (B).\r\n     * @param {Range} range A range to compare with\r\n     *\r\n     * @related Range.compare\r\n     * @returns {Number} This method returns one of the following numbers:<br/>\r\n     * <br/>\r\n     * * `-2`: (B) is in front of (A), and doesn't intersect with (A)<br/>\r\n     * * `-1`: (B) begins before (A) but ends inside of (A)<br/>\r\n     * * `0`: (B) is completely inside of (A) OR (A) is completely inside of (B)<br/>\r\n     * * `+1`: (B) begins inside of (A) but ends outside of (A)<br/>\r\n     * * `+2`: (B) is after (A) and doesn't intersect with (A)<br/>\r\n     * * `42`: FTW state: (B) ends in (A) but starts outside of (A)\r\n     **/\r\n    this.compareRange = function(range) {\r\n        var cmp,\r\n            end = range.end,\r\n            start = range.start;\r\n\r\n        cmp = this.compare(end.row, end.column);\r\n        if (cmp == 1) {\r\n            cmp = this.compare(start.row, start.column);\r\n            if (cmp == 1) {\r\n                return 2;\r\n            } else if (cmp == 0) {\r\n                return 1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        } else if (cmp == -1) {\r\n            return -2;\r\n        } else {\r\n            cmp = this.compare(start.row, start.column);\r\n            if (cmp == -1) {\r\n                return -1;\r\n            } else if (cmp == 1) {\r\n                return 42;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks the row and column points of `p` with the row and column points of the calling range.\r\n     *\r\n     * @param {Range} p A point to compare with\r\n     *\r\n     * @related Range.compare\r\n     * @returns {Number} This method returns one of the following numbers:<br/>\r\n     * * `0` if the two points are exactly equal<br/>\r\n     * * `-1` if `p.row` is less then the calling range<br/>\r\n     * * `1` if `p.row` is greater than the calling range<br/>\r\n     * <br/>\r\n     * If the starting row of the calling range is equal to `p.row`, and:<br/>\r\n     * * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>\r\n     * * Otherwise, it returns -1<br/>\r\n     *<br/>\r\n     * If the ending row of the calling range is equal to `p.row`, and:<br/>\r\n     * * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>\r\n     * * Otherwise, it returns 1<br/>\r\n     **/\r\n    this.comparePoint = function(p) {\r\n        return this.compare(p.row, p.column);\r\n    };\r\n\r\n    /**\r\n     * Checks the start and end points of `range` and compares them to the calling range. Returns `true` if the `range` is contained within the caller's range.\r\n     * @param {Range} range A range to compare with\r\n     *\r\n     * @returns {Boolean}\r\n     * @related Range.comparePoint\r\n     **/\r\n    this.containsRange = function(range) {\r\n        return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if passed in `range` intersects with the one calling this method.\r\n     * @param {Range} range A range to compare with\r\n     *\r\n     * @returns {Boolean}\r\n     **/\r\n    this.intersects = function(range) {\r\n        var cmp = this.compareRange(range);\r\n        return (cmp == -1 || cmp == 0 || cmp == 1);\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the caller's ending row point is the same as `row`, and if the caller's ending column is the same as `column`.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     * @returns {Boolean}\r\n     **/\r\n    this.isEnd = function(row, column) {\r\n        return this.end.row == row && this.end.column == column;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the caller's starting row point is the same as `row`, and if the caller's starting column is the same as `column`.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     * @returns {Boolean}\r\n     **/\r\n    this.isStart = function(row, column) {\r\n        return this.start.row == row && this.start.column == column;\r\n    };\r\n\r\n    /**\r\n     * Sets the starting row and column for the range.\r\n     * @param {Number} row A row point to set\r\n     * @param {Number} column A column point to set\r\n     *\r\n     **/\r\n    this.setStart = function(row, column) {\r\n        if (typeof row == \"object\") {\r\n            this.start.column = row.column;\r\n            this.start.row = row.row;\r\n        } else {\r\n            this.start.row = row;\r\n            this.start.column = column;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the starting row and column for the range.\r\n     * @param {Number} row A row point to set\r\n     * @param {Number} column A column point to set\r\n     *\r\n     **/\r\n    this.setEnd = function(row, column) {\r\n        if (typeof row == \"object\") {\r\n            this.end.column = row.column;\r\n            this.end.row = row.row;\r\n        } else {\r\n            this.end.row = row;\r\n            this.end.column = column;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the `row` and `column` are within the given range.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     *\r\n     * @returns {Boolean}\r\n     * @related Range.compare\r\n     **/\r\n    this.inside = function(row, column) {\r\n        if (this.compare(row, column) == 0) {\r\n            if (this.isEnd(row, column) || this.isStart(row, column)) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the `row` and `column` are within the given range's starting points.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     * @returns {Boolean}\r\n     * @related Range.compare\r\n     **/\r\n    this.insideStart = function(row, column) {\r\n        if (this.compare(row, column) == 0) {\r\n            if (this.isEnd(row, column)) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Returns `true` if the `row` and `column` are within the given range's ending points.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     * @returns {Boolean}\r\n     * @related Range.compare\r\n     *\r\n     **/\r\n    this.insideEnd = function(row, column) {\r\n        if (this.compare(row, column) == 0) {\r\n            if (this.isStart(row, column)) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Checks the row and column points with the row and column points of the calling range.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     *\r\n     * @returns {Number} This method returns one of the following numbers:<br/>\r\n     * `0` if the two points are exactly equal <br/>\r\n     * `-1` if `p.row` is less then the calling range <br/>\r\n     * `1` if `p.row` is greater than the calling range <br/>\r\n     *  <br/>\r\n     * If the starting row of the calling range is equal to `p.row`, and: <br/>\r\n     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>\r\n     * Otherwise, it returns -1<br/>\r\n     * <br/>\r\n     * If the ending row of the calling range is equal to `p.row`, and: <br/>\r\n     * `p.column` is less than or equal to the calling range's ending column, this returns `0` <br/>\r\n     * Otherwise, it returns 1\r\n     **/\r\n    this.compare = function(row, column) {\r\n        if (!this.isMultiLine()) {\r\n            if (row === this.start.row) {\r\n                return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);\r\n            }\r\n        }\r\n\r\n        if (row < this.start.row)\r\n            return -1;\r\n\r\n        if (row > this.end.row)\r\n            return 1;\r\n\r\n        if (this.start.row === row)\r\n            return column >= this.start.column ? 0 : -1;\r\n\r\n        if (this.end.row === row)\r\n            return column <= this.end.column ? 0 : 1;\r\n\r\n        return 0;\r\n    };\r\n\r\n    /**\r\n     * Checks the row and column points with the row and column points of the calling range.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     * @returns {Number} This method returns one of the following numbers:<br/>\r\n     * <br/>\r\n     * `0` if the two points are exactly equal<br/>\r\n     * `-1` if `p.row` is less then the calling range<br/>\r\n     * `1` if `p.row` is greater than the calling range, or if `isStart` is `true`.<br/>\r\n     * <br/>\r\n     * If the starting row of the calling range is equal to `p.row`, and:<br/>\r\n     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>\r\n     * Otherwise, it returns -1<br/>\r\n     * <br/>\r\n     * If the ending row of the calling range is equal to `p.row`, and:<br/>\r\n     * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>\r\n     * Otherwise, it returns 1\r\n     *\r\n     **/\r\n    this.compareStart = function(row, column) {\r\n        if (this.start.row == row && this.start.column == column) {\r\n            return -1;\r\n        } else {\r\n            return this.compare(row, column);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks the row and column points with the row and column points of the calling range.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     *\r\n     * @returns {Number} This method returns one of the following numbers:<br/>\r\n     * `0` if the two points are exactly equal<br/>\r\n     * `-1` if `p.row` is less then the calling range<br/>\r\n     * `1` if `p.row` is greater than the calling range, or if `isEnd` is `true.<br/>\r\n     * <br/>\r\n     * If the starting row of the calling range is equal to `p.row`, and:<br/>\r\n     * `p.column` is greater than or equal to the calling range's starting column, this returns `0`<br/>\r\n     * Otherwise, it returns -1<br/>\r\n     *<br/>\r\n     * If the ending row of the calling range is equal to `p.row`, and:<br/>\r\n     * `p.column` is less than or equal to the calling range's ending column, this returns `0`<br/>\r\n     * Otherwise, it returns 1\r\n     */\r\n    this.compareEnd = function(row, column) {\r\n        if (this.end.row == row && this.end.column == column) {\r\n            return 1;\r\n        } else {\r\n            return this.compare(row, column);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks the row and column points with the row and column points of the calling range.\r\n     * @param {Number} row A row point to compare with\r\n     * @param {Number} column A column point to compare with\r\n     *\r\n     *\r\n     * @returns {Number} This method returns one of the following numbers:<br/>\r\n     * * `1` if the ending row of the calling range is equal to `row`, and the ending column of the calling range is equal to `column`<br/>\r\n     * * `-1` if the starting row of the calling range is equal to `row`, and the starting column of the calling range is equal to `column`<br/>\r\n     * <br/>\r\n     * Otherwise, it returns the value after calling [[Range.compare `compare()`]].\r\n     *\r\n     **/\r\n    this.compareInside = function(row, column) {\r\n        if (this.end.row == row && this.end.column == column) {\r\n            return 1;\r\n        } else if (this.start.row == row && this.start.column == column) {\r\n            return -1;\r\n        } else {\r\n            return this.compare(row, column);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the part of the current `Range` that occurs within the boundaries of `firstRow` and `lastRow` as a new `Range` object.\r\n     * @param {Number} firstRow The starting row\r\n     * @param {Number} lastRow The ending row\r\n     *\r\n     *\r\n     * @returns {Range}\r\n    **/\r\n    this.clipRows = function(firstRow, lastRow) {\r\n        if (this.end.row > lastRow)\r\n            var end = {row: lastRow + 1, column: 0};\r\n        else if (this.end.row < firstRow)\r\n            var end = {row: firstRow, column: 0};\r\n\r\n        if (this.start.row > lastRow)\r\n            var start = {row: lastRow + 1, column: 0};\r\n        else if (this.start.row < firstRow)\r\n            var start = {row: firstRow, column: 0};\r\n\r\n        return Range.fromPoints(start || this.start, end || this.end);\r\n    };\r\n\r\n    /**\r\n     * Changes the row and column points for the calling range for both the starting and ending points.\r\n     * @param {Number} row A new row to extend to\r\n     * @param {Number} column A new column to extend to\r\n     *\r\n     *\r\n     * @returns {Range} The original range with the new row\r\n    **/\r\n    this.extend = function(row, column) {\r\n        var cmp = this.compare(row, column);\r\n\r\n        if (cmp == 0)\r\n            return this;\r\n        else if (cmp == -1)\r\n            var start = {row: row, column: column};\r\n        else\r\n            var end = {row: row, column: column};\r\n\r\n        return Range.fromPoints(start || this.start, end || this.end);\r\n    };\r\n\r\n    this.isEmpty = function() {\r\n        return (this.start.row === this.end.row && this.start.column === this.end.column);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Returns `true` if the range spans across multiple lines.\r\n     * @returns {Boolean}\r\n    **/\r\n    this.isMultiLine = function() {\r\n        return (this.start.row !== this.end.row);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Returns a duplicate of the calling range.\r\n     * @returns {Range}\r\n    **/\r\n    this.clone = function() {\r\n        return Range.fromPoints(this.start, this.end);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Returns a range containing the starting and ending rows of the original range, but with a column value of `0`.\r\n     * @returns {Range}\r\n    **/\r\n    this.collapseRows = function() {\r\n        if (this.end.column == 0)\r\n            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row-1), 0);\r\n        else\r\n            return new Range(this.start.row, 0, this.end.row, 0);\r\n    };\r\n\r\n    /**\r\n     * Given the current `Range`, this function converts those starting and ending points into screen positions, and then returns a new `Range` object.\r\n     * @param {EditSession} session The `EditSession` to retrieve coordinates from\r\n     *\r\n     *\r\n     * @returns {Range}\r\n    **/\r\n    this.toScreenRange = function(session) {\r\n        var screenPosStart = session.documentToScreenPosition(this.start);\r\n        var screenPosEnd = session.documentToScreenPosition(this.end);\r\n\r\n        return new Range(\r\n            screenPosStart.row, screenPosStart.column,\r\n            screenPosEnd.row, screenPosEnd.column\r\n        );\r\n    };\r\n    \r\n    \r\n    /* experimental */\r\n    this.moveBy = function(row, column) {\r\n        this.start.row += row;\r\n        this.start.column += column;\r\n        this.end.row += row;\r\n        this.end.column += column;\r\n    };\r\n\r\n}).call(Range.prototype);\r\n\r\n/**\r\n * Creates and returns a new `Range` based on the row and column of the given parameters.\r\n * @param {Range} start A starting point to use\r\n * @param {Range} end An ending point to use\r\n *\r\n * @returns {Range}\r\n**/\r\nRange.fromPoints = function(start, end) {\r\n    return new Range(start.row, start.column, end.row, end.column);\r\n};\r\nRange.comparePoints = comparePoints;\r\n\r\nRange.comparePoints = function(p1, p2) {\r\n    return p1.row - p2.row || p1.column - p2.column;\r\n};\r\n\r\n\r\nexports.Range = Range;\r\n});\r\n"]}