{"version":3,"sources":["tokenizer_dev.js"],"names":["define","require","exports","module","BaseTokenizer","Tokenizer","rules","call","this","getLineTokens","line","startState","stack","slice","currentState","state","states","mapping","matchMappings","re","regExps","lastIndex","match","tokens","stateTransitions","onStateChange","push","token","type","value","maxRecur","exec","defaultToken","rule","index","length","skipped","substring","i","undefined","onMatch","next","window","console","error","consumeLineEnd","merge","substr","prototype"],"mappings":";;;;;;;AA8BAA,OAAO,SAASC,EAASC,EAASC,GAClC,IAAIC,EAAgBH,EAAQ,eAAeI,UAUvCA,EAAY,SAASC,GACrBF,EAAcG,KAAKC,KAAMF,GAMzBE,KAAKC,cAAgB,SAASC,EAAMC,GAChC,GAAIA,GAAmC,iBAAdA,EAAwB,CAC7C,IAAIC,EAAQD,EAAWE,MAAM,GAC7BF,EAAaC,EAAM,QAEfA,KAER,IAAIE,EAAeH,GAAc,QAC7BI,EAAQP,KAAKQ,OAAOF,GACpBG,EAAUT,KAAKU,cAAcJ,GAC7BK,EAAKX,KAAKY,QAAQN,GACtBK,EAAGE,UAAY,EAEf,IAAIC,EAAOC,KAEPF,EAAY,EAEZG,KACJ,SAASC,IACLD,EAAiBE,KAAKf,EAAW,IAAIU,GAQzC,IAAIM,GACAC,KAAM,KACNC,MAAO,GACPd,MAAOD,GARPW,IACAD,KACAC,IAYJ,IAFA,IAAIK,EAAW,IAERR,EAAQH,EAAGY,KAAKrB,IAAO,CAC1B,IAAIkB,EAAOX,EAAQe,aACfC,EAAO,KACPJ,EAAQP,EAAM,GACdY,EAAQf,EAAGE,UAEf,GAAIa,EAAQL,EAAMM,OAASd,EAAW,CAClC,IAAIe,EAAU1B,EAAK2B,UAAUhB,EAAWa,EAAQL,EAAMM,QAClDR,EAAMC,MAAQA,EACdD,EAAME,OAASO,GAEXT,EAAMC,MACNL,EAAOG,KAAKC,GAChBA,GAASC,KAAMA,EAAMC,MAAOO,IAIpC,IAAK,IAAIE,EAAI,EAAGA,EAAIhB,EAAMa,OAAO,EAAGG,IAChC,QAAqBC,IAAjBjB,EAAMgB,EAAI,GAAd,CAGA,IAAKR,IACD,KAAM,WAAaf,EAAME,EAAQqB,IAAMxB,EAMvCc,GAHJK,EAAOlB,EAAME,EAAQqB,KAEZE,QACEP,EAAKO,QAAQX,EAAOf,EAAcF,EAAOF,GAEzCuB,EAAKN,MAEZM,EAAKQ,OAED3B,EADoB,iBAAbmB,EAAKQ,KACGR,EAAKQ,KAELR,EAAKQ,KAAK3B,EAAcF,IAE3CG,EAAQP,KAAKQ,OAAOF,MAEhB4B,OAAOC,SAAWA,QAAQC,OAASD,QAAQC,MAAM9B,EAAc,iBAC/DA,EAAe,QACfC,EAAQP,KAAKQ,OAAOF,IAExBG,EAAUT,KAAKU,cAAcJ,GAC7BO,EAAYa,GACZf,EAAKX,KAAKY,QAAQN,IACfO,UAAYa,EAEfT,KAEAQ,EAAKY,iBACLxB,EAAYa,GAChB,MAGJ,GAAIL,EACA,GAAmB,iBAARD,EACDK,IAAuB,IAAfA,EAAKa,OAAoBnB,EAAMC,OAASA,GAG9CD,EAAMC,MACNL,EAAOG,KAAKC,GAChBA,GAASC,KAAMA,EAAMC,MAAOA,IAJ5BF,EAAME,OAASA,MAMhB,CACCF,EAAMC,MACNL,EAAOG,KAAKC,GAChBA,GAASC,KAAM,KAAMC,MAAO,IAC5B,IAASS,EAAI,EAAGA,EAAIV,EAAKO,OAAQG,IAC7Bf,EAAOG,KAAKE,EAAKU,IAI7B,GAAIjB,GAAaX,EAAKyB,OAClB,MAIJ,GAFAd,EAAYa,EAERX,EAAOY,OAjID,IAiI2B,CACjCR,EAAME,OAASnB,EAAKqC,OAAO1B,GAC3BP,EAAe,QACf,OAOR,OAHIa,EAAMC,MACNL,EAAOG,KAAKC,IAGZJ,OAASA,EACTR,MAAQH,EAAMuB,OAASvB,EAAQE,KAM3CT,EAAU2C,UAAY5C,EAAc4C,UAEpC9C,EAAQG,UAAYA","file":"../tokenizer_dev.js","sourcesContent":["/* ***** BEGIN LICENSE BLOCK *****\r\n * Distributed under the BSD license:\r\n *\r\n * Copyright (c) 2010, Ajax.org B.V.\r\n * All rights reserved.\r\n * \r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of Ajax.org B.V. nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * ***** END LICENSE BLOCK ***** */\r\n\r\ndefine(function(require, exports, module) {\r\nvar BaseTokenizer = require(\"./tokenizer\").Tokenizer;\r\n\r\n// tokenizing lines longer than this makes editor very slow\r\nvar MAX_TOKEN_COUNT = 2000;\r\n/*\r\n * version of Tokenizer with additional logging\r\n * and infinite loop checks\r\n * can be used for developing/testing new modes\r\n **/\r\n\r\nvar Tokenizer = function(rules) {\r\n    BaseTokenizer.call(this, rules);\r\n\r\n    /**\r\n     * Returns an object containing two properties: `tokens`, which contains all the tokens; and `state`, the current state.\r\n     * @returns {Object}\r\n     **/\r\n    this.getLineTokens = function(line, startState) {\r\n        if (startState && typeof startState != \"string\") {\r\n            var stack = startState.slice(0);\r\n            startState = stack[0];\r\n        } else\r\n            var stack = [];\r\n\r\n        var currentState = startState || \"start\";\r\n        var state = this.states[currentState];\r\n        var mapping = this.matchMappings[currentState];\r\n        var re = this.regExps[currentState];\r\n        re.lastIndex = 0;\r\n\r\n        var match, tokens = [];\r\n\r\n        var lastIndex = 0;\r\n\r\n        var stateTransitions = [];\r\n        function onStateChange() {\r\n            stateTransitions.push(startState+\"@\"+lastIndex);\r\n        }\r\n        function initState() {\r\n            onStateChange();\r\n            stateTransitions = [];\r\n            onStateChange();\r\n        }\r\n        \r\n        var token = {\r\n            type: null,\r\n            value: \"\",\r\n            state: currentState\r\n        };\r\n        initState();\r\n        \r\n        var maxRecur = 20000;\r\n        \r\n        while (match = re.exec(line)) {\r\n            var type = mapping.defaultToken;\r\n            var rule = null;\r\n            var value = match[0];\r\n            var index = re.lastIndex;\r\n\r\n            if (index - value.length > lastIndex) {\r\n                var skipped = line.substring(lastIndex, index - value.length);\r\n                if (token.type == type) {\r\n                    token.value += skipped;\r\n                } else {\r\n                    if (token.type)\r\n                        tokens.push(token);\r\n                    token = {type: type, value: skipped};\r\n                }\r\n            }\r\n\r\n            for (var i = 0; i < match.length-2; i++) {\r\n                if (match[i + 1] === undefined)\r\n                    continue;\r\n                \r\n                if (!maxRecur--) {\r\n                    throw \"infinite\" + state[mapping[i]] + currentState;\r\n                }\r\n\r\n                rule = state[mapping[i]];\r\n\r\n                if (rule.onMatch)\r\n                    type = rule.onMatch(value, currentState, stack, line);\r\n                else\r\n                    type = rule.token;\r\n\r\n                if (rule.next) {\r\n                    if (typeof rule.next == \"string\")\r\n                        currentState = rule.next;\r\n                    else\r\n                        currentState = rule.next(currentState, stack);\r\n\r\n                    state = this.states[currentState];\r\n                    if (!state) {\r\n                        window.console && console.error && console.error(currentState, \"doesn't exist\");\r\n                        currentState = \"start\";\r\n                        state = this.states[currentState];\r\n                    }\r\n                    mapping = this.matchMappings[currentState];\r\n                    lastIndex = index;\r\n                    re = this.regExps[currentState];\r\n                    re.lastIndex = index;\r\n\r\n                    onStateChange();\r\n                }\r\n                if (rule.consumeLineEnd)\r\n                    lastIndex = index;\r\n                break;\r\n            }\r\n\r\n            if (value) {\r\n                if (typeof type == \"string\") {\r\n                    if ((!rule || rule.merge !== false) && token.type === type) {\r\n                        token.value += value;\r\n                    } else {\r\n                        if (token.type)\r\n                            tokens.push(token);\r\n                        token = {type: type, value: value};\r\n                    }\r\n                } else {\r\n                    if (token.type)\r\n                        tokens.push(token);\r\n                    token = {type: null, value: \"\"};\r\n                    for (var i = 0; i < type.length; i++)\r\n                        tokens.push(type[i]);\r\n                }\r\n            }\r\n\r\n            if (lastIndex == line.length)\r\n                break;\r\n\r\n            lastIndex = index;\r\n\r\n            if (tokens.length > MAX_TOKEN_COUNT) {\r\n                token.value += line.substr(lastIndex);\r\n                currentState = \"start\";\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (token.type)\r\n            tokens.push(token);\r\n\r\n        return {\r\n            tokens : tokens,\r\n            state : stack.length ? stack : currentState\r\n        };\r\n    };\r\n\r\n};\r\n\r\nTokenizer.prototype = BaseTokenizer.prototype;\r\n\r\nexports.Tokenizer = Tokenizer;\r\n});\r\n"]}