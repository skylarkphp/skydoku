{"version":3,"sources":["deserialize.js"],"names":["define","langx","$","forms","updateKeyValueArray","prop","value","obj","current","undefined","push","updateTypes","checked","selected","update","element","elementIndex","valueIndex","callback","property","type","nodeName","toLowerCase","getElementType","elementProperty","each","types","inArray","getPropertyToUpdate","call","fields","options","index","option","multiple","selectedIndex","field","defaultOptions","change","noop","complete","deserialize","formElm","data","isFunction","extend","normalized","rPlus","isPlainObject","name","isArray","split","decodeURIComponent","replace","normalizeData","elementsByName","filter","map","this","elements","makeArray","get","getFieldsByName","values"],"mappings":"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","file":"../deserialize.js","sourcesContent":["define([\r\n  \"skylark-langx/langx\",\r\n  \"skylark-domx-query\",\r\n  \"./forms\"\r\n],function(langx,$,forms){\r\n  /**\r\n   * Updates a key/valueArray with the given property and value. Values will always be stored as arrays.\r\n   *\r\n   * @param prop The property to add the value to.\r\n   * @param value The value to add.\r\n   * @param obj The object to update.\r\n   * @returns {object} Updated object.\r\n   */\r\n  function updateKeyValueArray( prop, value, obj ) {\r\n    var current = obj[ prop ];\r\n\r\n    if ( current === undefined ) {\r\n      obj[ prop ] = [ value ];\r\n    } else {\r\n      current.push( value );\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * Get all of the fields contained within the given elements by name.\r\n   *\r\n   * @param formElm The form element.\r\n   * @param filter Custom filter to apply to the list of fields.\r\n   * @returns {object} All of the fields contained within the given elements, keyed by name.\r\n   */\r\n  function getFieldsByName(formElm, filter ) {\r\n    var elementsByName = {};\r\n\r\n    // Extract fields from elements\r\n    var fields = $(formElm)\r\n      .map(function convertFormToElements() {\r\n        return this.elements ? langx.makeArray( this.elements ) : this;\r\n      })\r\n      .filter( filter || \":input:not(:disabled)\" )\r\n      .get();\r\n\r\n    langx.each( fields, function( index, field ) {\r\n      updateKeyValueArray( field.name, field, elementsByName );\r\n    });\r\n\r\n    return elementsByName;\r\n  }\r\n\r\n  /**\r\n   * Figure out the type of an element. Input type will be used first, falling back to nodeName.\r\n   *\r\n   * @param element DOM element to check type of.\r\n   * @returns {string} The element's type.\r\n   */\r\n  function getElementType( element ) {\r\n    return ( element.type || element.nodeName ).toLowerCase();\r\n  }\r\n\r\n  /**\r\n   * Normalize the provided data into a key/valueArray store.\r\n   *\r\n   * @param data The data provided by the user to the plugin.\r\n   * @returns {object} The data normalized into a key/valueArray store.\r\n   */\r\n  function normalizeData( data ) {\r\n    var normalized = {};\r\n    var rPlus = /\\+/g;\r\n\r\n    // Convert data from .serializeObject() notation\r\n    if ( langx.isPlainObject( data ) ) {\r\n      langx.extend( normalized, data );\r\n\r\n      // Convert non-array values into an array\r\n      langx.each( normalized, function( name, value ) {\r\n        if ( !langx.isArray( value ) ) {\r\n          normalized[ name ] = [ value ];\r\n        }\r\n      });\r\n\r\n    // Convert data from .serializeArray() notation\r\n    } else if ( langx.isArray( data ) ) {\r\n      langx.each( data, function( index, field ) {\r\n        updateKeyValueArray( field.name, field.value, normalized );\r\n      });\r\n\r\n    // Convert data from .serialize() notation\r\n    } else if ( typeof data === \"string\" ) {\r\n      langx.each( data.split( \"&\" ), function( index, field ) {\r\n        var current = field.split( \"=\" );\r\n        var name = decodeURIComponent( current[ 0 ].replace( rPlus, \"%20\" ) );\r\n        var value = decodeURIComponent( current[ 1 ].replace( rPlus, \"%20\" ) );\r\n        updateKeyValueArray( name, value, normalized );\r\n      });\r\n    }\r\n\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Map of property name -> element types.\r\n   *\r\n   * @type {object}\r\n   */\r\n  var updateTypes = {\r\n    checked: [\r\n      \"radio\",\r\n      \"checkbox\"\r\n    ],\r\n    selected: [\r\n      \"option\",\r\n      \"select-one\",\r\n      \"select-multiple\"\r\n    ],\r\n    value: [\r\n      \"button\",\r\n      \"color\",\r\n      \"date\",\r\n      \"datetime\",\r\n      \"datetime-local\",\r\n      \"email\",\r\n      \"hidden\",\r\n      \"month\",\r\n      \"number\",\r\n      \"password\",\r\n      \"range\",\r\n      \"reset\",\r\n      \"search\",\r\n      \"submit\",\r\n      \"tel\",\r\n      \"text\",\r\n      \"textarea\",\r\n      \"time\",\r\n      \"url\",\r\n      \"week\"\r\n    ]\r\n  };\r\n\r\n  /**\r\n   * Get the property to update on an element being updated.\r\n   *\r\n   * @param element The DOM element to get the property for.\r\n   * @returns The name of the property to update if element is supported, otherwise `undefined`.\r\n   */\r\n  function getPropertyToUpdate( element ) {\r\n    var type = getElementType( element );\r\n    var elementProperty = undefined;\r\n\r\n    langx.each( updateTypes, function( property, types ) {\r\n      if ( langx.inArray( type, types ) > -1 ) {\r\n        elementProperty = property;\r\n        return false;\r\n      }\r\n    });\r\n\r\n    return elementProperty;\r\n  }\r\n\r\n  /**\r\n   * Update the element based on the provided data.\r\n   *\r\n   * @param element The DOM element to update.\r\n   * @param elementIndex The index of this element in the list of elements with the same name.\r\n   * @param value The serialized element value.\r\n   * @param valueIndex The index of the value in the list of values for elements with the same name.\r\n   * @param callback A function to call if the value of an element was updated.\r\n   */\r\n  function update( element, elementIndex, value, valueIndex, callback ) {\r\n    var property = getPropertyToUpdate( element );\r\n\r\n    // Handle value inputs\r\n    // If there are multiple value inputs with the same name, they will be populated by matching indexes.\r\n    if ( property == \"value\" && elementIndex == valueIndex ) {\r\n      element.value = value;\r\n      callback.call( element, value );\r\n\r\n    // Handle select menus, checkboxes and radio buttons\r\n    } else if ( property == \"checked\" || property == \"selected\" ) {\r\n      var fields = [];\r\n\r\n      // Extract option fields from select menus\r\n      if ( element.options ) {\r\n        langx.each( element.options, function( index, option ) {\r\n          fields.push( option );\r\n        });\r\n\r\n      } else {\r\n        fields.push( element );\r\n      }\r\n\r\n      // #37: Remove selection from multiple select menus before deserialization\r\n      if ( element.multiple && valueIndex == 0 ) {\r\n        element.selectedIndex = -1;\r\n      }\r\n\r\n      langx.each( fields, function( index, field ) {\r\n        if ( field.value == value ) {\r\n          field[ property ] = true;\r\n          callback.call( field, value );\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Default plugin options.\r\n   *\r\n   * @type {object}\r\n   */\r\n  var defaultOptions = {\r\n    change: langx.noop,\r\n    complete: langx.noop\r\n  };\r\n\r\n  /**\r\n   * The $.deserialize function.\r\n   *\r\n   * @param data The data to deserialize.\r\n   * @param options Additional options.\r\n   * @returns {jQuery} The jQuery object that was provided to the plugin.\r\n   */\r\n  function deserialize(formElm,data, options ) {\r\n\r\n    // Backwards compatible with old arguments: data, callback\r\n    if ( langx.isFunction( options ) ) {\r\n      options = { complete: options };\r\n    }\r\n\r\n    options = langx.extend( defaultOptions, options || {} );\r\n    data = normalizeData( data );\r\n\r\n    var elementsByName = getFieldsByName( formElm, options.filter );\r\n\r\n    langx.each( data, function( name, values ) {\r\n      langx.each( elementsByName[ name ], function( elementIndex, element ) {\r\n        langx.each( values, function( valueIndex, value ) {\r\n          update( element, elementIndex, value, valueIndex, options.change );\r\n        });\r\n      });\r\n    });\r\n\r\n    options.complete.call( formElm );\r\n\r\n    return this;\r\n  };\r\n\r\n  return forms.deserialize = deserialize;\r\n});"]}