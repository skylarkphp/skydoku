{"version":3,"sources":["primitives/model/Doc.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","nextDocId","Doc","text","mode","firstLine","lineSep","direction","this","BranchChunk","call","LeafChunk","Line","first","scrollTop","scrollLeft","cantEdit","cleanGeneration","modeFrontier","highlightFrontier","start","Pos","sel","simpleSelection","history","History","id","modeOption","extend","splitLines","updateDoc","from","to","setSelection","sel_dontScroll","prototype","createObj","constructor","iter","op","iterN","size","insert","at","lines","height","length","insertInner","remove","removeInner","getValue","getLines","join","lineSeparator","setValue","docMethodOp","code","top","last","makeChange","getLine","origin","full","cm","scrollToCoords","replaceRange","clipPos","getRange","getBetween","line","getLineHandle","isLine","getLineNumber","lineNo","getLineHandleVisualStart","visualLine","lineCount","lastLine","pos","getCursor","range","primary","head","anchor","listSelections","ranges","somethingSelected","setCursor","ch","options","setSimpleSelection","extendSelection","other","extendSelections","heads","clipPosArray","extendSelectionsBy","map","setSelections","out","Range","Math","min","primIndex","normalizeSelection","addSelection","slice","push","getSelection","concat","getSelections","parts","replaceSelection","collapse","dup","replaceSelections","changes","newSel","computeReplacedSel","setSelectionReplaceHistory","ensureCursorVisible","undo","makeChangeFromHistory","redo","undoSelection","redoSelection","setExtending","val","getExtending","historySize","hist","done","undone","clearHistory","maxGeneration","markClean","changeGeneration","forceSplit","lastOp","lastSelOp","lastOrigin","generation","isClean","gen","getHistory","copyHistoryArray","setHistory","histData","setGutterMarker","gutterID","value","changeLine","markers","gutterMarkers","isEmpty","clearGutter","lineInfo","handle","textClass","bgClass","wrapClass","widgets","addLineClass","where","cls","prop","classTest","test","removeLineClass","cur","found","match","end","index","addLineWidget","node","removeLineWidget","widget","clear","markText","type","setBookmark","realOpts","replacedWith","nodeType","insertLeft","clearWhenEmpty","shared","handleMouseEvents","findMarksAt","spans","markedSpans","span","marker","parent","findMarks","filter","getAllMarks","sps","posFromIndex","off","sepSize","sz","indexFromPos","coords","copy","copyHistory","doc","undoDepth","linkedDoc","sharedHist","linked","isParent","copySharedMarkers","findSharedMarkers","unlinkDoc","splice","detachSharedMarkers","splitIds","linkedDocs","iterLinkedDocs","getMode","getEditor","str","split","splitLinesAuto","setDirection","dir","order","directionChanged","eachLine"],"mappings":"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","file":"../../../primitives/model/Doc.js","sourcesContent":["define([\n    '../display/operations',\n    '../line/line_data',\n    '../line/pos',\n    '../line/spans',\n    '../line/utils_line',\n    '../util/dom',\n    '../util/feature_detection',\n    '../util/misc',\n    '../display/scrolling',\n    './changes',\n    './change_measurement',\n    './chunk',\n    './document_data',\n    './history',\n    './line_widget',\n    './mark_text',\n    './selection',\n    './selection_updates'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {\n    'use strict';\n    let nextDocId = 0;\n    let Doc = function (text, mode, firstLine, lineSep, direction) {\n        if (!(this instanceof Doc))\n            return new Doc(text, mode, firstLine, lineSep, direction);\n        if (firstLine == null)\n            firstLine = 0;\n        l.BranchChunk.call(this, [new l.LeafChunk([new b.Line('', null)])]);\n        this.first = firstLine;\n        this.scrollTop = this.scrollLeft = 0;\n        this.cantEdit = false;\n        this.cleanGeneration = 1;\n        this.modeFrontier = this.highlightFrontier = firstLine;\n        let start = c.Pos(firstLine, 0);\n        this.sel = q.simpleSelection(start);\n        this.history = new n.History(null);\n        this.id = ++nextDocId;\n        this.modeOption = mode;\n        this.lineSep = lineSep;\n        this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\n        this.extend = false;\n        if (typeof text == 'string')\n            text = this.splitLines(text);\n        m.updateDoc(this, {\n            from: start,\n            to: start,\n            text: text\n        });\n        r.setSelection(this, q.simpleSelection(start), h.sel_dontScroll);\n    };\n    Doc.prototype = h.createObj(l.BranchChunk.prototype, {\n        constructor: Doc,\n        iter: function (from, to, op) {\n            if (op)\n                this.iterN(from - this.first, to - from, op);\n            else\n                this.iterN(this.first, this.first + this.size, from);\n        },\n        insert: function (at, lines) {\n            let height = 0;\n            for (let i = 0; i < lines.length; ++i)\n                height += lines[i].height;\n            this.insertInner(at - this.first, lines, height);\n        },\n        remove: function (at, n) {\n            this.removeInner(at - this.first, n);\n        },\n        getValue: function (lineSep) {\n            let lines = e.getLines(this, this.first, this.first + this.size);\n            if (lineSep === false)\n                return lines;\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        setValue: a.docMethodOp(function (code) {\n            let top = c.Pos(this.first, 0), last = this.first + this.size - 1;\n            j.makeChange(this, {\n                from: top,\n                to: c.Pos(last, e.getLine(this, last).text.length),\n                text: this.splitLines(code),\n                origin: 'setValue',\n                full: true\n            }, true);\n            if (this.cm)\n                i.scrollToCoords(this.cm, 0, 0);\n            r.setSelection(this, q.simpleSelection(top), h.sel_dontScroll);\n        }),\n        replaceRange: function (code, from, to, origin) {\n            from = c.clipPos(this, from);\n            to = to ? c.clipPos(this, to) : from;\n            j.replaceRange(this, code, from, to, origin);\n        },\n        getRange: function (from, to, lineSep) {\n            let lines = e.getBetween(this, c.clipPos(this, from), c.clipPos(this, to));\n            if (lineSep === false)\n                return lines;\n            return lines.join(lineSep || this.lineSeparator());\n        },\n        getLine: function (line) {\n            let l = this.getLineHandle(line);\n            return l && l.text;\n        },\n        getLineHandle: function (line) {\n            if (e.isLine(this, line))\n                return e.getLine(this, line);\n        },\n        getLineNumber: function (line) {\n            return e.lineNo(line);\n        },\n        getLineHandleVisualStart: function (line) {\n            if (typeof line == 'number')\n                line = e.getLine(this, line);\n            return d.visualLine(line);\n        },\n        lineCount: function () {\n            return this.size;\n        },\n        firstLine: function () {\n            return this.first;\n        },\n        lastLine: function () {\n            return this.first + this.size - 1;\n        },\n        clipPos: function (pos) {\n            return c.clipPos(this, pos);\n        },\n        getCursor: function (start) {\n            let range = this.sel.primary(), pos;\n            if (start == null || start == 'head')\n                pos = range.head;\n            else if (start == 'anchor')\n                pos = range.anchor;\n            else if (start == 'end' || start == 'to' || start === false)\n                pos = range.to();\n            else\n                pos = range.from();\n            return pos;\n        },\n        listSelections: function () {\n            return this.sel.ranges;\n        },\n        somethingSelected: function () {\n            return this.sel.somethingSelected();\n        },\n        setCursor: a.docMethodOp(function (line, ch, options) {\n            r.setSimpleSelection(this, c.clipPos(this, typeof line == 'number' ? c.Pos(line, ch || 0) : line), null, options);\n        }),\n        setSelection: a.docMethodOp(function (anchor, head, options) {\n            r.setSimpleSelection(this, c.clipPos(this, anchor), c.clipPos(this, head || anchor), options);\n        }),\n        extendSelection: a.docMethodOp(function (head, other, options) {\n            r.extendSelection(this, c.clipPos(this, head), other && c.clipPos(this, other), options);\n        }),\n        extendSelections: a.docMethodOp(function (heads, options) {\n            r.extendSelections(this, c.clipPosArray(this, heads), options);\n        }),\n        extendSelectionsBy: a.docMethodOp(function (f, options) {\n            let heads = h.map(this.sel.ranges, f);\n            r.extendSelections(this, c.clipPosArray(this, heads), options);\n        }),\n        setSelections: a.docMethodOp(function (ranges, primary, options) {\n            if (!ranges.length)\n                return;\n            let out = [];\n            for (let i = 0; i < ranges.length; i++)\n                out[i] = new q.Range(c.clipPos(this, ranges[i].anchor), c.clipPos(this, ranges[i].head));\n            if (primary == null)\n                primary = Math.min(ranges.length - 1, this.sel.primIndex);\n            r.setSelection(this, q.normalizeSelection(this.cm, out, primary), options);\n        }),\n        addSelection: a.docMethodOp(function (anchor, head, options) {\n            let ranges = this.sel.ranges.slice(0);\n            ranges.push(new q.Range(c.clipPos(this, anchor), c.clipPos(this, head || anchor)));\n            r.setSelection(this, q.normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n        }),\n        getSelection: function (lineSep) {\n            let ranges = this.sel.ranges, lines;\n            for (let i = 0; i < ranges.length; i++) {\n                let sel = e.getBetween(this, ranges[i].from(), ranges[i].to());\n                lines = lines ? lines.concat(sel) : sel;\n            }\n            if (lineSep === false)\n                return lines;\n            else\n                return lines.join(lineSep || this.lineSeparator());\n        },\n        getSelections: function (lineSep) {\n            let parts = [], ranges = this.sel.ranges;\n            for (let i = 0; i < ranges.length; i++) {\n                let sel = e.getBetween(this, ranges[i].from(), ranges[i].to());\n                if (lineSep !== false)\n                    sel = sel.join(lineSep || this.lineSeparator());\n                parts[i] = sel;\n            }\n            return parts;\n        },\n        replaceSelection: function (code, collapse, origin) {\n            let dup = [];\n            for (let i = 0; i < this.sel.ranges.length; i++)\n                dup[i] = code;\n            this.replaceSelections(dup, collapse, origin || '+input');\n        },\n        replaceSelections: a.docMethodOp(function (code, collapse, origin) {\n            let changes = [], sel = this.sel;\n            for (let i = 0; i < sel.ranges.length; i++) {\n                let range = sel.ranges[i];\n                changes[i] = {\n                    from: range.from(),\n                    to: range.to(),\n                    text: this.splitLines(code[i]),\n                    origin: origin\n                };\n            }\n            let newSel = collapse && collapse != 'end' && k.computeReplacedSel(this, changes, collapse);\n            for (let i = changes.length - 1; i >= 0; i--)\n                j.makeChange(this, changes[i]);\n            if (newSel)\n                r.setSelectionReplaceHistory(this, newSel);\n            else if (this.cm)\n                i.ensureCursorVisible(this.cm);\n        }),\n        undo: a.docMethodOp(function () {\n            j.makeChangeFromHistory(this, 'undo');\n        }),\n        redo: a.docMethodOp(function () {\n            j.makeChangeFromHistory(this, 'redo');\n        }),\n        undoSelection: a.docMethodOp(function () {\n            j.makeChangeFromHistory(this, 'undo', true);\n        }),\n        redoSelection: a.docMethodOp(function () {\n            j.makeChangeFromHistory(this, 'redo', true);\n        }),\n        setExtending: function (val) {\n            this.extend = val;\n        },\n        getExtending: function () {\n            return this.extend;\n        },\n        historySize: function () {\n            let hist = this.history, done = 0, undone = 0;\n            for (let i = 0; i < hist.done.length; i++)\n                if (!hist.done[i].ranges)\n                    ++done;\n            for (let i = 0; i < hist.undone.length; i++)\n                if (!hist.undone[i].ranges)\n                    ++undone;\n            return {\n                undo: done,\n                redo: undone\n            };\n        },\n        clearHistory: function () {\n            this.history = new n.History(this.history.maxGeneration);\n        },\n        markClean: function () {\n            this.cleanGeneration = this.changeGeneration(true);\n        },\n        changeGeneration: function (forceSplit) {\n            if (forceSplit)\n                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n            return this.history.generation;\n        },\n        isClean: function (gen) {\n            return this.history.generation == (gen || this.cleanGeneration);\n        },\n        getHistory: function () {\n            return {\n                done: n.copyHistoryArray(this.history.done),\n                undone: n.copyHistoryArray(this.history.undone)\n            };\n        },\n        setHistory: function (histData) {\n            let hist = this.history = new n.History(this.history.maxGeneration);\n            hist.done = n.copyHistoryArray(histData.done.slice(0), null, true);\n            hist.undone = n.copyHistoryArray(histData.undone.slice(0), null, true);\n        },\n        setGutterMarker: a.docMethodOp(function (line, gutterID, value) {\n            return j.changeLine(this, line, 'gutter', line => {\n                let markers = line.gutterMarkers || (line.gutterMarkers = {});\n                markers[gutterID] = value;\n                if (!value && h.isEmpty(markers))\n                    line.gutterMarkers = null;\n                return true;\n            });\n        }),\n        clearGutter: a.docMethodOp(function (gutterID) {\n            this.iter(line => {\n                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n                    j.changeLine(this, line, 'gutter', () => {\n                        line.gutterMarkers[gutterID] = null;\n                        if (h.isEmpty(line.gutterMarkers))\n                            line.gutterMarkers = null;\n                        return true;\n                    });\n                }\n            });\n        }),\n        lineInfo: function (line) {\n            let n;\n            if (typeof line == 'number') {\n                if (!e.isLine(this, line))\n                    return null;\n                n = line;\n                line = e.getLine(this, line);\n                if (!line)\n                    return null;\n            } else {\n                n = e.lineNo(line);\n                if (n == null)\n                    return null;\n            }\n            return {\n                line: n,\n                handle: line,\n                text: line.text,\n                gutterMarkers: line.gutterMarkers,\n                textClass: line.textClass,\n                bgClass: line.bgClass,\n                wrapClass: line.wrapClass,\n                widgets: line.widgets\n            };\n        },\n        addLineClass: a.docMethodOp(function (handle, where, cls) {\n            return j.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\n                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                if (!line[prop])\n                    line[prop] = cls;\n                else if (f.classTest(cls).test(line[prop]))\n                    return false;\n                else\n                    line[prop] += ' ' + cls;\n                return true;\n            });\n        }),\n        removeLineClass: a.docMethodOp(function (handle, where, cls) {\n            return j.changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', line => {\n                let prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                let cur = line[prop];\n                if (!cur)\n                    return false;\n                else if (cls == null)\n                    line[prop] = null;\n                else {\n                    let found = cur.match(f.classTest(cls));\n                    if (!found)\n                        return false;\n                    let end = found.index + found[0].length;\n                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\n                }\n                return true;\n            });\n        }),\n        addLineWidget: a.docMethodOp(function (handle, node, options) {\n            return o.addLineWidget(this, handle, node, options);\n        }),\n        removeLineWidget: function (widget) {\n            widget.clear();\n        },\n        markText: function (from, to, options) {\n            return p.markText(this, c.clipPos(this, from), c.clipPos(this, to), options, options && options.type || 'range');\n        },\n        setBookmark: function (pos, options) {\n            let realOpts = {\n                replacedWith: options && (options.nodeType == null ? options.widget : options),\n                insertLeft: options && options.insertLeft,\n                clearWhenEmpty: false,\n                shared: options && options.shared,\n                handleMouseEvents: options && options.handleMouseEvents\n            };\n            pos = c.clipPos(this, pos);\n            return p.markText(this, pos, pos, realOpts, 'bookmark');\n        },\n        findMarksAt: function (pos) {\n            pos = c.clipPos(this, pos);\n            let markers = [], spans = e.getLine(this, pos.line).markedSpans;\n            if (spans)\n                for (let i = 0; i < spans.length; ++i) {\n                    let span = spans[i];\n                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))\n                        markers.push(span.marker.parent || span.marker);\n                }\n            return markers;\n        },\n        findMarks: function (from, to, filter) {\n            from = c.clipPos(this, from);\n            to = c.clipPos(this, to);\n            let found = [], lineNo = from.line;\n            this.iter(from.line, to.line + 1, line => {\n                let spans = line.markedSpans;\n                if (spans)\n                    for (let i = 0; i < spans.length; i++) {\n                        let span = spans[i];\n                        if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker)))\n                            found.push(span.marker.parent || span.marker);\n                    }\n                ++lineNo;\n            });\n            return found;\n        },\n        getAllMarks: function () {\n            let markers = [];\n            this.iter(line => {\n                let sps = line.markedSpans;\n                if (sps)\n                    for (let i = 0; i < sps.length; ++i)\n                        if (sps[i].from != null)\n                            markers.push(sps[i].marker);\n            });\n            return markers;\n        },\n        posFromIndex: function (off) {\n            let ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n            this.iter(line => {\n                let sz = line.text.length + sepSize;\n                if (sz > off) {\n                    ch = off;\n                    return true;\n                }\n                off -= sz;\n                ++lineNo;\n            });\n            return c.clipPos(this, c.Pos(lineNo, ch));\n        },\n        indexFromPos: function (coords) {\n            coords = c.clipPos(this, coords);\n            let index = coords.ch;\n            if (coords.line < this.first || coords.ch < 0)\n                return 0;\n            let sepSize = this.lineSeparator().length;\n            this.iter(this.first, coords.line, line => {\n                index += line.text.length + sepSize;\n            });\n            return index;\n        },\n        copy: function (copyHistory) {\n            let doc = new Doc(e.getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n            doc.scrollTop = this.scrollTop;\n            doc.scrollLeft = this.scrollLeft;\n            doc.sel = this.sel;\n            doc.extend = false;\n            if (copyHistory) {\n                doc.history.undoDepth = this.history.undoDepth;\n                doc.setHistory(this.getHistory());\n            }\n            return doc;\n        },\n        linkedDoc: function (options) {\n            if (!options)\n                options = {};\n            let from = this.first, to = this.first + this.size;\n            if (options.from != null && options.from > from)\n                from = options.from;\n            if (options.to != null && options.to < to)\n                to = options.to;\n            let copy = new Doc(e.getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n            if (options.sharedHist)\n                copy.history = this.history;\n            (this.linked || (this.linked = [])).push({\n                doc: copy,\n                sharedHist: options.sharedHist\n            });\n            copy.linked = [{\n                    doc: this,\n                    isParent: true,\n                    sharedHist: options.sharedHist\n                }];\n            p.copySharedMarkers(copy, p.findSharedMarkers(this));\n            return copy;\n        },\n        unlinkDoc: function (other) {\n            //if (other instanceof CodeMirror) // modified by lwf\n            if (other.doc)\n                other = other.doc;\n            if (this.linked)\n                for (let i = 0; i < this.linked.length; ++i) {\n                    let link = this.linked[i];\n                    if (link.doc != other)\n                        continue;\n                    this.linked.splice(i, 1);\n                    other.unlinkDoc(this);\n                    p.detachSharedMarkers(p.findSharedMarkers(this));\n                    break;\n                }\n            if (other.history == this.history) {\n                let splitIds = [other.id];\n                m.linkedDocs(other, doc => splitIds.push(doc.id), true);\n                other.history = new n.History(null);\n                other.history.done = n.copyHistoryArray(this.history.done, splitIds);\n                other.history.undone = n.copyHistoryArray(this.history.undone, splitIds);\n            }\n        },\n        iterLinkedDocs: function (f) {\n            m.linkedDocs(this, f);\n        },\n        getMode: function () {\n            return this.mode;\n        },\n        getEditor: function () {\n            return this.cm;\n        },\n        splitLines: function (str) {\n            if (this.lineSep)\n                return str.split(this.lineSep);\n            return g.splitLinesAuto(str);\n        },\n        lineSeparator: function () {\n            return this.lineSep || '\\n';\n        },\n        setDirection: a.docMethodOp(function (dir) {\n            if (dir != 'rtl')\n                dir = 'ltr';\n            if (dir == this.direction)\n                return;\n            this.direction = dir;\n            this.iter(line => line.order = null);\n            if (this.cm)\n                m.directionChanged(this.cm);\n        })\n    });\n    Doc.prototype.eachLine = Doc.prototype.iter;\n    return Doc;\n});"]}