{"version":3,"sources":["primitives/model/mark_text.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","nextMarkerId","TextMarker","[object Object]","doc","type","this","lines","id","explicitlyCleared","cm","withOp","curOp","startOperation","hasHandler","found","find","signalLater","from","to","min","max","length","line","span","getMarkedSpanFor","markedSpans","collapsed","regLineChange","lineNo","removeMarkedSpan","lineIsHidden","updateLineHeight","textHeight","display","options","lineWrapping","visual","visualLine","len","lineLength","maxLineLength","maxLine","maxLineChanged","regChange","atomic","cantEdit","reCheckSelection","endOperation","parent","clear","side","lineObj","Pos","pos","widget","runInOp","lineN","view","findViewForLine","clearLineMeasurementCacheFor","selectionChanged","forceUpdate","updateMaxLine","height","oldHeight","dHeight","widgetHeight","op","maybeHiddenMarkers","indexOf","maybeUnhiddenMarkers","push","splice","markText","shared","copyObj","markers","primary","widgetNode","linkedDocs","cloneNode","clipPos","linked","isParent","lst","SharedTextMarker","markTextShared","operation","marker","diff","cmp","clearWhenEmpty","replacedWith","eltP","handleMouseEvents","setAttribute","insertLeft","conflictingCollapsedRange","Error","seeCollapsedSpans","addToHistory","addChangeToHistory","origin","sel","NaN","curLine","iter","addMarkedSpan","MarkedSpan","ch","clearOnEnter","on","readOnly","seeReadOnlySpans","history","done","undone","clearHistory","className","startStyle","endStyle","css","attributes","title","eventMixin","findSharedMarkers","findMarks","first","lastLine","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker"],"mappings":"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","file":"../../../primitives/model/mark_text.js","sourcesContent":["define([\n    '../util/dom',\n    '../util/event',\n    '../display/operations',\n    '../line/pos',\n    '../line/utils_line',\n    '../measurement/position_measurement',\n    '../line/saw_special_spans',\n    '../line/spans',\n    '../util/misc',\n    '../util/operation_group',\n    '../measurement/widgets',\n    '../display/view_tracking',\n    './document_data',\n    './history',\n    './selection_updates'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {\n    'use strict';\n    let nextMarkerId = 0;\n    class TextMarker {\n        constructor(doc, type) {\n            this.lines = [];\n            this.type = type;\n            this.doc = doc;\n            this.id = ++nextMarkerId;\n        }\n        clear() {\n            if (this.explicitlyCleared)\n                return;\n            let cm = this.doc.cm, withOp = cm && !cm.curOp;\n            if (withOp)\n                c.startOperation(cm);\n            if (b.hasHandler(this, 'clear')) {\n                let found = this.find();\n                if (found)\n                    j.signalLater(this, 'clear', found.from, found.to);\n            }\n            let min = null, max = null;\n            for (let i = 0; i < this.lines.length; ++i) {\n                let line = this.lines[i];\n                let span = h.getMarkedSpanFor(line.markedSpans, this);\n                if (cm && !this.collapsed)\n                    l.regLineChange(cm, e.lineNo(line), 'text');\n                else if (cm) {\n                    if (span.to != null)\n                        max = e.lineNo(line);\n                    if (span.from != null)\n                        min = e.lineNo(line);\n                }\n                line.markedSpans = h.removeMarkedSpan(line.markedSpans, span);\n                if (span.from == null && this.collapsed && !h.lineIsHidden(this.doc, line) && cm)\n                    e.updateLineHeight(line, f.textHeight(cm.display));\n            }\n            if (cm && this.collapsed && !cm.options.lineWrapping)\n                for (let i = 0; i < this.lines.length; ++i) {\n                    let visual = h.visualLine(this.lines[i]), len = h.lineLength(visual);\n                    if (len > cm.display.maxLineLength) {\n                        cm.display.maxLine = visual;\n                        cm.display.maxLineLength = len;\n                        cm.display.maxLineChanged = true;\n                    }\n                }\n            if (min != null && cm && this.collapsed)\n                l.regChange(cm, min, max + 1);\n            this.lines.length = 0;\n            this.explicitlyCleared = true;\n            if (this.atomic && this.doc.cantEdit) {\n                this.doc.cantEdit = false;\n                if (cm)\n                    o.reCheckSelection(cm.doc);\n            }\n            if (cm)\n                j.signalLater(cm, 'markerCleared', cm, this, min, max);\n            if (withOp)\n                c.endOperation(cm);\n            if (this.parent)\n                this.parent.clear();\n        }\n        find(side, lineObj) {\n            if (side == null && this.type == 'bookmark')\n                side = 1;\n            let from, to;\n            for (let i = 0; i < this.lines.length; ++i) {\n                let line = this.lines[i];\n                let span = h.getMarkedSpanFor(line.markedSpans, this);\n                if (span.from != null) {\n                    from = d.Pos(lineObj ? line : e.lineNo(line), span.from);\n                    if (side == -1)\n                        return from;\n                }\n                if (span.to != null) {\n                    to = d.Pos(lineObj ? line : e.lineNo(line), span.to);\n                    if (side == 1)\n                        return to;\n                }\n            }\n            return from && {\n                from: from,\n                to: to\n            };\n        }\n        changed() {\n            let pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n            if (!pos || !cm)\n                return;\n            c.runInOp(cm, () => {\n                let line = pos.line, lineN = e.lineNo(pos.line);\n                let view = f.findViewForLine(cm, lineN);\n                if (view) {\n                    f.clearLineMeasurementCacheFor(view);\n                    cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n                }\n                cm.curOp.updateMaxLine = true;\n                if (!h.lineIsHidden(widget.doc, line) && widget.height != null) {\n                    let oldHeight = widget.height;\n                    widget.height = null;\n                    let dHeight = k.widgetHeight(widget) - oldHeight;\n                    if (dHeight)\n                        e.updateLineHeight(line, line.height + dHeight);\n                }\n                j.signalLater(cm, 'markerChanged', cm, this);\n            });\n        }\n        attachLine(line) {\n            if (!this.lines.length && this.doc.cm) {\n                let op = this.doc.cm.curOp;\n                if (!op.maybeHiddenMarkers || i.indexOf(op.maybeHiddenMarkers, this) == -1)\n                    (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n            }\n            this.lines.push(line);\n        }\n        detachLine(line) {\n            this.lines.splice(i.indexOf(this.lines, line), 1);\n            if (!this.lines.length && this.doc.cm) {\n                let op = this.doc.cm.curOp;\n                (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n            }\n        }\n    }\n    b.eventMixin(TextMarker);\n    function markText(doc, from, to, options, type) {\n        if (options && options.shared)\n            return markTextShared(doc, from, to, options, type);\n        if (doc.cm && !doc.cm.curOp)\n            return c.operation(doc.cm, markText)(doc, from, to, options, type);\n        let marker = new TextMarker(doc, type), diff = d.cmp(from, to);\n        if (options)\n            i.copyObj(options, marker, false);\n        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n            return marker;\n        if (marker.replacedWith) {\n            marker.collapsed = true;\n            marker.widgetNode = a.eltP('span', [marker.replacedWith], 'CodeMirror-widget');\n            if (!options.handleMouseEvents)\n                marker.widgetNode.setAttribute('cm-ignore-events', 'true');\n            if (options.insertLeft)\n                marker.widgetNode.insertLeft = true;\n        }\n        if (marker.collapsed) {\n            if (h.conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && h.conflictingCollapsedRange(doc, to.line, from, to, marker))\n                throw new Error('Inserting collapsed marker partially overlapping an existing one');\n            g.seeCollapsedSpans();\n        }\n        if (marker.addToHistory)\n            n.addChangeToHistory(doc, {\n                from: from,\n                to: to,\n                origin: 'markText'\n            }, doc.sel, NaN);\n        let curLine = from.line, cm = doc.cm, updateMaxLine;\n        doc.iter(curLine, to.line + 1, line => {\n            if (cm && marker.collapsed && !cm.options.lineWrapping && h.visualLine(line) == cm.display.maxLine)\n                updateMaxLine = true;\n            if (marker.collapsed && curLine != from.line)\n                e.updateLineHeight(line, 0);\n            h.addMarkedSpan(line, new h.MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));\n            ++curLine;\n        });\n        if (marker.collapsed)\n            doc.iter(from.line, to.line + 1, line => {\n                if (h.lineIsHidden(doc, line))\n                    e.updateLineHeight(line, 0);\n            });\n        if (marker.clearOnEnter)\n            b.on(marker, 'beforeCursorEnter', () => marker.clear());\n        if (marker.readOnly) {\n            g.seeReadOnlySpans();\n            if (doc.history.done.length || doc.history.undone.length)\n                doc.clearHistory();\n        }\n        if (marker.collapsed) {\n            marker.id = ++nextMarkerId;\n            marker.atomic = true;\n        }\n        if (cm) {\n            if (updateMaxLine)\n                cm.curOp.updateMaxLine = true;\n            if (marker.collapsed)\n                l.regChange(cm, from.line, to.line + 1);\n            else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title)\n                for (let i = from.line; i <= to.line; i++)\n                    l.regLineChange(cm, i, 'text');\n            if (marker.atomic)\n                o.reCheckSelection(cm.doc);\n            j.signalLater(cm, 'markerAdded', cm, marker);\n        }\n        return marker;\n    }\n    class SharedTextMarker {\n        constructor(markers, primary) {\n            this.markers = markers;\n            this.primary = primary;\n            for (let i = 0; i < markers.length; ++i)\n                markers[i].parent = this;\n        }\n        clear() {\n            if (this.explicitlyCleared)\n                return;\n            this.explicitlyCleared = true;\n            for (let i = 0; i < this.markers.length; ++i)\n                this.markers[i].clear();\n            j.signalLater(this, 'clear');\n        }\n        find(side, lineObj) {\n            return this.primary.find(side, lineObj);\n        }\n    }\n    b.eventMixin(SharedTextMarker);\n    function markTextShared(doc, from, to, options, type) {\n        options = i.copyObj(options);\n        options.shared = false;\n        let markers = [markText(doc, from, to, options, type)], primary = markers[0];\n        let widget = options.widgetNode;\n        m.linkedDocs(doc, doc => {\n            if (widget)\n                options.widgetNode = widget.cloneNode(true);\n            markers.push(markText(doc, d.clipPos(doc, from), d.clipPos(doc, to), options, type));\n            for (let i = 0; i < doc.linked.length; ++i)\n                if (doc.linked[i].isParent)\n                    return;\n            primary = i.lst(markers);\n        });\n        return new SharedTextMarker(markers, primary);\n    }\n    function findSharedMarkers(doc) {\n        return doc.findMarks(d.Pos(doc.first, 0), doc.clipPos(d.Pos(doc.lastLine())), m => m.parent);\n    }\n    function copySharedMarkers(doc, markers) {\n        for (let i = 0; i < markers.length; i++) {\n            let marker = markers[i], pos = marker.find();\n            let mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n            if (d.cmp(mFrom, mTo)) {\n                let subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n                marker.markers.push(subMark);\n                subMark.parent = marker;\n            }\n        }\n    }\n    function detachSharedMarkers(markers) {\n        for (let i = 0; i < markers.length; i++) {\n            let marker = markers[i], linked = [marker.primary.doc];\n            m.linkedDocs(marker.primary.doc, d => linked.push(d));\n            for (let j = 0; j < marker.markers.length; j++) {\n                let subMarker = marker.markers[j];\n                if (i.indexOf(linked, subMarker.doc) == -1) {\n                    subMarker.parent = null;\n                    marker.markers.splice(j--, 1);\n                }\n            }\n        }\n    }\n    return {\n        TextMarker: TextMarker,\n        markText: markText,\n        SharedTextMarker: SharedTextMarker,\n        findSharedMarkers: findSharedMarkers,\n        copySharedMarkers: copySharedMarkers,\n        detachSharedMarkers: detachSharedMarkers\n    };\n});"]}