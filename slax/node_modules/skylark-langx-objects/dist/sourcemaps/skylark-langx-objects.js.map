{"version":3,"sources":["skylark-langx-objects.js"],"names":["define","skylark","_attach","types","numbers","eq","deepEq","hasOwnProperty","Object","prototype","slice","Array","isBoolean","isFunction","isObject","isPlainObject","isArray","isArrayLike","isString","toInteger","keysFunc","defaults","SymbolProto","Symbol","allKeys","obj","keys","key","push","has","path","call","length","i","_mixin","target","source","deep","safe","undefined","_parseMixinArgs","args","params","arguments","shift","pop","sources","mixin","apply","this","forEach","values","a","b","aStack","bStack","type","className","toString","valueOf","areArrays","aCtor","constructor","bCtor","attach","clone","src","checkCloneMethod","copy","index","l","each","callback","value","undef","extend","arg","isEqual","includes","collection","fromIndex","guard","nativeMax","indexOf","baseIndexOf","isMatch","object","attrs","omit","prop1","prop2","result","pn","pick","removeItem","items","item","idx","splice","fallback","split","prop","safeMixin","objects","main"],"mappings":"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","file":"../skylark-langx-objects.js","sourcesContent":["define('skylark-langx-objects/objects',[\r\n    \"skylark-langx-ns/ns\",\r\n    \"skylark-langx-ns/_attach\",\r\n\t\"skylark-langx-types\",\r\n    \"skylark-langx-numbers\"\r\n],function(skylark,_attach,types,numbers){\r\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\r\n        slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean,\r\n        isFunction = types.isFunction,\r\n\t\tisObject = types.isObject,\r\n\t\tisPlainObject = types.isPlainObject,\r\n\t\tisArray = types.isArray,\r\n        isArrayLike = types.isArrayLike,\r\n        isString = types.isString,\r\n        toInteger = numbers.toInteger;\r\n\r\n     // An internal function for creating assigner functions.\r\n    function createAssigner(keysFunc, defaults) {\r\n        return function(obj) {\r\n          var length = arguments.length;\r\n          if (defaults) obj = Object(obj);  \r\n          if (length < 2 || obj == null) return obj;\r\n          for (var index = 1; index < length; index++) {\r\n            var source = arguments[index],\r\n                keys = keysFunc(source),\r\n                l = keys.length;\r\n            for (var i = 0; i < l; i++) {\r\n              var key = keys[i];\r\n              if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n            }\r\n          }\r\n          return obj;\r\n       };\r\n    }\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function each(obj, callback) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if (callback.call(value, key, value) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if (callback.call(value, i, value) === false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function extend(target) {\r\n        var deep, args = slice.call(arguments, 1);\r\n        if (typeof target == 'boolean') {\r\n            deep = target\r\n            target = args.shift()\r\n        }\r\n        if (args.length == 0) {\r\n            args = [target];\r\n            target = this;\r\n        }\r\n        args.forEach(function(arg) {\r\n            mixin(target, arg, deep);\r\n        });\r\n        return target;\r\n    }\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function has(obj, path) {\r\n        if (!isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n                if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                if (isArray(source[key]) && !isArray(target[key])) {\r\n                    target[key] = [];\r\n                }\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n    function omit(obj, prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = mixin({},obj);\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                delete result[pn];\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n\r\n   // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj,prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = {};\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                result[pn] = obj[pn];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function removeItem(items, item) {\r\n        if (isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function result(obj, path, fallback) {\r\n        if (!isArray(path)) {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length;\r\n        if (!length) {\r\n          return isFunction(fallback) ? fallback.call(obj) : fallback;\r\n        }\r\n        for (var i = 0; i < length; i++) {\r\n          var prop = obj == null ? void 0 : obj[path[i]];\r\n          if (prop === void 0) {\r\n            prop = fallback;\r\n            i = length; // Ensure we don't continue iterating.\r\n          }\r\n          obj = isFunction(prop) ? prop.call(obj) : prop;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = allKeys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return skylark.attach(\"langx.objects\",{\r\n        allKeys: allKeys,\r\n\r\n        attach : _attach,\r\n\r\n        clone: clone,\r\n\r\n        defaults : createAssigner(allKeys, true),\r\n\r\n        each : each,\r\n\r\n        extend : extend,\r\n\r\n        has: has,\r\n\r\n        isEqual: isEqual,   \r\n\r\n        includes: includes,\r\n\r\n        isMatch: isMatch,\r\n\r\n        keys: keys,\r\n\r\n        mixin: mixin,\r\n\r\n        omit: omit,\r\n\r\n        pick: pick,\r\n\r\n        removeItem: removeItem,\r\n\r\n        result : result,\r\n        \r\n        safeMixin: safeMixin,\r\n\r\n        values: values\r\n    });\r\n\r\n\r\n});\ndefine('skylark-langx-objects/main',[\r\n\t\"./objects\"\r\n],function(objects){\r\n\treturn objects;\r\n});\ndefine('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });\n\n"]}