{"version":3,"sources":["PredictorStream.js"],"names":["define","skylark","langx","streams","DecodeStream","PredictorStream","inherit","klassName","init","stream","params","predictor","this","get","error","readBlock","readBlockTiff","readBlockPng","dict","colors","bits","columns","pixBytes","rowBytes","prototype","call","bufferLength","buffer","ensureBuffer","rawBytes","getBytes","inbuf","outbuf","inbits","outbits","pos","i","c","compArray","Uint8Array","bitMask","j","k","kk","getByte","prevRow","subarray","length","up","upLeft","left","p","pa","pb","pc"],"mappings":"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","file":"../PredictorStream.js","sourcesContent":["\r\ndefine([\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\",\r\n    \"./streams\",\r\n    \"./DecodeStream\"\r\n], function(skylark, langx, streams, DecodeStream) {\r\n\r\n    var PredictorStream = DecodeStream.inherit({\r\n        klassName : \"PredictorStream\",\r\n\r\n        init : function(stream, params) {\r\n            var predictor = this.predictor = params.get('Predictor') || 1;\r\n\r\n            if (predictor <= 1)\r\n                return stream; // no prediction\r\n            if (predictor !== 2 && (predictor < 10 || predictor > 15))\r\n                error('Unsupported predictor: ' + predictor);\r\n\r\n            if (predictor === 2)\r\n                this.readBlock = this.readBlockTiff;\r\n            else\r\n                this.readBlock = this.readBlockPng;\r\n\r\n            this.stream = stream;\r\n            this.dict = stream.dict;\r\n\r\n            var colors = this.colors = params.get('Colors') || 1;\r\n            var bits = this.bits = params.get('BitsPerComponent') || 8;\r\n            var columns = this.columns = params.get('Columns') || 1;\r\n\r\n            this.pixBytes = (colors * bits + 7) >> 3;\r\n            this.rowBytes = (columns * colors * bits + 7) >> 3;\r\n            DecodeStream.prototype.init.call(this);          \r\n        },\r\n\r\n        readBlockTiff : function () {\r\n                var rowBytes = this.rowBytes;\r\n\r\n                var bufferLength = this.bufferLength;\r\n                var buffer = this.ensureBuffer(bufferLength + rowBytes);\r\n\r\n                var bits = this.bits;\r\n                var colors = this.colors;\r\n\r\n                var rawBytes = this.stream.getBytes(rowBytes);\r\n\r\n                var inbuf = 0,\r\n                    outbuf = 0;\r\n                var inbits = 0,\r\n                    outbits = 0;\r\n                var pos = bufferLength;\r\n\r\n                if (bits === 1) {\r\n                    for (var i = 0; i < rowBytes; ++i) {\r\n                        var c = rawBytes[i];\r\n                        inbuf = (inbuf << 8) | c;\r\n                        // bitwise addition is exclusive or\r\n                        // first shift inbuf and then add\r\n                        buffer[pos++] = (c ^ (inbuf >> colors)) & 0xFF;\r\n                        // truncate inbuf (assumes colors < 16)\r\n                        inbuf &= 0xFFFF;\r\n                    }\r\n                } else if (bits === 8) {\r\n                    for (var i = 0; i < colors; ++i)\r\n                        buffer[pos++] = rawBytes[i];\r\n                    for (; i < rowBytes; ++i) {\r\n                        buffer[pos] = buffer[pos - colors] + rawBytes[i];\r\n                        pos++;\r\n                    }\r\n                } else {\r\n                    var compArray = new Uint8Array(colors + 1);\r\n                    var bitMask = (1 << bits) - 1;\r\n                    var j = 0,\r\n                        k = bufferLength;\r\n                    var columns = this.columns;\r\n                    for (var i = 0; i < columns; ++i) {\r\n                        for (var kk = 0; kk < colors; ++kk) {\r\n                            if (inbits < bits) {\r\n                                inbuf = (inbuf << 8) | (rawBytes[j++] & 0xFF);\r\n                                inbits += 8;\r\n                            }\r\n                            compArray[kk] = (compArray[kk] +\r\n                                (inbuf >> (inbits - bits))) & bitMask;\r\n                            inbits -= bits;\r\n                            outbuf = (outbuf << bits) | compArray[kk];\r\n                            outbits += bits;\r\n                            if (outbits >= 8) {\r\n                                buffer[k++] = (outbuf >> (outbits - 8)) & 0xFF;\r\n                                outbits -= 8;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (outbits > 0) {\r\n                        buffer[k++] = (outbuf << (8 - outbits)) +\r\n                            (inbuf & ((1 << (8 - outbits)) - 1));\r\n                    }\r\n                }\r\n                this.bufferLength += rowBytes;\r\n        },\r\n\r\n        readBlockPng : function() {\r\n\r\n                var rowBytes = this.rowBytes;\r\n                var pixBytes = this.pixBytes;\r\n\r\n                var predictor = this.stream.getByte();\r\n                var rawBytes = this.stream.getBytes(rowBytes);\r\n\r\n                var bufferLength = this.bufferLength;\r\n                var buffer = this.ensureBuffer(bufferLength + rowBytes);\r\n\r\n                var prevRow = buffer.subarray(bufferLength - rowBytes, bufferLength);\r\n                if (prevRow.length == 0)\r\n                    prevRow = new Uint8Array(rowBytes);\r\n\r\n                var j = bufferLength;\r\n                switch (predictor) {\r\n                    case 0:\r\n                        for (var i = 0; i < rowBytes; ++i)\r\n                            buffer[j++] = rawBytes[i];\r\n                        break;\r\n                    case 1:\r\n                        for (var i = 0; i < pixBytes; ++i)\r\n                            buffer[j++] = rawBytes[i];\r\n                        for (; i < rowBytes; ++i) {\r\n                            buffer[j] = (buffer[j - pixBytes] + rawBytes[i]) & 0xFF;\r\n                            j++;\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        for (var i = 0; i < rowBytes; ++i)\r\n                            buffer[j++] = (prevRow[i] + rawBytes[i]) & 0xFF;\r\n                        break;\r\n                    case 3:\r\n                        for (var i = 0; i < pixBytes; ++i)\r\n                            buffer[j++] = (prevRow[i] >> 1) + rawBytes[i];\r\n                        for (; i < rowBytes; ++i) {\r\n                            buffer[j] = (((prevRow[i] + buffer[j - pixBytes]) >> 1) +\r\n                                rawBytes[i]) & 0xFF;\r\n                            j++;\r\n                        }\r\n                        break;\r\n                    case 4:\r\n                        // we need to save the up left pixels values. the simplest way\r\n                        // is to create a new buffer\r\n                        for (var i = 0; i < pixBytes; ++i) {\r\n                            var up = prevRow[i];\r\n                            var c = rawBytes[i];\r\n                            buffer[j++] = up + c;\r\n                        }\r\n                        for (; i < rowBytes; ++i) {\r\n                            var up = prevRow[i];\r\n                            var upLeft = prevRow[i - pixBytes];\r\n                            var left = buffer[j - pixBytes];\r\n                            var p = left + up - upLeft;\r\n\r\n                            var pa = p - left;\r\n                            if (pa < 0)\r\n                                pa = -pa;\r\n                            var pb = p - up;\r\n                            if (pb < 0)\r\n                                pb = -pb;\r\n                            var pc = p - upLeft;\r\n                            if (pc < 0)\r\n                                pc = -pc;\r\n\r\n                            var c = rawBytes[i];\r\n                            if (pa <= pb && pa <= pc)\r\n                                buffer[j++] = left + c;\r\n                            else if (pb <= pc)\r\n                                buffer[j++] = up + c;\r\n                            else\r\n                                buffer[j++] = upLeft + c;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        error('Unsupported predictor: ' + predictor);\r\n                }\r\n                this.bufferLength += rowBytes;\r\n        }\r\n    });\r\n\r\n    return streams.PredictorStream = PredictorStream;\r\n});\r\n"]}