{"version":3,"sources":["Entity.js"],"names":["define","langx","entities","wrapError","model","options","error","resp","call","context","trigger","Entity","Stateful","inherit","sync","apply","this","arguments","matches","attrs","isMatch","attributes","fetch","entity","success","mixin","parse","serverAttrs","set","save","key","val","wait","validate","_validate","method","isNew","patch","xhr","destroy","clone","stopListening","collection","defer","url","base","result","urlError","id","get","idAttribute","replace","encodeURIComponent"],"mappings":"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","file":"../Entity.js","sourcesContent":["define([\r\n\t\"skylark-langx/langx\",\r\n\t\"./entities\"\r\n],function(langx,entities){\r\n   // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function(model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error.call(options.context, model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n \r\n  var Entity = langx.Stateful.inherit({\r\n    sync: function() {\r\n      return entities.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Get the HTML-escaped value of an attribute.\r\n    //escape: function(attr) {\r\n    //  return _.escape(this.get(attr));\r\n    //},\r\n\r\n    // Special-cased proxy to underscore's `_.matches` method.\r\n    matches: function(attrs) {\r\n      return langx.isMatch(this.attributes,attrs);\r\n    },\r\n\r\n    // Fetch the entity from the server, merging the response with the entity's\r\n    // local attributes. Any changed attributes will trigger a \"change\" event.\r\n    fetch: function(options) {\r\n      options = langx.mixin({parse: true}, options);\r\n      var entity = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;\r\n        if (!entity.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        entity.trigger('sync', entity, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Set a hash of entity attributes, and sync the entity to the server.\r\n    // If the server returns an attributes hash that differs, the entity's\r\n    // state will be `set` again.\r\n    save: function(key, val, options) {\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      var attrs;\r\n      if (key == null || typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      options = langx.mixin({validate: true, parse: true}, options);\r\n      var wait = options.wait;\r\n\r\n      // If we're not waiting and attributes exist, save acts as\r\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\r\n      // the entity will be valid when the attributes, if any, are set.\r\n      if (attrs && !wait) {\r\n        if (!this.set(attrs, options)) return false;\r\n      } else if (!this._validate(attrs, options)) {\r\n        return false;\r\n      }\r\n\r\n      // After a successful server-side save, the client is (optionally)\r\n      // updated with the server-side state.\r\n      var entity = this;\r\n      var success = options.success;\r\n      var attributes = this.attributes;\r\n      options.success = function(resp) {\r\n        // Ensure attributes are restored during synchronous saves.\r\n        entity.attributes = attributes;\r\n        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;\r\n        if (wait) serverAttrs = langx.mixin({}, attrs, serverAttrs);\r\n        if (serverAttrs && !entity.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        entity.trigger('sync', entity, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n\r\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\r\n      if (attrs && wait) this.attributes = langx.mixin({}, attributes, attrs);\r\n\r\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\r\n      var xhr = this.sync(method, this, options);\r\n\r\n      // Restore attributes.\r\n      this.attributes = attributes;\r\n\r\n      return xhr;\r\n    },\r\n\r\n    // Destroy this entity on the server if it was already persisted.\r\n    // Optimistically removes the entity from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy: function(options) {\r\n      options = options ? langx.clone(options) : {};\r\n      var entity = this;\r\n      var success = options.success;\r\n      var wait = options.wait;\r\n\r\n      var destroy = function() {\r\n        entity.stopListening();\r\n        entity.trigger('destroy', entity, entity.collection, options);\r\n      };\r\n\r\n      options.success = function(resp) {\r\n        if (wait) destroy();\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        if (!entity.isNew()) entity.trigger('sync', entity, resp, options);\r\n      };\r\n\r\n      var xhr = false;\r\n      if (this.isNew()) {\r\n        langx.defer(options.success);\r\n      } else {\r\n        wrapError(this, options);\r\n        xhr = this.sync('delete', this, options);\r\n      }\r\n      if (!wait) destroy();\r\n      return xhr;\r\n    },\r\n\r\n    // Default URL for the entity's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url: function() {\r\n      var base =\r\n        langx.result(this, 'urlRoot') ||\r\n        langx.result(this.collection, 'url') ||\r\n        urlError();\r\n      if (this.isNew()) return base;\r\n      var id = this.get(this.idAttribute);\r\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\r\n    },\r\n\r\n    // **parse** converts a response into the hash of attributes to be `set` on\r\n    // the entity. The default implementation is just to pass the response along.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    }\r\n  });\r\n\r\n  return entities.Entity = Entity;\r\n\r\n});"]}