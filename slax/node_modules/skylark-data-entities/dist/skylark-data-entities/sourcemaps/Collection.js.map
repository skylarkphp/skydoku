{"version":3,"sources":["Collection.js"],"names":["define","langx","entities","Entity","Collection","Evented","inherit","_construct","options","entity","this","comparator","_reset","reset","mixin","silent","setOptions","add","remove","merge","addOptions","splice","array","insert","at","Math","min","max","length","i","tail","Array","partial","initialize","toJSON","map","sync","apply","arguments","set","singular","isArray","slice","removed","_removeEntitys","changes","added","merged","trigger","parse","_isEntity","toAdd","toMerge","toRemove","modelMap","sort","sortable","sortAttr","isString","existing","get","attrs","attributes","push","hasChanged","cid","_prepareEntity","_addReference","orderChanged","replace","some","m","index","clone","_removeReference","previousEntitys","pop","unshift","shift","obj","_byId","entityId","has","where","first","findWhere","Error","isFunction","proxy","sortBy","pluck","attr","fetch","success","collection","resp","method","call","context","model","error","wrapError","create","wait","callbackOpts","save","constructor","prototype","idAttribute","validationError","indexOf","id","on","_onEntityEvent","off","event","prevId","previousAttributes"],"mappings":";;;;;;;AAAAA,QACC,sBACA,aACA,YACC,SAASC,EAAMC,EAASC,GAExB,IASGC,EAAcH,EAAMI,QAAQC,SAC/BC,WAAe,SAASL,EAAUM,GACjCA,IAAYA,MACRA,EAAQC,SAAQC,KAAKD,OAASD,EAAQC,aACf,IAAvBD,EAAQG,aAAuBD,KAAKC,WAAaH,EAAQG,YAC7DD,KAAKE,SACDV,GAAUQ,KAAKG,MAAMX,EAAUD,EAAMa,OAAOC,QAAQ,GAAOP,OAK7DQ,GAAcC,KAAK,EAAMC,QAAQ,EAAMC,OAAO,GAC9CC,GAAcH,KAAK,EAAMC,QAAQ,GAGjCG,EAAS,SAASC,EAAOC,EAAQC,GACpCA,EAAKC,KAAKC,IAAID,KAAKE,IAAIH,EAAI,GAAIF,EAAMM,QACrC,IAEIC,EAFAC,EAAOC,MAAMT,EAAMM,OAASJ,GAC5BI,EAASL,EAAOK,OAEpB,IAAKC,EAAI,EAAGA,EAAIC,EAAKF,OAAQC,IAAKC,EAAKD,GAAKP,EAAMO,EAAIL,GACtD,IAAKK,EAAI,EAAGA,EAAID,EAAQC,IAAKP,EAAMO,EAAIL,GAAMD,EAAOM,GACpD,IAAKA,EAAI,EAAGA,EAAIC,EAAKF,OAAQC,IAAKP,EAAMO,EAAID,EAASJ,GAAMM,EAAKD,IAgajE,OA5ZAzB,EAAW4B,SAIVvB,OAAQN,EAIR8B,WAAY,aAIZC,OAAQ,SAAS1B,GACf,OAAOE,KAAKyB,IAAI,SAAS1B,GAAU,OAAOA,EAAOyB,OAAO1B,MAI1D4B,KAAM,WACJ,OAAOlC,EAASkC,KAAKC,MAAM3B,KAAM4B,YAMnCrB,IAAK,SAASf,EAAUM,GACtB,OAAOE,KAAK6B,IAAIrC,EAAUD,EAAMa,OAAOK,OAAO,GAAQX,EAASY,KAIjEF,OAAQ,SAAShB,EAAUM,GACzBA,EAAUP,EAAMa,SAAUN,GAC1B,IAAIgC,GAAYvC,EAAMwC,QAAQvC,GAC9BA,EAAWsC,GAAYtC,GAAYA,EAASwC,QAC5C,IAAIC,EAAUjC,KAAKkC,eAAe1C,EAAUM,GAK5C,OAJKA,EAAQO,QAAU4B,EAAQf,SAC7BpB,EAAQqC,SAAWC,SAAWC,UAAYJ,QAASA,GACnDjC,KAAKsC,QAAQ,SAAUtC,KAAMF,IAExBgC,EAAWG,EAAQ,GAAKA,GAOjCJ,IAAK,SAASrC,EAAUM,GACtB,GAAgB,MAAZN,EAAJ,EAEAM,EAAUP,EAAMa,SAAUE,EAAYR,IAC1ByC,QAAUvC,KAAKwC,UAAUhD,KACnCA,EAAWQ,KAAKuC,MAAM/C,EAAUM,QAGlC,IAAIgC,GAAYvC,EAAMwC,QAAQvC,GAC9BA,EAAWsC,GAAYtC,GAAYA,EAASwC,QAE5C,IAAIlB,EAAKhB,EAAQgB,GACP,MAANA,IAAYA,GAAMA,GAClBA,EAAKd,KAAKkB,SAAQJ,EAAKd,KAAKkB,QAC5BJ,EAAK,IAAGA,GAAMd,KAAKkB,OAAS,GAEhC,IAgBInB,EAAQoB,EAhBRU,KACAY,KACAC,KACAC,KACAC,KAEArC,EAAMT,EAAQS,IACdE,EAAQX,EAAQW,MAChBD,EAASV,EAAQU,OAEjBqC,GAAO,EACPC,EAAW9C,KAAKC,YAAoB,MAANa,IAA+B,IAAjBhB,EAAQ+C,KACpDE,EAAWxD,EAAMyD,SAAShD,KAAKC,YAAcD,KAAKC,WAAa,KAKnE,IAAKkB,EAAI,EAAGA,EAAI3B,EAAS0B,OAAQC,IAAK,CACpCpB,EAASP,EAAS2B,GAIlB,IAAI8B,EAAWjD,KAAKkD,IAAInD,GACxB,GAAIkD,EAAU,CACZ,GAAIxC,GAASV,IAAWkD,EAAU,CAChC,IAAIE,EAAQnD,KAAKwC,UAAUzC,GAAUA,EAAOqD,WAAarD,EACrDD,EAAQyC,QAAOY,EAAQF,EAASV,MAAMY,EAAOrD,IACjDmD,EAASpB,IAAIsB,EAAOrD,GACpB4C,EAAQW,KAAKJ,GACTH,IAAaD,IAAMA,EAAOI,EAASK,WAAWP,IAE/CH,EAASK,EAASM,OACrBX,EAASK,EAASM,MAAO,EACzB1B,EAAIwB,KAAKJ,IAEXzD,EAAS2B,GAAK8B,OAGL1C,IACTR,EAASP,EAAS2B,GAAKnB,KAAKwD,eAAezD,EAAQD,MAEjD2C,EAAMY,KAAKtD,GACXC,KAAKyD,cAAc1D,EAAQD,GAC3B8C,EAAS7C,EAAOwD,MAAO,EACvB1B,EAAIwB,KAAKtD,IAMf,GAAIS,EAAQ,CACV,IAAKW,EAAI,EAAGA,EAAInB,KAAKkB,OAAQC,IAEtByB,GADL7C,EAASC,KAAKR,SAAS2B,IACFoC,MAAMZ,EAASU,KAAKtD,GAEvC4C,EAASzB,QAAQlB,KAAKkC,eAAeS,EAAU7C,GAIrD,IAAI4D,GAAe,EACfC,GAAWb,GAAYvC,GAAOC,EAkBlC,GAjBIqB,EAAIX,QAAUyC,GAChBD,EAAe1D,KAAKkB,SAAWW,EAAIX,QAAUlB,KAAKR,SAASoE,KAAK,SAASC,EAAGC,GAC1E,OAAOD,IAAMhC,EAAIiC,KAEnB9D,KAAKR,SAAS0B,OAAS,EACvBP,EAAOX,KAAKR,SAAUqC,EAAK,GAC3B7B,KAAKkB,OAASlB,KAAKR,SAAS0B,QACnBuB,EAAMvB,SACX4B,IAAUD,GAAO,GACrBlC,EAAOX,KAAKR,SAAUiD,EAAa,MAAN3B,EAAad,KAAKkB,OAASJ,GACxDd,KAAKkB,OAASlB,KAAKR,SAAS0B,QAI1B2B,GAAM7C,KAAK6C,MAAMxC,QAAQ,KAGxBP,EAAQO,OAAQ,CACnB,IAAKc,EAAI,EAAGA,EAAIsB,EAAMvB,OAAQC,IAClB,MAANL,IAAYhB,EAAQgE,MAAQhD,EAAKK,IACrCpB,EAAS0C,EAAMtB,IACRmB,QAAQ,MAAOvC,EAAQC,KAAMF,IAElC+C,GAAQa,IAAc1D,KAAKsC,QAAQ,OAAQtC,KAAMF,IACjD2C,EAAMvB,QAAUyB,EAASzB,QAAUwB,EAAQxB,UAC7CpB,EAAQqC,SACNC,MAAOK,EACPR,QAASU,EACTN,OAAQK,GAEV1C,KAAKsC,QAAQ,SAAUtC,KAAMF,IAKjC,OAAOgC,EAAWtC,EAAS,GAAKA,IAOlCW,MAAO,SAASX,EAAUM,GACxBA,EAAUA,EAAUP,EAAMwE,MAAMjE,MAChC,IAAK,IAAIqB,EAAI,EAAGA,EAAInB,KAAKR,SAAS0B,OAAQC,IACxCnB,KAAKgE,iBAAiBhE,KAAKR,SAAS2B,GAAIrB,GAM1C,OAJAA,EAAQmE,gBAAkBjE,KAAKR,SAC/BQ,KAAKE,SACLV,EAAWQ,KAAKO,IAAIf,EAAUD,EAAMa,OAAOC,QAAQ,GAAOP,IACrDA,EAAQO,QAAQL,KAAKsC,QAAQ,QAAStC,KAAMF,GAC1CN,GAIT6D,KAAM,SAAStD,EAAQD,GACrB,OAAOE,KAAKO,IAAIR,EAAQR,EAAMa,OAAOU,GAAId,KAAKkB,QAASpB,KAIzDoE,IAAK,SAASpE,GACZ,IAAIC,EAASC,KAAKc,GAAGd,KAAKkB,OAAS,GACnC,OAAOlB,KAAKQ,OAAOT,EAAQD,IAI7BqE,QAAS,SAASpE,EAAQD,GACxB,OAAOE,KAAKO,IAAIR,EAAQR,EAAMa,OAAOU,GAAI,GAAIhB,KAI/CsE,MAAO,SAAStE,GACd,IAAIC,EAASC,KAAKc,GAAG,GACrB,OAAOd,KAAKQ,OAAOT,EAAQD,IAI7BkC,MAAO,WACL,OAAOA,MAAML,MAAM3B,KAAKR,SAAUoC,YAKpCsB,IAAK,SAASmB,GACZ,GAAW,MAAPA,EACJ,OAAOrE,KAAKsE,MAAMD,IAChBrE,KAAKsE,MAAMtE,KAAKuE,SAASF,EAAIjB,YAAciB,KAC3CA,EAAId,KAAOvD,KAAKsE,MAAMD,EAAId,MAI9BiB,IAAK,SAASH,GACZ,OAAwB,MAAjBrE,KAAKkD,IAAImB,IAIlBvD,GAAI,SAASgD,GAEX,OADIA,EAAQ,IAAGA,GAAS9D,KAAKkB,QACtBlB,KAAKR,SAASsE,IAKvBW,MAAO,SAAStB,EAAOuB,GACrB,OAAO1E,KAAK0E,EAAQ,OAAS,UAAUvB,IAKzCwB,UAAW,SAASxB,GAClB,OAAOnD,KAAKyE,MAAMtB,GAAO,IAM3BN,KAAM,SAAS/C,GACb,IAAIG,EAAaD,KAAKC,WACtB,IAAKA,EAAY,MAAM,IAAI2E,MAAM,0CACjC9E,IAAYA,MAEZ,IAAIoB,EAASjB,EAAWiB,OAUxB,OATI3B,EAAMsF,WAAW5E,KAAaA,EAAaV,EAAMuF,MAAM7E,EAAYD,OAGxD,IAAXkB,GAAgB3B,EAAMyD,SAAS/C,GACjCD,KAAKR,SAAWQ,KAAK+E,OAAO9E,GAE5BD,KAAKR,SAASqD,KAAK5C,GAEhBH,EAAQO,QAAQL,KAAKsC,QAAQ,OAAQtC,KAAMF,GACzCE,MAITgF,MAAO,SAASC,GACd,OAAOjF,KAAKyB,IAAIwD,EAAO,KAMzBC,MAAO,SAASpF,GAEd,IAAIqF,GADJrF,EAAUP,EAAMa,OAAOmC,OAAO,GAAOzC,IACfqF,QAClBC,EAAapF,KAQjB,OAPAF,EAAQqF,QAAU,SAASE,GACzB,IAAIC,EAASxF,EAAQK,MAAQ,QAAU,MACvCiF,EAAWE,GAAQD,EAAMvF,GACrBqF,GAASA,EAAQI,KAAKzF,EAAQ0F,QAASJ,EAAYC,EAAMvF,GAC7DsF,EAAW9C,QAAQ,OAAQ8C,EAAYC,EAAMvF,IAnTjC,SAAS2F,EAAO3F,GAC9B,IAAI4F,EAAQ5F,EAAQ4F,MACpB5F,EAAQ4F,MAAQ,SAASL,GACnBK,GAAOA,EAAMH,KAAKzF,EAAQ0F,QAASC,EAAOJ,EAAMvF,GACpD2F,EAAMnD,QAAQ,QAASmD,EAAOJ,EAAMvF,IAiTtC6F,CAAU3F,KAAMF,GACTE,KAAK0B,KAAK,OAAQ1B,KAAMF,IAMjC8F,OAAQ,SAAS7F,EAAQD,GAEvB,IAAI+F,GADJ/F,EAAUA,EAAUP,EAAMwE,MAAMjE,OACb+F,KAEnB,KADA9F,EAASC,KAAKwD,eAAezD,EAAQD,IACxB,OAAO,EACf+F,GAAM7F,KAAKO,IAAIR,EAAQD,GAC5B,IAAIsF,EAAapF,KACbmF,EAAUrF,EAAQqF,QAMtB,OALArF,EAAQqF,QAAU,SAAStB,EAAGwB,EAAMS,GAC9BD,GAAMT,EAAW7E,IAAIsD,EAAGiC,GACxBX,GAASA,EAAQI,KAAKO,EAAaN,QAAS3B,EAAGwB,EAAMS,IAE3D/F,EAAOgG,KAAK,KAAMjG,GACXC,GAKTwC,MAAO,SAAS8C,EAAMvF,GACpB,OAAOuF,GAITtB,MAAO,WACL,OAAO,IAAI/D,KAAKgG,YAAYhG,KAAKR,UAC/BO,OAAQC,KAAKD,OACbE,WAAYD,KAAKC,cAKrBsE,SAAU,SAASpB,GACjB,OAAOA,EAAMnD,KAAKD,OAAOkG,UAAUC,aAAe,OAKpDhG,OAAQ,WACNF,KAAKkB,OAAS,EACdlB,KAAKR,YACLQ,KAAKsE,UAKPd,eAAgB,SAASL,EAAOrD,GAC9B,GAAIE,KAAKwC,UAAUW,GAEjB,OADKA,EAAMiC,aAAYjC,EAAMiC,WAAapF,MACnCmD,GAETrD,EAAUA,EAAUP,EAAMwE,MAAMjE,OACxBsF,WAAapF,KACrB,IAAID,EAAS,IAAIC,KAAKD,OAAOoD,EAAOrD,GACpC,OAAKC,EAAOoG,iBACZnG,KAAKsC,QAAQ,UAAWtC,KAAMD,EAAOoG,gBAAiBrG,IAC/C,GAF6BC,GAMtCmC,eAAgB,SAAS1C,EAAUM,GAEjC,IADA,IAAImC,KACKd,EAAI,EAAGA,EAAI3B,EAAS0B,OAAQC,IAAK,CACxC,IAAIpB,EAASC,KAAKkD,IAAI1D,EAAS2B,IAC/B,GAAKpB,EAAL,CAEA,IAAI+D,EAAQ9D,KAAKoG,QAAQrG,GACzBC,KAAKR,SAASmB,OAAOmD,EAAO,GAC5B9D,KAAKkB,gBAIElB,KAAKsE,MAAMvE,EAAOwD,KACzB,IAAI8C,EAAKrG,KAAKuE,SAASxE,EAAOqD,YACpB,MAANiD,UAAmBrG,KAAKsE,MAAM+B,GAE7BvG,EAAQO,SACXP,EAAQgE,MAAQA,EAChB/D,EAAOuC,QAAQ,SAAUvC,EAAQC,KAAMF,IAGzCmC,EAAQoB,KAAKtD,GACbC,KAAKgE,iBAAiBjE,EAAQD,IAEhC,OAAOmC,GAKTO,UAAW,SAASzC,GAClB,OAAOA,aAAkBN,GAI3BgE,cAAe,SAAS1D,EAAQD,GAC9BE,KAAKsE,MAAMvE,EAAOwD,KAAOxD,EACzB,IAAIsG,EAAKrG,KAAKuE,SAASxE,EAAOqD,YACpB,MAANiD,IAAYrG,KAAKsE,MAAM+B,GAAMtG,GACjCA,EAAOuG,GAAG,MAAOtG,KAAKuG,eAAgBvG,OAIxCgE,iBAAkB,SAASjE,EAAQD,UAC1BE,KAAKsE,MAAMvE,EAAOwD,KACzB,IAAI8C,EAAKrG,KAAKuE,SAASxE,EAAOqD,YACpB,MAANiD,UAAmBrG,KAAKsE,MAAM+B,GAC9BrG,OAASD,EAAOqF,mBAAmBrF,EAAOqF,WAC9CrF,EAAOyG,IAAI,MAAOxG,KAAKuG,eAAgBvG,OAOzCuG,eAAgB,SAASE,EAAO1G,EAAQqF,EAAYtF,GAClD,GAAIC,EAAQ,CACV,IAAe,QAAV0G,GAA6B,WAAVA,IAAuBrB,IAAepF,KAAM,OAEpE,GADc,YAAVyG,GAAqBzG,KAAKQ,OAAOT,EAAQD,GAC/B,WAAV2G,EAAoB,CACtB,IAAIC,EAAS1G,KAAKuE,SAASxE,EAAO4G,sBAC9BN,EAAKrG,KAAKuE,SAASxE,EAAOqD,YAC1BsD,IAAWL,IACC,MAAVK,UAAuB1G,KAAKsE,MAAMoC,GAC5B,MAANL,IAAYrG,KAAKsE,MAAM+B,GAAMtG,KAIvCC,KAAKsC,QAAQX,MAAM3B,KAAM4B,cAKrBpC,EAASE,WAAaA","file":"../Collection.js","sourcesContent":["define([\r\n\t\"skylark-langx/langx\",\r\n\t\"./entities\",\r\n\t\"./Entity\"\r\n],function(langx,entities,Entity){\r\n  // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function(model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error.call(options.context, model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n\r\n\tvar Collection  = langx.Evented.inherit({\r\n\t\t\"_construct\" : function(entities, options) {\r\n\t\t\toptions || (options = {});\r\n\t\t\tif (options.entity) this.entity = options.entity;\r\n\t\t\tif (options.comparator !== void 0) this.comparator = options.comparator;\r\n\t\t\tthis._reset();\r\n\t\t\tif (entities) this.reset(entities, langx.mixin({silent: true}, options));\r\n\t\t}\r\n\t}); \r\n\r\n\t// Default options for `Collection#set`.\r\n\tvar setOptions = {add: true, remove: true, merge: true};\r\n\tvar addOptions = {add: true, remove: false};\r\n\r\n\t// Splices `insert` into `array` at index `at`.\r\n\tvar splice = function(array, insert, at) {\r\n\t\tat = Math.min(Math.max(at, 0), array.length);\r\n\t\tvar tail = Array(array.length - at);\r\n\t\tvar length = insert.length;\r\n\t\tvar i;\r\n\t\tfor (i = 0; i < tail.length; i++) tail[i] = array[i + at];\r\n\t\tfor (i = 0; i < length; i++) array[i + at] = insert[i];\r\n\t\tfor (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\r\n\t};\r\n\r\n  // Define the Collection's inheritable methods.\r\n\tCollection.partial({\r\n\r\n\t\t// The default entity for a collection is just a **Entity**.\r\n\t\t// This should be overridden in most cases.\r\n\t\tentity: Entity,\r\n\r\n\t\t// Initialize is an empty function by default. Override it with your own\r\n\t\t// initialization logic.\r\n\t\tinitialize: function(){},\r\n\r\n\t\t// The JSON representation of a Collection is an array of the\r\n\t\t// entities' attributes.\r\n\t\ttoJSON: function(options) {\r\n\t\t  return this.map(function(entity) { return entity.toJSON(options); });\r\n\t\t},\r\n\r\n\t\t// Proxy `entities.sync` by default.\r\n\t\tsync: function() {\r\n\t\t  return entities.sync.apply(this, arguments);\r\n\t\t},\r\n\r\n\t\t// Add a entity, or list of entities to the set. `entities` may be Backbone\r\n\t\t// Entitys or raw JavaScript objects to be converted to Entitys, or any\r\n\t\t// combination of the two.\r\n\t\tadd: function(entities, options) {\r\n\t\t  return this.set(entities, langx.mixin({merge: false}, options, addOptions));\r\n\t\t},\r\n\r\n\t\t// Remove a entity, or a list of entities from the set.\r\n\t\tremove: function(entities, options) {\r\n\t\t  options = langx.mixin({}, options);\r\n\t\t  var singular = !langx.isArray(entities);\r\n\t\t  entities = singular ? [entities] : entities.slice();\r\n\t\t  var removed = this._removeEntitys(entities, options);\r\n\t\t  if (!options.silent && removed.length) {\r\n\t\t    options.changes = {added: [], merged: [], removed: removed};\r\n\t\t    this.trigger('update', this, options);\r\n\t\t  }\r\n\t\t  return singular ? removed[0] : removed;\r\n\t\t},\r\n\r\n\t\t// Update a collection by `set`-ing a new list of entities, adding new ones,\r\n\t\t// removing entities that are no longer present, and merging entities that\r\n\t\t// already exist in the collection, as necessary. Similar to **Entity#set**,\r\n\t\t// the core operation for updating the data contained by the collection.\r\n\t\tset: function(entities, options) {\r\n\t\t  if (entities == null) return;\r\n\r\n\t\t  options = langx.mixin({}, setOptions, options);\r\n\t\t  if (options.parse && !this._isEntity(entities)) {\r\n\t\t    entities = this.parse(entities, options) || [];\r\n\t\t  }\r\n\r\n\t\t  var singular = !langx.isArray(entities);\r\n\t\t  entities = singular ? [entities] : entities.slice();\r\n\r\n\t\t  var at = options.at;\r\n\t\t  if (at != null) at = +at;\r\n\t\t  if (at > this.length) at = this.length;\r\n\t\t  if (at < 0) at += this.length + 1;\r\n\r\n\t\t  var set = [];\r\n\t\t  var toAdd = [];\r\n\t\t  var toMerge = [];\r\n\t\t  var toRemove = [];\r\n\t\t  var modelMap = {};\r\n\r\n\t\t  var add = options.add;\r\n\t\t  var merge = options.merge;\r\n\t\t  var remove = options.remove;\r\n\r\n\t\t  var sort = false;\r\n\t\t  var sortable = this.comparator && at == null && options.sort !== false;\r\n\t\t  var sortAttr = langx.isString(this.comparator) ? this.comparator : null;\r\n\r\n\t\t  // Turn bare objects into entity references, and prevent invalid entities\r\n\t\t  // from being added.\r\n\t\t  var entity, i;\r\n\t\t  for (i = 0; i < entities.length; i++) {\r\n\t\t    entity = entities[i];\r\n\r\n\t\t    // If a duplicate is found, prevent it from being added and\r\n\t\t    // optionally merge it into the existing entity.\r\n\t\t    var existing = this.get(entity);\r\n\t\t    if (existing) {\r\n\t\t      if (merge && entity !== existing) {\r\n\t\t        var attrs = this._isEntity(entity) ? entity.attributes : entity;\r\n\t\t        if (options.parse) attrs = existing.parse(attrs, options);\r\n\t\t        existing.set(attrs, options);\r\n\t\t        toMerge.push(existing);\r\n\t\t        if (sortable && !sort) sort = existing.hasChanged(sortAttr);\r\n\t\t      }\r\n\t\t      if (!modelMap[existing.cid]) {\r\n\t\t        modelMap[existing.cid] = true;\r\n\t\t        set.push(existing);\r\n\t\t      }\r\n\t\t      entities[i] = existing;\r\n\r\n\t\t    // If this is a new, valid entity, push it to the `toAdd` list.\r\n\t\t    } else if (add) {\r\n\t\t      entity = entities[i] = this._prepareEntity(entity, options);\r\n\t\t      if (entity) {\r\n\t\t        toAdd.push(entity);\r\n\t\t        this._addReference(entity, options);\r\n\t\t        modelMap[entity.cid] = true;\r\n\t\t        set.push(entity);\r\n\t\t      }\r\n\t\t    }\r\n\t\t  }\r\n\r\n\t\t  // Remove stale entities.\r\n\t\t  if (remove) {\r\n\t\t    for (i = 0; i < this.length; i++) {\r\n\t\t      entity = this.entities[i];\r\n\t\t      if (!modelMap[entity.cid]) toRemove.push(entity);\r\n\t\t    }\r\n\t\t    if (toRemove.length) this._removeEntitys(toRemove, options);\r\n\t\t  }\r\n\r\n\t\t  // See if sorting is needed, update `length` and splice in new entities.\r\n\t\t  var orderChanged = false;\r\n\t\t  var replace = !sortable && add && remove;\r\n\t\t  if (set.length && replace) {\r\n\t\t    orderChanged = this.length !== set.length || this.entities.some(function(m, index) {\r\n\t\t      return m !== set[index];\r\n\t\t    });\r\n\t\t    this.entities.length = 0;\r\n\t\t    splice(this.entities, set, 0);\r\n\t\t    this.length = this.entities.length;\r\n\t\t  } else if (toAdd.length) {\r\n\t\t    if (sortable) sort = true;\r\n\t\t    splice(this.entities, toAdd, at == null ? this.length : at);\r\n\t\t    this.length = this.entities.length;\r\n\t\t  }\r\n\r\n\t\t  // Silently sort the collection if appropriate.\r\n\t\t  if (sort) this.sort({silent: true});\r\n\r\n\t\t  // Unless silenced, it's time to fire all appropriate add/sort/update events.\r\n\t\t  if (!options.silent) {\r\n\t\t    for (i = 0; i < toAdd.length; i++) {\r\n\t\t      if (at != null) options.index = at + i;\r\n\t\t      entity = toAdd[i];\r\n\t\t      entity.trigger('add', entity, this, options);\r\n\t\t    }\r\n\t\t    if (sort || orderChanged) this.trigger('sort', this, options);\r\n\t\t    if (toAdd.length || toRemove.length || toMerge.length) {\r\n\t\t      options.changes = {\r\n\t\t        added: toAdd,\r\n\t\t        removed: toRemove,\r\n\t\t        merged: toMerge\r\n\t\t      };\r\n\t\t      this.trigger('update', this, options);\r\n\t\t    }\r\n\t\t  }\r\n\r\n\t\t  // Return the added (or merged) entity (or entities).\r\n\t\t  return singular ? entities[0] : entities;\r\n\t\t},\r\n\r\n\t\t// When you have more items than you want to add or remove individually,\r\n\t\t// you can reset the entire set with a new list of entities, without firing\r\n\t\t// any granular `add` or `remove` events. Fires `reset` when finished.\r\n\t\t// Useful for bulk operations and optimizations.\r\n\t\treset: function(entities, options) {\r\n\t\t  options = options ? langx.clone(options) : {};\r\n\t\t  for (var i = 0; i < this.entities.length; i++) {\r\n\t\t    this._removeReference(this.entities[i], options);\r\n\t\t  }\r\n\t\t  options.previousEntitys = this.entities;\r\n\t\t  this._reset();\r\n\t\t  entities = this.add(entities, langx.mixin({silent: true}, options));\r\n\t\t  if (!options.silent) this.trigger('reset', this, options);\r\n\t\t  return entities;\r\n\t\t},\r\n\r\n\t\t// Add a entity to the end of the collection.\r\n\t\tpush: function(entity, options) {\r\n\t\t  return this.add(entity, langx.mixin({at: this.length}, options));\r\n\t\t},\r\n\r\n\t\t// Remove a entity from the end of the collection.\r\n\t\tpop: function(options) {\r\n\t\t  var entity = this.at(this.length - 1);\r\n\t\t  return this.remove(entity, options);\r\n\t\t},\r\n\r\n\t\t// Add a entity to the beginning of the collection.\r\n\t\tunshift: function(entity, options) {\r\n\t\t  return this.add(entity, langx.mixin({at: 0}, options));\r\n\t\t},\r\n\r\n\t\t// Remove a entity from the beginning of the collection.\r\n\t\tshift: function(options) {\r\n\t\t  var entity = this.at(0);\r\n\t\t  return this.remove(entity, options);\r\n\t\t},\r\n\r\n\t\t// Slice out a sub-array of entities from the collection.\r\n\t\tslice: function() {\r\n\t\t  return slice.apply(this.entities, arguments);\r\n\t\t},\r\n\r\n\t\t// Get a entity from the set by id, cid, entity object with id or cid\r\n\t\t// properties, or an attributes object that is transformed through entityId.\r\n\t\tget: function(obj) {\r\n\t\t  if (obj == null) return void 0;\r\n\t\t  return this._byId[obj] ||\r\n\t\t    this._byId[this.entityId(obj.attributes || obj)] ||\r\n\t\t    obj.cid && this._byId[obj.cid];\r\n\t\t},\r\n\r\n\t\t// Returns `true` if the entity is in the collection.\r\n\t\thas: function(obj) {\r\n\t\t  return this.get(obj) != null;\r\n\t\t},\r\n\r\n\t\t// Get the entity at the given index.\r\n\t\tat: function(index) {\r\n\t\t  if (index < 0) index += this.length;\r\n\t\t  return this.entities[index];\r\n\t\t},\r\n\r\n\t\t// Return entities with matching attributes. Useful for simple cases of\r\n\t\t// `filter`.\r\n\t\twhere: function(attrs, first) {\r\n\t\t  return this[first ? 'find' : 'filter'](attrs);\r\n\t\t},\r\n\r\n\t\t// Return the first entity with matching attributes. Useful for simple cases\r\n\t\t// of `find`.\r\n\t\tfindWhere: function(attrs) {\r\n\t\t  return this.where(attrs, true);\r\n\t\t},\r\n\r\n\t\t// Force the collection to re-sort itself. You don't need to call this under\r\n\t\t// normal circumstances, as the set will maintain sort order as each item\r\n\t\t// is added.\r\n\t\tsort: function(options) {\r\n\t\t  var comparator = this.comparator;\r\n\t\t  if (!comparator) throw new Error('Cannot sort a set without a comparator');\r\n\t\t  options || (options = {});\r\n\r\n\t\t  var length = comparator.length;\r\n\t\t  if (langx.isFunction(comparator)) comparator = langx.proxy(comparator, this);\r\n\r\n\t\t  // Run sort based on type of `comparator`.\r\n\t\t  if (length === 1 || langx.isString(comparator)) {\r\n\t\t    this.entities = this.sortBy(comparator);\r\n\t\t  } else {\r\n\t\t    this.entities.sort(comparator);\r\n\t\t  }\r\n\t\t  if (!options.silent) this.trigger('sort', this, options);\r\n\t\t  return this;\r\n\t\t},\r\n\r\n\t\t// Pluck an attribute from each entity in the collection.\r\n\t\tpluck: function(attr) {\r\n\t\t  return this.map(attr + '');\r\n\t\t},\r\n\r\n\t\t// Fetch the default set of entities for this collection, resetting the\r\n\t\t// collection when they arrive. If `reset: true` is passed, the response\r\n\t\t// data will be passed through the `reset` method instead of `set`.\r\n\t\tfetch: function(options) {\r\n\t\t  options = langx.mixin({parse: true}, options);\r\n\t\t  var success = options.success;\r\n\t\t  var collection = this;\r\n\t\t  options.success = function(resp) {\r\n\t\t    var method = options.reset ? 'reset' : 'set';\r\n\t\t    collection[method](resp, options);\r\n\t\t    if (success) success.call(options.context, collection, resp, options);\r\n\t\t    collection.trigger('sync', collection, resp, options);\r\n\t\t  };\r\n\t\t  wrapError(this, options);\r\n\t\t  return this.sync('read', this, options);\r\n\t\t},\r\n\r\n\t\t// Create a new instance of a entity in this collection. Add the entity to the\r\n\t\t// collection immediately, unless `wait: true` is passed, in which case we\r\n\t\t// wait for the server to agree.\r\n\t\tcreate: function(entity, options) {\r\n\t\t  options = options ? langx.clone(options) : {};\r\n\t\t  var wait = options.wait;\r\n\t\t  entity = this._prepareEntity(entity, options);\r\n\t\t  if (!entity) return false;\r\n\t\t  if (!wait) this.add(entity, options);\r\n\t\t  var collection = this;\r\n\t\t  var success = options.success;\r\n\t\t  options.success = function(m, resp, callbackOpts) {\r\n\t\t    if (wait) collection.add(m, callbackOpts);\r\n\t\t    if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\r\n\t\t  };\r\n\t\t  entity.save(null, options);\r\n\t\t  return entity;\r\n\t\t},\r\n\r\n\t\t// **parse** converts a response into a list of entities to be added to the\r\n\t\t// collection. The default implementation is just to pass it through.\r\n\t\tparse: function(resp, options) {\r\n\t\t  return resp;\r\n\t\t},\r\n\r\n\t\t// Create a new collection with an identical list of entities as this one.\r\n\t\tclone: function() {\r\n\t\t  return new this.constructor(this.entities, {\r\n\t\t    entity: this.entity,\r\n\t\t    comparator: this.comparator\r\n\t\t  });\r\n\t\t},\r\n\r\n\t\t// Define how to uniquely identify entities in the collection.\r\n\t\tentityId: function(attrs) {\r\n\t\t  return attrs[this.entity.prototype.idAttribute || 'id'];\r\n\t\t},\r\n\r\n\t\t// Private method to reset all internal state. Called when the collection\r\n\t\t// is first initialized or reset.\r\n\t\t_reset: function() {\r\n\t\t  this.length = 0;\r\n\t\t  this.entities = [];\r\n\t\t  this._byId  = {};\r\n\t\t},\r\n\r\n\t\t// Prepare a hash of attributes (or other entity) to be added to this\r\n\t\t// collection.\r\n\t\t_prepareEntity: function(attrs, options) {\r\n\t\t  if (this._isEntity(attrs)) {\r\n\t\t    if (!attrs.collection) attrs.collection = this;\r\n\t\t    return attrs;\r\n\t\t  }\r\n\t\t  options = options ? langx.clone(options) : {};\r\n\t\t  options.collection = this;\r\n\t\t  var entity = new this.entity(attrs, options);\r\n\t\t  if (!entity.validationError) return entity;\r\n\t\t  this.trigger('invalid', this, entity.validationError, options);\r\n\t\t  return false;\r\n\t\t},\r\n\r\n\t\t// Internal method called by both remove and set.\r\n\t\t_removeEntitys: function(entities, options) {\r\n\t\t  var removed = [];\r\n\t\t  for (var i = 0; i < entities.length; i++) {\r\n\t\t    var entity = this.get(entities[i]);\r\n\t\t    if (!entity) continue;\r\n\r\n\t\t    var index = this.indexOf(entity);\r\n\t\t    this.entities.splice(index, 1);\r\n\t\t    this.length--;\r\n\r\n\t\t    // Remove references before triggering 'remove' event to prevent an\r\n\t\t    // infinite loop. #3693\r\n\t\t    delete this._byId[entity.cid];\r\n\t\t    var id = this.entityId(entity.attributes);\r\n\t\t    if (id != null) delete this._byId[id];\r\n\r\n\t\t    if (!options.silent) {\r\n\t\t      options.index = index;\r\n\t\t      entity.trigger('remove', entity, this, options);\r\n\t\t    }\r\n\r\n\t\t    removed.push(entity);\r\n\t\t    this._removeReference(entity, options);\r\n\t\t  }\r\n\t\t  return removed;\r\n\t\t},\r\n\r\n\t\t// Method for checking whether an object should be considered a entity for\r\n\t\t// the purposes of adding to the collection.\r\n\t\t_isEntity: function(entity) {\r\n\t\t  return entity instanceof Entity;\r\n\t\t},\r\n\r\n\t\t// Internal method to create a entity's ties to a collection.\r\n\t\t_addReference: function(entity, options) {\r\n\t\t  this._byId[entity.cid] = entity;\r\n\t\t  var id = this.entityId(entity.attributes);\r\n\t\t  if (id != null) this._byId[id] = entity;\r\n\t\t  entity.on('all', this._onEntityEvent, this);\r\n\t\t},\r\n\r\n\t\t// Internal method to sever a entity's ties to a collection.\r\n\t\t_removeReference: function(entity, options) {\r\n\t\t  delete this._byId[entity.cid];\r\n\t\t  var id = this.entityId(entity.attributes);\r\n\t\t  if (id != null) delete this._byId[id];\r\n\t\t  if (this === entity.collection) delete entity.collection;\r\n\t\t  entity.off('all', this._onEntityEvent, this);\r\n\t\t},\r\n\r\n\t\t// Internal method called every time a entity in the set fires an event.\r\n\t\t// Sets need to update their indexes when entities change ids. All other\r\n\t\t// events simply proxy through. \"add\" and \"remove\" events that originate\r\n\t\t// in other collections are ignored.\r\n\t\t_onEntityEvent: function(event, entity, collection, options) {\r\n\t\t  if (entity) {\r\n\t\t    if ((event === 'add' || event === 'remove') && collection !== this) return;\r\n\t\t    if (event === 'destroy') this.remove(entity, options);\r\n\t\t    if (event === 'change') {\r\n\t\t      var prevId = this.entityId(entity.previousAttributes());\r\n\t\t      var id = this.entityId(entity.attributes);\r\n\t\t      if (prevId !== id) {\r\n\t\t        if (prevId != null) delete this._byId[prevId];\r\n\t\t        if (id != null) this._byId[id] = entity;\r\n\t\t      }\r\n\t\t    }\r\n\t\t  }\r\n\t\t  this.trigger.apply(this, arguments);\r\n\t\t}\r\n\r\n  \t});\r\n\r\n\treturn entities.Collection = Collection;\r\n});"]}