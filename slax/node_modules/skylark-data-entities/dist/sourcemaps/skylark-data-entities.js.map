{"version":3,"sources":["skylark-data-entities.js"],"names":["define","langx","entities","mixin","emulateHTTP","emulateJSON","backends","wrapError","model","options","error","resp","call","context","trigger","Entity","Stateful","inherit","sync","apply","this","arguments","matches","attrs","isMatch","attributes","fetch","entity","success","parse","serverAttrs","set","save","key","val","wait","validate","_validate","method","isNew","patch","xhr","destroy","clone","stopListening","collection","defer","url","base","result","urlError","id","get","idAttribute","replace","encodeURIComponent","Collection","Evented","_construct","comparator","_reset","reset","silent","setOptions","add","remove","merge","addOptions","splice","array","insert","at","Math","min","max","length","i","tail","Array","partial","initialize","toJSON","map","singular","isArray","slice","removed","_removeEntitys","changes","added","merged","_isEntity","toAdd","toMerge","toRemove","modelMap","sort","sortable","sortAttr","isString","existing","push","hasChanged","cid","_prepareEntity","_addReference","orderChanged","some","m","index","_removeReference","previousEntitys","pop","unshift","shift","obj","_byId","entityId","has","where","first","findWhere","Error","isFunction","proxy","sortBy","pluck","attr","create","callbackOpts","constructor","prototype","validationError","indexOf","on","_onEntityEvent","off","event","prevId","previousAttributes","providers","name","setting","provides","registry","backend","syncMethod","options2","methodMap","update","delete","read","ajaxSync","type","defaults","params","dataType","data","contentType","JSON","stringify","_method","beforeSend","setRequestHeader","processData","textStatus","errorThrown","Xhr","request","S4","random","toString","substring","LocalStorage","klass","store","localStorage","getItem","records","split","setItem","join","find","_","include","jsonData","findAll","chain","compact","value","removeItem","reject","errorMessage","syncDfd","Deferred","undefined","code","DOMException","QUOTA_EXCEEDED_ERR","window","message","resolve","complete","promise","localSync","main"],"mappings":"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","file":"../skylark-data-entities.js","sourcesContent":["define('skylark-data-entities/entities',[\r\n    \"skylark-langx/langx\"\r\n], function(langx) {\r\n    function entities() {\r\n        return entities;\r\n    }\r\n\r\n    langx.mixin(entities, {\r\n        // set a `X-Http-Method-Override` header.\r\n        emulateHTTP : false,\r\n\r\n        // Turn on `emulateJSON` to support legacy servers that can't deal with direct\r\n        // `application/json` requests ... this will encode the body as\r\n        // `application/x-www-form-urlencoded` instead and will send the model in a\r\n        // form param named `model`.\r\n        emulateJSON : false,\r\n\r\n        backends : {\r\n            \r\n        }\r\n    });\r\n\r\n\r\n    return entities;\r\n});\r\n\ndefine('skylark-data-entities/Entity',[\r\n\t\"skylark-langx/langx\",\r\n\t\"./entities\"\r\n],function(langx,entities){\r\n   // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function(model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error.call(options.context, model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n \r\n  var Entity = langx.Stateful.inherit({\r\n    sync: function() {\r\n      return entities.sync.apply(this, arguments);\r\n    },\r\n\r\n    // Get the HTML-escaped value of an attribute.\r\n    //escape: function(attr) {\r\n    //  return _.escape(this.get(attr));\r\n    //},\r\n\r\n    // Special-cased proxy to underscore's `_.matches` method.\r\n    matches: function(attrs) {\r\n      return langx.isMatch(this.attributes,attrs);\r\n    },\r\n\r\n    // Fetch the entity from the server, merging the response with the entity's\r\n    // local attributes. Any changed attributes will trigger a \"change\" event.\r\n    fetch: function(options) {\r\n      options = langx.mixin({parse: true}, options);\r\n      var entity = this;\r\n      var success = options.success;\r\n      options.success = function(resp) {\r\n        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;\r\n        if (!entity.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        entity.trigger('sync', entity, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n      return this.sync('read', this, options);\r\n    },\r\n\r\n    // Set a hash of entity attributes, and sync the entity to the server.\r\n    // If the server returns an attributes hash that differs, the entity's\r\n    // state will be `set` again.\r\n    save: function(key, val, options) {\r\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\r\n      var attrs;\r\n      if (key == null || typeof key === 'object') {\r\n        attrs = key;\r\n        options = val;\r\n      } else {\r\n        (attrs = {})[key] = val;\r\n      }\r\n\r\n      options = langx.mixin({validate: true, parse: true}, options);\r\n      var wait = options.wait;\r\n\r\n      // If we're not waiting and attributes exist, save acts as\r\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\r\n      // the entity will be valid when the attributes, if any, are set.\r\n      if (attrs && !wait) {\r\n        if (!this.set(attrs, options)) return false;\r\n      } else if (!this._validate(attrs, options)) {\r\n        return false;\r\n      }\r\n\r\n      // After a successful server-side save, the client is (optionally)\r\n      // updated with the server-side state.\r\n      var entity = this;\r\n      var success = options.success;\r\n      var attributes = this.attributes;\r\n      options.success = function(resp) {\r\n        // Ensure attributes are restored during synchronous saves.\r\n        entity.attributes = attributes;\r\n        var serverAttrs = options.parse ? entity.parse(resp, options) : resp;\r\n        if (wait) serverAttrs = langx.mixin({}, attrs, serverAttrs);\r\n        if (serverAttrs && !entity.set(serverAttrs, options)) return false;\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        entity.trigger('sync', entity, resp, options);\r\n      };\r\n      wrapError(this, options);\r\n\r\n      // Set temporary attributes if `{wait: true}` to properly find new ids.\r\n      if (attrs && wait) this.attributes = langx.mixin({}, attributes, attrs);\r\n\r\n      var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\r\n      if (method === 'patch' && !options.attrs) options.attrs = attrs;\r\n      var xhr = this.sync(method, this, options);\r\n\r\n      // Restore attributes.\r\n      this.attributes = attributes;\r\n\r\n      return xhr;\r\n    },\r\n\r\n    // Destroy this entity on the server if it was already persisted.\r\n    // Optimistically removes the entity from its collection, if it has one.\r\n    // If `wait: true` is passed, waits for the server to respond before removal.\r\n    destroy: function(options) {\r\n      options = options ? langx.clone(options) : {};\r\n      var entity = this;\r\n      var success = options.success;\r\n      var wait = options.wait;\r\n\r\n      var destroy = function() {\r\n        entity.stopListening();\r\n        entity.trigger('destroy', entity, entity.collection, options);\r\n      };\r\n\r\n      options.success = function(resp) {\r\n        if (wait) destroy();\r\n        if (success) success.call(options.context, entity, resp, options);\r\n        if (!entity.isNew()) entity.trigger('sync', entity, resp, options);\r\n      };\r\n\r\n      var xhr = false;\r\n      if (this.isNew()) {\r\n        langx.defer(options.success);\r\n      } else {\r\n        wrapError(this, options);\r\n        xhr = this.sync('delete', this, options);\r\n      }\r\n      if (!wait) destroy();\r\n      return xhr;\r\n    },\r\n\r\n    // Default URL for the entity's representation on the server -- if you're\r\n    // using Backbone's restful methods, override this to change the endpoint\r\n    // that will be called.\r\n    url: function() {\r\n      var base =\r\n        langx.result(this, 'urlRoot') ||\r\n        langx.result(this.collection, 'url') ||\r\n        urlError();\r\n      if (this.isNew()) return base;\r\n      var id = this.get(this.idAttribute);\r\n      return base.replace(/[^\\/]$/, '$&/') + encodeURIComponent(id);\r\n    },\r\n\r\n    // **parse** converts a response into the hash of attributes to be `set` on\r\n    // the entity. The default implementation is just to pass the response along.\r\n    parse: function(resp, options) {\r\n      return resp;\r\n    }\r\n  });\r\n\r\n  return entities.Entity = Entity;\r\n\r\n});\ndefine('skylark-data-entities/Collection',[\r\n\t\"skylark-langx/langx\",\r\n\t\"./entities\",\r\n\t\"./Entity\"\r\n],function(langx,entities,Entity){\r\n  // Wrap an optional error callback with a fallback error event.\r\n  var wrapError = function(model, options) {\r\n    var error = options.error;\r\n    options.error = function(resp) {\r\n      if (error) error.call(options.context, model, resp, options);\r\n      model.trigger('error', model, resp, options);\r\n    };\r\n  };\r\n\r\n\r\n\tvar Collection  = langx.Evented.inherit({\r\n\t\t\"_construct\" : function(entities, options) {\r\n\t\t\toptions || (options = {});\r\n\t\t\tif (options.entity) this.entity = options.entity;\r\n\t\t\tif (options.comparator !== void 0) this.comparator = options.comparator;\r\n\t\t\tthis._reset();\r\n\t\t\tif (entities) this.reset(entities, langx.mixin({silent: true}, options));\r\n\t\t}\r\n\t}); \r\n\r\n\t// Default options for `Collection#set`.\r\n\tvar setOptions = {add: true, remove: true, merge: true};\r\n\tvar addOptions = {add: true, remove: false};\r\n\r\n\t// Splices `insert` into `array` at index `at`.\r\n\tvar splice = function(array, insert, at) {\r\n\t\tat = Math.min(Math.max(at, 0), array.length);\r\n\t\tvar tail = Array(array.length - at);\r\n\t\tvar length = insert.length;\r\n\t\tvar i;\r\n\t\tfor (i = 0; i < tail.length; i++) tail[i] = array[i + at];\r\n\t\tfor (i = 0; i < length; i++) array[i + at] = insert[i];\r\n\t\tfor (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\r\n\t};\r\n\r\n  // Define the Collection's inheritable methods.\r\n\tCollection.partial({\r\n\r\n\t\t// The default entity for a collection is just a **Entity**.\r\n\t\t// This should be overridden in most cases.\r\n\t\tentity: Entity,\r\n\r\n\t\t// Initialize is an empty function by default. Override it with your own\r\n\t\t// initialization logic.\r\n\t\tinitialize: function(){},\r\n\r\n\t\t// The JSON representation of a Collection is an array of the\r\n\t\t// entities' attributes.\r\n\t\ttoJSON: function(options) {\r\n\t\t  return this.map(function(entity) { return entity.toJSON(options); });\r\n\t\t},\r\n\r\n\t\t// Proxy `entities.sync` by default.\r\n\t\tsync: function() {\r\n\t\t  return entities.sync.apply(this, arguments);\r\n\t\t},\r\n\r\n\t\t// Add a entity, or list of entities to the set. `entities` may be Backbone\r\n\t\t// Entitys or raw JavaScript objects to be converted to Entitys, or any\r\n\t\t// combination of the two.\r\n\t\tadd: function(entities, options) {\r\n\t\t  return this.set(entities, langx.mixin({merge: false}, options, addOptions));\r\n\t\t},\r\n\r\n\t\t// Remove a entity, or a list of entities from the set.\r\n\t\tremove: function(entities, options) {\r\n\t\t  options = langx.mixin({}, options);\r\n\t\t  var singular = !langx.isArray(entities);\r\n\t\t  entities = singular ? [entities] : entities.slice();\r\n\t\t  var removed = this._removeEntitys(entities, options);\r\n\t\t  if (!options.silent && removed.length) {\r\n\t\t    options.changes = {added: [], merged: [], removed: removed};\r\n\t\t    this.trigger('update', this, options);\r\n\t\t  }\r\n\t\t  return singular ? removed[0] : removed;\r\n\t\t},\r\n\r\n\t\t// Update a collection by `set`-ing a new list of entities, adding new ones,\r\n\t\t// removing entities that are no longer present, and merging entities that\r\n\t\t// already exist in the collection, as necessary. Similar to **Entity#set**,\r\n\t\t// the core operation for updating the data contained by the collection.\r\n\t\tset: function(entities, options) {\r\n\t\t  if (entities == null) return;\r\n\r\n\t\t  options = langx.mixin({}, setOptions, options);\r\n\t\t  if (options.parse && !this._isEntity(entities)) {\r\n\t\t    entities = this.parse(entities, options) || [];\r\n\t\t  }\r\n\r\n\t\t  var singular = !langx.isArray(entities);\r\n\t\t  entities = singular ? [entities] : entities.slice();\r\n\r\n\t\t  var at = options.at;\r\n\t\t  if (at != null) at = +at;\r\n\t\t  if (at > this.length) at = this.length;\r\n\t\t  if (at < 0) at += this.length + 1;\r\n\r\n\t\t  var set = [];\r\n\t\t  var toAdd = [];\r\n\t\t  var toMerge = [];\r\n\t\t  var toRemove = [];\r\n\t\t  var modelMap = {};\r\n\r\n\t\t  var add = options.add;\r\n\t\t  var merge = options.merge;\r\n\t\t  var remove = options.remove;\r\n\r\n\t\t  var sort = false;\r\n\t\t  var sortable = this.comparator && at == null && options.sort !== false;\r\n\t\t  var sortAttr = langx.isString(this.comparator) ? this.comparator : null;\r\n\r\n\t\t  // Turn bare objects into entity references, and prevent invalid entities\r\n\t\t  // from being added.\r\n\t\t  var entity, i;\r\n\t\t  for (i = 0; i < entities.length; i++) {\r\n\t\t    entity = entities[i];\r\n\r\n\t\t    // If a duplicate is found, prevent it from being added and\r\n\t\t    // optionally merge it into the existing entity.\r\n\t\t    var existing = this.get(entity);\r\n\t\t    if (existing) {\r\n\t\t      if (merge && entity !== existing) {\r\n\t\t        var attrs = this._isEntity(entity) ? entity.attributes : entity;\r\n\t\t        if (options.parse) attrs = existing.parse(attrs, options);\r\n\t\t        existing.set(attrs, options);\r\n\t\t        toMerge.push(existing);\r\n\t\t        if (sortable && !sort) sort = existing.hasChanged(sortAttr);\r\n\t\t      }\r\n\t\t      if (!modelMap[existing.cid]) {\r\n\t\t        modelMap[existing.cid] = true;\r\n\t\t        set.push(existing);\r\n\t\t      }\r\n\t\t      entities[i] = existing;\r\n\r\n\t\t    // If this is a new, valid entity, push it to the `toAdd` list.\r\n\t\t    } else if (add) {\r\n\t\t      entity = entities[i] = this._prepareEntity(entity, options);\r\n\t\t      if (entity) {\r\n\t\t        toAdd.push(entity);\r\n\t\t        this._addReference(entity, options);\r\n\t\t        modelMap[entity.cid] = true;\r\n\t\t        set.push(entity);\r\n\t\t      }\r\n\t\t    }\r\n\t\t  }\r\n\r\n\t\t  // Remove stale entities.\r\n\t\t  if (remove) {\r\n\t\t    for (i = 0; i < this.length; i++) {\r\n\t\t      entity = this.entities[i];\r\n\t\t      if (!modelMap[entity.cid]) toRemove.push(entity);\r\n\t\t    }\r\n\t\t    if (toRemove.length) this._removeEntitys(toRemove, options);\r\n\t\t  }\r\n\r\n\t\t  // See if sorting is needed, update `length` and splice in new entities.\r\n\t\t  var orderChanged = false;\r\n\t\t  var replace = !sortable && add && remove;\r\n\t\t  if (set.length && replace) {\r\n\t\t    orderChanged = this.length !== set.length || this.entities.some(function(m, index) {\r\n\t\t      return m !== set[index];\r\n\t\t    });\r\n\t\t    this.entities.length = 0;\r\n\t\t    splice(this.entities, set, 0);\r\n\t\t    this.length = this.entities.length;\r\n\t\t  } else if (toAdd.length) {\r\n\t\t    if (sortable) sort = true;\r\n\t\t    splice(this.entities, toAdd, at == null ? this.length : at);\r\n\t\t    this.length = this.entities.length;\r\n\t\t  }\r\n\r\n\t\t  // Silently sort the collection if appropriate.\r\n\t\t  if (sort) this.sort({silent: true});\r\n\r\n\t\t  // Unless silenced, it's time to fire all appropriate add/sort/update events.\r\n\t\t  if (!options.silent) {\r\n\t\t    for (i = 0; i < toAdd.length; i++) {\r\n\t\t      if (at != null) options.index = at + i;\r\n\t\t      entity = toAdd[i];\r\n\t\t      entity.trigger('add', entity, this, options);\r\n\t\t    }\r\n\t\t    if (sort || orderChanged) this.trigger('sort', this, options);\r\n\t\t    if (toAdd.length || toRemove.length || toMerge.length) {\r\n\t\t      options.changes = {\r\n\t\t        added: toAdd,\r\n\t\t        removed: toRemove,\r\n\t\t        merged: toMerge\r\n\t\t      };\r\n\t\t      this.trigger('update', this, options);\r\n\t\t    }\r\n\t\t  }\r\n\r\n\t\t  // Return the added (or merged) entity (or entities).\r\n\t\t  return singular ? entities[0] : entities;\r\n\t\t},\r\n\r\n\t\t// When you have more items than you want to add or remove individually,\r\n\t\t// you can reset the entire set with a new list of entities, without firing\r\n\t\t// any granular `add` or `remove` events. Fires `reset` when finished.\r\n\t\t// Useful for bulk operations and optimizations.\r\n\t\treset: function(entities, options) {\r\n\t\t  options = options ? langx.clone(options) : {};\r\n\t\t  for (var i = 0; i < this.entities.length; i++) {\r\n\t\t    this._removeReference(this.entities[i], options);\r\n\t\t  }\r\n\t\t  options.previousEntitys = this.entities;\r\n\t\t  this._reset();\r\n\t\t  entities = this.add(entities, langx.mixin({silent: true}, options));\r\n\t\t  if (!options.silent) this.trigger('reset', this, options);\r\n\t\t  return entities;\r\n\t\t},\r\n\r\n\t\t// Add a entity to the end of the collection.\r\n\t\tpush: function(entity, options) {\r\n\t\t  return this.add(entity, langx.mixin({at: this.length}, options));\r\n\t\t},\r\n\r\n\t\t// Remove a entity from the end of the collection.\r\n\t\tpop: function(options) {\r\n\t\t  var entity = this.at(this.length - 1);\r\n\t\t  return this.remove(entity, options);\r\n\t\t},\r\n\r\n\t\t// Add a entity to the beginning of the collection.\r\n\t\tunshift: function(entity, options) {\r\n\t\t  return this.add(entity, langx.mixin({at: 0}, options));\r\n\t\t},\r\n\r\n\t\t// Remove a entity from the beginning of the collection.\r\n\t\tshift: function(options) {\r\n\t\t  var entity = this.at(0);\r\n\t\t  return this.remove(entity, options);\r\n\t\t},\r\n\r\n\t\t// Slice out a sub-array of entities from the collection.\r\n\t\tslice: function() {\r\n\t\t  return slice.apply(this.entities, arguments);\r\n\t\t},\r\n\r\n\t\t// Get a entity from the set by id, cid, entity object with id or cid\r\n\t\t// properties, or an attributes object that is transformed through entityId.\r\n\t\tget: function(obj) {\r\n\t\t  if (obj == null) return void 0;\r\n\t\t  return this._byId[obj] ||\r\n\t\t    this._byId[this.entityId(obj.attributes || obj)] ||\r\n\t\t    obj.cid && this._byId[obj.cid];\r\n\t\t},\r\n\r\n\t\t// Returns `true` if the entity is in the collection.\r\n\t\thas: function(obj) {\r\n\t\t  return this.get(obj) != null;\r\n\t\t},\r\n\r\n\t\t// Get the entity at the given index.\r\n\t\tat: function(index) {\r\n\t\t  if (index < 0) index += this.length;\r\n\t\t  return this.entities[index];\r\n\t\t},\r\n\r\n\t\t// Return entities with matching attributes. Useful for simple cases of\r\n\t\t// `filter`.\r\n\t\twhere: function(attrs, first) {\r\n\t\t  return this[first ? 'find' : 'filter'](attrs);\r\n\t\t},\r\n\r\n\t\t// Return the first entity with matching attributes. Useful for simple cases\r\n\t\t// of `find`.\r\n\t\tfindWhere: function(attrs) {\r\n\t\t  return this.where(attrs, true);\r\n\t\t},\r\n\r\n\t\t// Force the collection to re-sort itself. You don't need to call this under\r\n\t\t// normal circumstances, as the set will maintain sort order as each item\r\n\t\t// is added.\r\n\t\tsort: function(options) {\r\n\t\t  var comparator = this.comparator;\r\n\t\t  if (!comparator) throw new Error('Cannot sort a set without a comparator');\r\n\t\t  options || (options = {});\r\n\r\n\t\t  var length = comparator.length;\r\n\t\t  if (langx.isFunction(comparator)) comparator = langx.proxy(comparator, this);\r\n\r\n\t\t  // Run sort based on type of `comparator`.\r\n\t\t  if (length === 1 || langx.isString(comparator)) {\r\n\t\t    this.entities = this.sortBy(comparator);\r\n\t\t  } else {\r\n\t\t    this.entities.sort(comparator);\r\n\t\t  }\r\n\t\t  if (!options.silent) this.trigger('sort', this, options);\r\n\t\t  return this;\r\n\t\t},\r\n\r\n\t\t// Pluck an attribute from each entity in the collection.\r\n\t\tpluck: function(attr) {\r\n\t\t  return this.map(attr + '');\r\n\t\t},\r\n\r\n\t\t// Fetch the default set of entities for this collection, resetting the\r\n\t\t// collection when they arrive. If `reset: true` is passed, the response\r\n\t\t// data will be passed through the `reset` method instead of `set`.\r\n\t\tfetch: function(options) {\r\n\t\t  options = langx.mixin({parse: true}, options);\r\n\t\t  var success = options.success;\r\n\t\t  var collection = this;\r\n\t\t  options.success = function(resp) {\r\n\t\t    var method = options.reset ? 'reset' : 'set';\r\n\t\t    collection[method](resp, options);\r\n\t\t    if (success) success.call(options.context, collection, resp, options);\r\n\t\t    collection.trigger('sync', collection, resp, options);\r\n\t\t  };\r\n\t\t  wrapError(this, options);\r\n\t\t  return this.sync('read', this, options);\r\n\t\t},\r\n\r\n\t\t// Create a new instance of a entity in this collection. Add the entity to the\r\n\t\t// collection immediately, unless `wait: true` is passed, in which case we\r\n\t\t// wait for the server to agree.\r\n\t\tcreate: function(entity, options) {\r\n\t\t  options = options ? langx.clone(options) : {};\r\n\t\t  var wait = options.wait;\r\n\t\t  entity = this._prepareEntity(entity, options);\r\n\t\t  if (!entity) return false;\r\n\t\t  if (!wait) this.add(entity, options);\r\n\t\t  var collection = this;\r\n\t\t  var success = options.success;\r\n\t\t  options.success = function(m, resp, callbackOpts) {\r\n\t\t    if (wait) collection.add(m, callbackOpts);\r\n\t\t    if (success) success.call(callbackOpts.context, m, resp, callbackOpts);\r\n\t\t  };\r\n\t\t  entity.save(null, options);\r\n\t\t  return entity;\r\n\t\t},\r\n\r\n\t\t// **parse** converts a response into a list of entities to be added to the\r\n\t\t// collection. The default implementation is just to pass it through.\r\n\t\tparse: function(resp, options) {\r\n\t\t  return resp;\r\n\t\t},\r\n\r\n\t\t// Create a new collection with an identical list of entities as this one.\r\n\t\tclone: function() {\r\n\t\t  return new this.constructor(this.entities, {\r\n\t\t    entity: this.entity,\r\n\t\t    comparator: this.comparator\r\n\t\t  });\r\n\t\t},\r\n\r\n\t\t// Define how to uniquely identify entities in the collection.\r\n\t\tentityId: function(attrs) {\r\n\t\t  return attrs[this.entity.prototype.idAttribute || 'id'];\r\n\t\t},\r\n\r\n\t\t// Private method to reset all internal state. Called when the collection\r\n\t\t// is first initialized or reset.\r\n\t\t_reset: function() {\r\n\t\t  this.length = 0;\r\n\t\t  this.entities = [];\r\n\t\t  this._byId  = {};\r\n\t\t},\r\n\r\n\t\t// Prepare a hash of attributes (or other entity) to be added to this\r\n\t\t// collection.\r\n\t\t_prepareEntity: function(attrs, options) {\r\n\t\t  if (this._isEntity(attrs)) {\r\n\t\t    if (!attrs.collection) attrs.collection = this;\r\n\t\t    return attrs;\r\n\t\t  }\r\n\t\t  options = options ? langx.clone(options) : {};\r\n\t\t  options.collection = this;\r\n\t\t  var entity = new this.entity(attrs, options);\r\n\t\t  if (!entity.validationError) return entity;\r\n\t\t  this.trigger('invalid', this, entity.validationError, options);\r\n\t\t  return false;\r\n\t\t},\r\n\r\n\t\t// Internal method called by both remove and set.\r\n\t\t_removeEntitys: function(entities, options) {\r\n\t\t  var removed = [];\r\n\t\t  for (var i = 0; i < entities.length; i++) {\r\n\t\t    var entity = this.get(entities[i]);\r\n\t\t    if (!entity) continue;\r\n\r\n\t\t    var index = this.indexOf(entity);\r\n\t\t    this.entities.splice(index, 1);\r\n\t\t    this.length--;\r\n\r\n\t\t    // Remove references before triggering 'remove' event to prevent an\r\n\t\t    // infinite loop. #3693\r\n\t\t    delete this._byId[entity.cid];\r\n\t\t    var id = this.entityId(entity.attributes);\r\n\t\t    if (id != null) delete this._byId[id];\r\n\r\n\t\t    if (!options.silent) {\r\n\t\t      options.index = index;\r\n\t\t      entity.trigger('remove', entity, this, options);\r\n\t\t    }\r\n\r\n\t\t    removed.push(entity);\r\n\t\t    this._removeReference(entity, options);\r\n\t\t  }\r\n\t\t  return removed;\r\n\t\t},\r\n\r\n\t\t// Method for checking whether an object should be considered a entity for\r\n\t\t// the purposes of adding to the collection.\r\n\t\t_isEntity: function(entity) {\r\n\t\t  return entity instanceof Entity;\r\n\t\t},\r\n\r\n\t\t// Internal method to create a entity's ties to a collection.\r\n\t\t_addReference: function(entity, options) {\r\n\t\t  this._byId[entity.cid] = entity;\r\n\t\t  var id = this.entityId(entity.attributes);\r\n\t\t  if (id != null) this._byId[id] = entity;\r\n\t\t  entity.on('all', this._onEntityEvent, this);\r\n\t\t},\r\n\r\n\t\t// Internal method to sever a entity's ties to a collection.\r\n\t\t_removeReference: function(entity, options) {\r\n\t\t  delete this._byId[entity.cid];\r\n\t\t  var id = this.entityId(entity.attributes);\r\n\t\t  if (id != null) delete this._byId[id];\r\n\t\t  if (this === entity.collection) delete entity.collection;\r\n\t\t  entity.off('all', this._onEntityEvent, this);\r\n\t\t},\r\n\r\n\t\t// Internal method called every time a entity in the set fires an event.\r\n\t\t// Sets need to update their indexes when entities change ids. All other\r\n\t\t// events simply proxy through. \"add\" and \"remove\" events that originate\r\n\t\t// in other collections are ignored.\r\n\t\t_onEntityEvent: function(event, entity, collection, options) {\r\n\t\t  if (entity) {\r\n\t\t    if ((event === 'add' || event === 'remove') && collection !== this) return;\r\n\t\t    if (event === 'destroy') this.remove(entity, options);\r\n\t\t    if (event === 'change') {\r\n\t\t      var prevId = this.entityId(entity.previousAttributes());\r\n\t\t      var id = this.entityId(entity.attributes);\r\n\t\t      if (prevId !== id) {\r\n\t\t        if (prevId != null) delete this._byId[prevId];\r\n\t\t        if (id != null) this._byId[id] = entity;\r\n\t\t      }\r\n\t\t    }\r\n\t\t  }\r\n\t\t  this.trigger.apply(this, arguments);\r\n\t\t}\r\n\r\n  \t});\r\n\r\n\treturn entities.Collection = Collection;\r\n});\ndefine('skylark-data-entities/backends/registry',[\r\n\t\r\n],function(){\r\n\tvar providers = {\r\n\r\n\t};\r\n\r\n\tfunction add(name,setting) {\r\n\t\tproviders[name] = setting;\r\n\t}\r\n\r\n\tfunction remove(name) {\r\n\t\tdelete provides[name];\r\n\t}\r\n\r\n\tfunction get(name) {\r\n\t\treturn providers[name];\r\n\t}\r\n\r\n\treturn {\r\n\t\tadd : add,\r\n\t\tremove: remove,\r\n\t\tget : get\r\n\t}\r\n});\ndefine('skylark-data-entities/sync',[\r\n\t\"skylark-langx/langx\",\r\n\t\"./entities\",\r\n  \t\"./backends/registry\"\r\n],function(langx,entities,registry){\r\n\r\n\t// Override 'Backbone.sync' to default to localSync,\r\n\t// the original 'Backbone.sync' is still available in 'Backbone.ajaxSync'\r\n\tfunction sync(method, model, options) {\r\n\t\tif (!options.backend) {\r\n\t\t\tthrow new Error(\"The backend is not specified\")\r\n\t\t}\r\n\t\tvar setting = registry.get(options.backend);\r\n\t\tif (!setting) {\r\n\t\t\tthrow new Error(\"The backend is not defined:\" + options.backend);\r\n\t\t}\r\n\t\tvar syncMethod = setting.sync;\r\n\t\tif (!syncMethod) {\r\n\t\t\tthrow new Error(\"The backend sync method is not defined:\" + options.backend);\r\n\t\t}\r\n\r\n\t\tvar options2 = langx.mixin({},setting.options,options);\r\n\t  \treturn syncMethod.apply(this, [method, model, options2]);\r\n\t};\r\n\r\n  \r\n   return entities.sync = sync;\r\n\r\n});\ndefine('skylark-data-entities/backends/ajaxSync',[\r\n\t\"skylark-langx/langx\",\r\n\t\"../entities\"\r\n],function(langx,entities){\r\n// Map from CRUD to HTTP for our default `Backbone.sync` implementation.\r\n  var methodMap = {\r\n    'create': 'POST',\r\n    'update': 'PUT',\r\n    'patch': 'PATCH',\r\n    'delete': 'DELETE',\r\n    'read': 'GET'\r\n  };\r\n  \r\n\r\n  var sync = function(method, entity, options) {\r\n    var type = methodMap[method];\r\n\r\n    // Default options, unless specified.\r\n    langx.defaults(options || (options = {}), {\r\n      emulateHTTP: entities.emulateHTTP,\r\n      emulateJSON: entities.emulateJSON\r\n    });\r\n\r\n    // Default JSON-request options.\r\n    var params = {type: type, dataType: 'json'};\r\n\r\n    // Ensure that we have a URL.\r\n    if (!options.url) {\r\n      params.url = langx.result(entity, 'url') || urlError();\r\n    }\r\n\r\n    // Ensure that we have the appropriate request data.\r\n    if (options.data == null && entity && (method === 'create' || method === 'update' || method === 'patch')) {\r\n      params.contentType = 'application/json';\r\n      params.data = JSON.stringify(options.attrs || entity.toJSON(options));\r\n    }\r\n\r\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\r\n    if (options.emulateJSON) {\r\n      params.contentType = 'application/x-www-form-urlencoded';\r\n      params.data = params.data ? {entity: params.data} : {};\r\n    }\r\n\r\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\r\n    // And an `X-HTTP-Method-Override` header.\r\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\r\n      params.type = 'POST';\r\n      if (options.emulateJSON) params.data._method = type;\r\n      var beforeSend = options.beforeSend;\r\n      options.beforeSend = function(xhr) {\r\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\r\n        if (beforeSend) return beforeSend.apply(this, arguments);\r\n      };\r\n    }\r\n\r\n    // Don't process data on a non-GET request.\r\n    if (params.type !== 'GET' && !options.emulateJSON) {\r\n      params.processData = false;\r\n    }\r\n\r\n    // Pass along `textStatus` and `errorThrown` from jQuery.\r\n    var error = options.error;\r\n    options.error = function(xhr, textStatus, errorThrown) {\r\n      options.textStatus = textStatus;\r\n      options.errorThrown = errorThrown;\r\n      if (error) error.call(options.context, xhr, textStatus, errorThrown);\r\n    };\r\n\r\n    // Make the request, allowing the user to override any Ajax options.\r\n    var xhr = options.xhr = langx.Xhr.request(langx.mixin(params, options));\r\n    entity.trigger('request', entity, xhr, options);\r\n    return xhr;\r\n  };\r\n\r\n \r\n  \r\n  return entities.backends.ajaxSync = sync;\r\n\r\n});\ndefine('skylark-data-entities/backends/localSync',[\r\n  \"skylark-langx/langx\",\r\n  \"../entities\"\r\n],function(langx,entities){\r\n\r\n  // A simple module to replace `Backbone.sync` with *localStorage*-based\r\n  // persistence. Models are given GUIDS, and saved into a JSON object. Simple\r\n  // as that.\r\n\r\n  // Hold reference to Underscore.js and Backbone.js in the closure in order\r\n  // to make things work even if they are removed from the global namespace\r\n\r\n  // Generate four random hex digits.\r\n  function S4() {\r\n     return (((1+Math.random())*0x10000)|0).toString(16).substring(1);\r\n  };\r\n\r\n  // Generate a pseudo-GUID by concatenating random hexadecimal.\r\n  function guid() {\r\n     return (S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4());\r\n  };\r\n\r\n  // Our Store is represented by a single JS object in *localStorage*. Create it\r\n  // with a meaningful name, like the name you'd give a table.\r\n  // window.Store is deprecated, use Backbone.LocalStorage instead\r\n  var LocalStorage = langx.klass({\r\n    _construct : function(name) {\r\n      this.name = name;\r\n      var store = this.localStorage().getItem(this.name);\r\n      this.records = (store && store.split(\",\")) || [];\r\n    },\r\n\r\n    // Save the current state of the **Store** to *localStorage*.\r\n    save: function() {\r\n      this.localStorage().setItem(this.name, this.records.join(\",\"));\r\n    },\r\n\r\n    // Add a model, giving it a (hopefully)-unique GUID, if it doesn't already\r\n    // have an id of it's own.\r\n    create: function(model) {\r\n      if (!model.id) {\r\n        model.id = guid();\r\n        model.set(model.idAttribute, model.id);\r\n      }\r\n      this.localStorage().setItem(this.name+\"-\"+model.id, JSON.stringify(model));\r\n      this.records.push(model.id.toString());\r\n      this.save();\r\n      return this.find(model);\r\n    },\r\n\r\n    // Update a model by replacing its copy in `this.data`.\r\n    update: function(model) {\r\n      this.localStorage().setItem(this.name+\"-\"+model.id, JSON.stringify(model));\r\n      if (!_.include(this.records, model.id.toString()))\r\n        this.records.push(model.id.toString()); this.save();\r\n      return this.find(model);\r\n    },\r\n\r\n    // Retrieve a model from `this.data` by id.\r\n    find: function(model) {\r\n      return this.jsonData(this.localStorage().getItem(this.name+\"-\"+model.id));\r\n    },\r\n\r\n    // Return the array of all entities currently in storage.\r\n    findAll: function() {\r\n      return _(this.records).chain()\r\n        .map(function(id){\r\n          return this.jsonData(this.localStorage().getItem(this.name+\"-\"+id));\r\n        }, this)\r\n        .compact()\r\n        .value();\r\n    },\r\n\r\n    // Delete a model from `this.data`, returning it.\r\n    destroy: function(model) {\r\n      if (model.isNew())\r\n        return false\r\n      this.localStorage().removeItem(this.name+\"-\"+model.id);\r\n      this.records = _.reject(this.records, function(id){\r\n        return id === model.id.toString();\r\n      });\r\n      this.save();\r\n      return model;\r\n    },\r\n\r\n    localStorage: function() {\r\n      return localStorage;\r\n    },\r\n\r\n    // fix for \"illegal access\" error on Android when JSON.parse is passed null\r\n    jsonData: function (data) {\r\n        return data && JSON.parse(data);\r\n    }\r\n\r\n  });\r\n\r\n  // localSync delegate to the model or collection's\r\n  // *localStorage* property, which should be an instance of `Store`.\r\n  function sync(method, model, options) {\r\n    var store = model.localStorage || model.collection.localStorage;\r\n\r\n    var resp, errorMessage, syncDfd = langx.Deferred(); //If $ is having Deferred - use it.\r\n\r\n    try {\r\n\r\n      switch (method) {\r\n        case \"read\":\r\n          resp = model.id != undefined ? store.find(model) : store.findAll();\r\n          break;\r\n        case \"create\":\r\n          resp = store.create(model);\r\n          break;\r\n        case \"update\":\r\n          resp = store.update(model);\r\n          break;\r\n        case \"delete\":\r\n          resp = store.destroy(model);\r\n          break;\r\n      }\r\n\r\n    } catch(error) {\r\n      if (error.code === DOMException.QUOTA_EXCEEDED_ERR && window.localStorage.length === 0)\r\n        errorMessage = \"Private browsing is unsupported\";\r\n      else\r\n        errorMessage = error.message;\r\n    }\r\n\r\n    if (resp) {\r\n      model.trigger(\"sync\", model, resp, options);\r\n      if (options && options.success)\r\n        options.success(resp);\r\n      if (syncDfd)\r\n        syncDfd.resolve(resp);\r\n\r\n    } else {\r\n      errorMessage = errorMessage ? errorMessage\r\n                                  : \"Record Not Found\";\r\n\r\n      if (options && options.error)\r\n        options.error(errorMessage);\r\n      if (syncDfd)\r\n        syncDfd.reject(errorMessage);\r\n    }\r\n\r\n    // add compatibility with $.ajax\r\n    // always execute callback for success and error\r\n    if (options && options.complete) options.complete(resp);\r\n\r\n    return syncDfd && syncDfd.promise();\r\n  };\r\n\r\n  entities.backends.LocalStorage = sync.LocalStorage = LocalStorage;\r\n  \r\n  return entities.backends.localSync = sync;\r\n\r\n});\ndefine('skylark-data-entities/main',[\r\n\t\"./entities\",\r\n\t\"./Collection\",\r\n\t\"./Entity\",\r\n\t\"./sync\",\r\n\t\"./backends/ajaxSync\",\r\n\t\"./backends/localSync\",\r\n\t\"./backends/registry\"\r\n],function(entities){\r\n\treturn entities;\r\n});\ndefine('skylark-data-entities', ['skylark-data-entities/main'], function (main) { return main; });\n\n"]}