{"version":3,"sources":["Plane.js"],"names":["define","numbers","Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","normal","constant","this","undefined","Object","assign","prototype","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","clone","constructor","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","console","warn","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals"],"mappings":"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","file":"../Plane.js","sourcesContent":["define([\r\n\t\"./numbers\",\r\n\t\"./Matrix3\",\r\n\t\"./Vector3\"\r\n] ,function(\r\n\tnumbers,\r\n\tMatrix3,\r\n\tVector3\r\n) {\r\n\r\n\r\n\tvar _vector1 = new Vector3();\r\n\tvar _vector2 = new Vector3();\r\n\tvar _normalMatrix = new Matrix3();\r\n\r\n\tfunction Plane( normal, constant ) {\r\n\r\n\t\t// normal is assumed to be normalized\r\n\r\n\t\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\r\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n\t}\r\n\r\n\tObject.assign( Plane.prototype, {\r\n\r\n\t\tset: function ( normal, constant ) {\r\n\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCoplanarPoints: function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tclone: function () {\r\n\r\n\t\t\treturn new this.constructor().copy( this );\r\n\r\n\t\t},\r\n\r\n\t\tcopy: function ( plane ) {\r\n\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnormalize: function () {\r\n\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tnegate: function () {\r\n\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToPoint: function ( point ) {\r\n\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t\t},\r\n\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t\t},\r\n\r\n\t\tprojectPoint: function ( point, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .projectPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\r\n\r\n\t\t},\r\n\r\n\t\tintersectLine: function ( line, target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .intersectLine() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar direction = line.delta( _vector1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn target.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsLine: function ( line ) {\r\n\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsBox: function ( box ) {\r\n\r\n\t\t\treturn box.intersectsPlane( this );\r\n\r\n\t\t},\r\n\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t\t},\r\n\r\n\t\tcoplanarPoint: function ( target ) {\r\n\r\n\t\t\tif ( target === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'mathsPlane: .coplanarPoint() target is now required' );\r\n\t\t\t\ttarget = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t\t},\r\n\r\n\t\tapplyMatrix4: function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\r\n\r\n\t\t\tvar referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\r\n\r\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\ttranslate: function ( offset ) {\r\n\r\n\t\t\tthis.constant -= offset.dot( this.normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t},\r\n\r\n\t\tequals: function ( plane ) {\r\n\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\r\n\treturn numbers.Plane = Plane;\r\n\r\n});"]}